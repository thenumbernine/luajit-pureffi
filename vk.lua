local ffi = require("ffi")
local mod = {}


	ffi.cdef[=[
		struct ANativeWindow;
		struct AHardwareBuffer;
		struct wl_display;
		struct wl_surface;
	 	struct _screen_context;
	 	struct _screen_window;
	 	struct _screen_buffer;
		typedef void* zx_handle_t;
		typedef void* HINSTANCE;
		typedef void* HWND;
		typedef void* HANDLE;
		typedef void* LPCWSTR;
		typedef void* DWORD;
		typedef void* xcb_window_t;
	]=]

	function mod.GetExtension(lib, instance, name)
		local ptr = lib.vkGetInstanceProcAddr(instance, name)

		if ptr == nil then error("extension function not found", 2) end

		local func = ffi.cast(mod["PFN_" .. name], ptr)
		return func
	end

	function mod.find_library()
		local function try_load(tbl)
			local errors = {}

			for _, name in ipairs(tbl) do
				local status, lib = pcall(ffi.load, name)

				if status then
					print("Loaded Vulkan library:", name)
					return lib else table.insert(errors, lib) end
			end

			return nil, table.concat(errors, "\n")
		end

		if ffi.os == "Windows" then
			return assert(try_load({"vulkan-1.dll"}))
		elseif ffi.os == "OSX" then
			-- Try user's home directory first (expand ~ manually)
			local home = os.getenv("HOME")
			local vulkan_sdk = os.getenv("VULKAN_SDK")
			local paths = {}

			-- Try MoltenVK directly first (more reliable on macOS)
			if home then
				if vulkan_sdk then
					table.insert(paths, home .. "/VulkanSDK/1.4.328.1/macOS/lib/libvulkan.1.dylib")
				end
				table.insert(paths, home .. "/VulkanSDK/1.4.328.1/macOS/lib/libMoltenVK.dylib")
			end

			-- Try VULKAN_SDK environment variable
			if vulkan_sdk then
				table.insert(paths, vulkan_sdk .. "/lib/libMoltenVK.dylib")
				table.insert(paths, vulkan_sdk .. "/lib/libvulkan.dylib")
			end

			-- Try standard locations
			table.insert(paths, "libMoltenVK.dylib")
			table.insert(paths, "libvulkan.dylib")
			table.insert(paths, "libvulkan.1.dylib")
			table.insert(paths, "/usr/local/lib/libvulkan.dylib")
			return assert(try_load(paths))
		end

		return assert(try_load({"libvulkan.so", "libvulkan.so.1"}))
	end


do -- Preprocessor Definitions
	mod.STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS = 6
	mod.STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS = 2
	mod.STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS = 8
	mod.STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS = 4
	mod.STD_VIDEO_AV1_MAX_NUM_CB_POINTS = 10
	mod.STD_VIDEO_AV1_MAX_NUM_CR_POINTS = 10
	mod.STD_VIDEO_AV1_MAX_NUM_PLANES = 3
	mod.STD_VIDEO_AV1_MAX_NUM_POS_CHROMA = 25
	mod.STD_VIDEO_AV1_MAX_NUM_POS_LUMA = 24
	mod.STD_VIDEO_AV1_MAX_NUM_Y_POINTS = 14
	mod.STD_VIDEO_AV1_MAX_SEGMENTS = 8
	mod.STD_VIDEO_AV1_MAX_TILE_COLS = 64
	mod.STD_VIDEO_AV1_MAX_TILE_ROWS = 64
	mod.STD_VIDEO_AV1_NUM_REF_FRAMES = 8
	mod.STD_VIDEO_AV1_PRIMARY_REF_NONE = 7
	mod.STD_VIDEO_AV1_REFS_PER_FRAME = 7
	mod.STD_VIDEO_AV1_SEG_LVL_MAX = 8
	mod.STD_VIDEO_AV1_SELECT_INTEGER_MV = 2
	mod.STD_VIDEO_AV1_SELECT_SCREEN_CONTENT_TOOLS = 2
	mod.STD_VIDEO_AV1_SKIP_MODE_FRAMES = 2
	mod.STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME = 8
	mod.STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE = 2
	mod.STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE = 8
	mod.STD_VIDEO_H264_CPB_CNT_LIST_SIZE = 32
	mod.STD_VIDEO_H264_MAX_CHROMA_PLANES = 2
	mod.STD_VIDEO_H264_MAX_NUM_LIST_REF = 32
	mod.STD_VIDEO_H264_NO_REFERENCE_PICTURE = 0xFF
	mod.STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS = 16
	mod.STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS = 6
	mod.STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS = 64
	mod.STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS = 6
	mod.STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE = 6
	mod.STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE = 19
	mod.STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE = 21
	mod.STD_VIDEO_H265_CPB_CNT_LIST_SIZE = 32
	mod.STD_VIDEO_H265_MAX_CHROMA_PLANES = 2
	mod.STD_VIDEO_H265_MAX_DELTA_POC = 48
	mod.STD_VIDEO_H265_MAX_DPB_SIZE = 16
	mod.STD_VIDEO_H265_MAX_LONG_TERM_PICS = 16
	mod.STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS = 32
	mod.STD_VIDEO_H265_MAX_NUM_LIST_REF = 15
	mod.STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS = 64
	mod.STD_VIDEO_H265_NO_REFERENCE_PICTURE = 0xFF
	mod.STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE = 3
	mod.STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE = 128
	mod.STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS = 64
	mod.STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS = 6
	mod.STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS = 64
	mod.STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS = 2
	mod.STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS = 16
	mod.STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS = 6
	mod.STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS = 64
	mod.STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS = 6
	mod.STD_VIDEO_H265_SUBLAYERS_LIST_SIZE = 7
	mod.STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS = 2
	mod.STD_VIDEO_VP9_MAX_REF_FRAMES = 4
	mod.STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB = 3
	mod.STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS = 7
	mod.STD_VIDEO_VP9_MAX_SEGMENTS = 8
	mod.STD_VIDEO_VP9_NUM_REF_FRAMES = 8
	mod.STD_VIDEO_VP9_REFS_PER_FRAME = 3
	mod.STD_VIDEO_VP9_SEG_LVL_MAX = 4
	mod.VK_AMD_ANTI_LAG_EXTENSION_NAME = "VK_AMD_anti_lag"
	mod.VK_AMD_ANTI_LAG_SPEC_VERSION = 1
	mod.VK_AMD_BUFFER_MARKER_EXTENSION_NAME = "VK_AMD_buffer_marker"
	mod.VK_AMD_BUFFER_MARKER_SPEC_VERSION = 1
	mod.VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME = "VK_AMD_device_coherent_memory"
	mod.VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION = 1
	mod.VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = "VK_AMD_display_native_hdr"
	mod.VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION = 1
	mod.VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_AMD_draw_indirect_count"
	mod.VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION = 2
	mod.VK_AMD_GCN_SHADER_EXTENSION_NAME = "VK_AMD_gcn_shader"
	mod.VK_AMD_GCN_SHADER_SPEC_VERSION = 1
	mod.VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = "VK_AMD_gpu_shader_half_float"
	mod.VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION = 2
	mod.VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME = "VK_AMD_gpu_shader_int16"
	mod.VK_AMD_GPU_SHADER_INT16_SPEC_VERSION = 2
	mod.VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = "VK_AMD_memory_overallocation_behavior"
	mod.VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION = 1
	mod.VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = "VK_AMD_mixed_attachment_samples"
	mod.VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION = 1
	mod.VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = "VK_AMD_negative_viewport_height"
	mod.VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION = 1
	mod.VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME = "VK_AMD_pipeline_compiler_control"
	mod.VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION = 1
	mod.VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME = "VK_AMD_rasterization_order"
	mod.VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_BALLOT_EXTENSION_NAME = "VK_AMD_shader_ballot"
	mod.VK_AMD_SHADER_BALLOT_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME = "VK_AMD_shader_core_properties2"
	mod.VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_AMD_shader_core_properties"
	mod.VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION = 2
	mod.VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME = "VK_AMD_shader_early_and_late_fragment_tests"
	mod.VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = "VK_AMD_shader_explicit_vertex_parameter"
	mod.VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = "VK_AMD_shader_fragment_mask"
	mod.VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = "VK_AMD_shader_image_load_store_lod"
	mod.VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_INFO_EXTENSION_NAME = "VK_AMD_shader_info"
	mod.VK_AMD_SHADER_INFO_SPEC_VERSION = 1
	mod.VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = "VK_AMD_shader_trinary_minmax"
	mod.VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION = 1
	mod.VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = "VK_AMD_texture_gather_bias_lod"
	mod.VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION = 1
	mod.VK_AMD_anti_lag = 1
	mod.VK_AMD_buffer_marker = 1
	mod.VK_AMD_device_coherent_memory = 1
	mod.VK_AMD_display_native_hdr = 1
	mod.VK_AMD_draw_indirect_count = 1
	mod.VK_AMD_gcn_shader = 1
	mod.VK_AMD_gpu_shader_half_float = 1
	mod.VK_AMD_gpu_shader_int16 = 1
	mod.VK_AMD_memory_overallocation_behavior = 1
	mod.VK_AMD_mixed_attachment_samples = 1
	mod.VK_AMD_negative_viewport_height = 1
	mod.VK_AMD_pipeline_compiler_control = 1
	mod.VK_AMD_rasterization_order = 1
	mod.VK_AMD_shader_ballot = 1
	mod.VK_AMD_shader_core_properties = 1
	mod.VK_AMD_shader_core_properties2 = 1
	mod.VK_AMD_shader_early_and_late_fragment_tests = 1
	mod.VK_AMD_shader_explicit_vertex_parameter = 1
	mod.VK_AMD_shader_fragment_mask = 1
	mod.VK_AMD_shader_image_load_store_lod = 1
	mod.VK_AMD_shader_info = 1
	mod.VK_AMD_shader_trinary_minmax = 1
	mod.VK_AMD_texture_gather_bias_lod = 1
	mod.VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME = "VK_ANDROID_external_format_resolve"
	mod.VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION = 1
	mod.VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME = "VK_ANDROID_external_memory_android_hardware_buffer"
	mod.VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 5
	mod.VK_ANDROID_external_format_resolve = 1
	mod.VK_ANDROID_external_memory_android_hardware_buffer = 1
	mod.VK_API_VERSION_1_0 = bit.bor( bit.lshift( ffi.cast("uint32_t", 0) , 29) ,  bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_API_VERSION_1_1 = bit.bor( bit.lshift( ffi.cast("uint32_t", 0) , 29) ,  bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 1) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_API_VERSION_1_2 = bit.bor( bit.lshift( ffi.cast("uint32_t", 0) , 29) ,  bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 2) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_API_VERSION_1_3 = bit.bor( bit.lshift( ffi.cast("uint32_t", 0) , 29) ,  bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 3) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_API_VERSION_1_4 = bit.bor( bit.lshift( ffi.cast("uint32_t", 0) , 29) ,  bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 4) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_ARM_DATA_GRAPH_EXTENSION_NAME = "VK_ARM_data_graph"
	mod.VK_ARM_DATA_GRAPH_SPEC_VERSION = 1
	mod.VK_ARM_FORMAT_PACK_EXTENSION_NAME = "VK_ARM_format_pack"
	mod.VK_ARM_FORMAT_PACK_SPEC_VERSION = 1
	mod.VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME = "VK_ARM_pipeline_opacity_micromap"
	mod.VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION = 1
	mod.VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_ARM_rasterization_order_attachment_access"
	mod.VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION = 1
	mod.VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME = "VK_ARM_render_pass_striped"
	mod.VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION = 1
	mod.VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME = "VK_ARM_scheduling_controls"
	mod.VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION = 1
	mod.VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME = "VK_ARM_shader_core_builtins"
	mod.VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION = 2
	mod.VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_ARM_shader_core_properties"
	mod.VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION = 1
	mod.VK_ARM_TENSORS_EXTENSION_NAME = "VK_ARM_tensors"
	mod.VK_ARM_TENSORS_SPEC_VERSION = 1
	mod.VK_ARM_data_graph = 1
	mod.VK_ARM_format_pack = 1
	mod.VK_ARM_pipeline_opacity_micromap = 1
	mod.VK_ARM_rasterization_order_attachment_access = 1
	mod.VK_ARM_render_pass_striped = 1
	mod.VK_ARM_scheduling_controls = 1
	mod.VK_ARM_shader_core_builtins = 1
	mod.VK_ARM_shader_core_properties = 1
	mod.VK_ARM_tensors = 1
	mod.VK_ATTACHMENT_UNUSED =  bit.bnot(0) 
	mod.VK_EXT_4444_FORMATS_EXTENSION_NAME = "VK_EXT_4444_formats"
	mod.VK_EXT_4444_FORMATS_SPEC_VERSION = 1
	mod.VK_EXT_4444_formats = 1
	mod.VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME = "VK_EXT_acquire_drm_display"
	mod.VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION = 1
	mod.VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME = "VK_EXT_astc_decode_mode"
	mod.VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION = 1
	mod.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_attachment_feedback_loop_dynamic_state"
	mod.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION = 1
	mod.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME = "VK_EXT_attachment_feedback_loop_layout"
	mod.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION = 2
	mod.VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = "VK_EXT_blend_operation_advanced"
	mod.VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION = 2
	mod.VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME = "VK_EXT_border_color_swizzle"
	mod.VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION = 1
	mod.VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_EXT_buffer_device_address"
	mod.VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 2
	mod.VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_EXT_calibrated_timestamps"
	mod.VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 2
	mod.VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME = "VK_EXT_color_write_enable"
	mod.VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION = 1
	mod.VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = "VK_EXT_conditional_rendering"
	mod.VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION = 2
	mod.VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_conservative_rasterization"
	mod.VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION = 1
	mod.VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME = "VK_EXT_custom_border_color"
	mod.VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION = 12
	mod.VK_EXT_DEBUG_MARKER_EXTENSION_NAME = "VK_EXT_debug_marker"
	mod.VK_EXT_DEBUG_MARKER_SPEC_VERSION = 4
	mod.VK_EXT_DEBUG_REPORT_EXTENSION_NAME = "VK_EXT_debug_report"
	mod.VK_EXT_DEBUG_REPORT_SPEC_VERSION = 10
	mod.VK_EXT_DEBUG_UTILS_EXTENSION_NAME = "VK_EXT_debug_utils"
	mod.VK_EXT_DEBUG_UTILS_SPEC_VERSION = 2
	mod.VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME = "VK_EXT_depth_bias_control"
	mod.VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME = "VK_EXT_depth_clamp_control"
	mod.VK_EXT_DEPTH_CLAMP_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME = "VK_EXT_depth_clamp_zero_one"
	mod.VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME = "VK_EXT_depth_clip_control"
	mod.VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = "VK_EXT_depth_clip_enable"
	mod.VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION = 1
	mod.VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = "VK_EXT_depth_range_unrestricted"
	mod.VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION = 1
	mod.VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME = "VK_EXT_descriptor_buffer"
	mod.VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION = 1
	mod.VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = "VK_EXT_descriptor_indexing"
	mod.VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION = 2
	mod.VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME = "VK_EXT_device_address_binding_report"
	mod.VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION = 1
	mod.VK_EXT_DEVICE_FAULT_EXTENSION_NAME = "VK_EXT_device_fault"
	mod.VK_EXT_DEVICE_FAULT_SPEC_VERSION = 2
	mod.VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_EXT_device_generated_commands"
	mod.VK_EXT_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 1
	mod.VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME = "VK_EXT_device_memory_report"
	mod.VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION = 2
	mod.VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME = "VK_EXT_directfb_surface"
	mod.VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION = 1
	mod.VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = "VK_EXT_direct_mode_display"
	mod.VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION = 1
	mod.VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME = "VK_EXT_discard_rectangles"
	mod.VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION = 2
	mod.VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME = "VK_EXT_display_control"
	mod.VK_EXT_DISPLAY_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = "VK_EXT_display_surface_counter"
	mod.VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION = 1
	mod.VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME = "VK_EXT_dynamic_rendering_unused_attachments"
	mod.VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION = 1
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME = "VK_EXT_extended_dynamic_state2"
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION = 1
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME = "VK_EXT_extended_dynamic_state3"
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION = 2
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_extended_dynamic_state"
	mod.VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION = 1
	mod.VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME = "VK_EXT_external_memory_acquire_unmodified"
	mod.VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION = 1
	mod.VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = "VK_EXT_external_memory_dma_buf"
	mod.VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION = 1
	mod.VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = "VK_EXT_external_memory_host"
	mod.VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION = 1
	mod.VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME = "VK_EXT_external_memory_metal"
	mod.VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION = 1
	mod.VK_EXT_FILTER_CUBIC_EXTENSION_NAME = "VK_EXT_filter_cubic"
	mod.VK_EXT_FILTER_CUBIC_SPEC_VERSION = 3
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME = "VK_EXT_fragment_density_map2"
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION = 1
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = "VK_EXT_fragment_density_map"
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = "VK_EXT_fragment_density_map_offset"
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION = 1
	mod.VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION = 2
	mod.VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME = "VK_EXT_fragment_shader_interlock"
	mod.VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION = 1
	mod.VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME = "VK_EXT_frame_boundary"
	mod.VK_EXT_FRAME_BOUNDARY_SPEC_VERSION = 1
	mod.VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_EXT_global_priority"
	mod.VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME = "VK_EXT_global_priority_query"
	mod.VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION = 1
	mod.VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION = 2
	mod.VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_EXT_graphics_pipeline_library"
	mod.VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION = 1
	mod.VK_EXT_HDR_METADATA_EXTENSION_NAME = "VK_EXT_hdr_metadata"
	mod.VK_EXT_HDR_METADATA_SPEC_VERSION = 3
	mod.VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME = "VK_EXT_headless_surface"
	mod.VK_EXT_HEADLESS_SURFACE_SPEC_VERSION = 1
	mod.VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME = "VK_EXT_host_image_copy"
	mod.VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION = 1
	mod.VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME = "VK_EXT_host_query_reset"
	mod.VK_EXT_HOST_QUERY_RESET_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME = "VK_EXT_image_2d_view_of_3d"
	mod.VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME = "VK_EXT_image_compression_control"
	mod.VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME = "VK_EXT_image_compression_control_swapchain"
	mod.VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = "VK_EXT_image_drm_format_modifier"
	mod.VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION = 2
	mod.VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_image_robustness"
	mod.VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME = "VK_EXT_image_sliced_view_of_3d"
	mod.VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION = 1
	mod.VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME = "VK_EXT_image_view_min_lod"
	mod.VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION = 1
	mod.VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_EXT_index_type_uint8"
	mod.VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION = 1
	mod.VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = "VK_EXT_inline_uniform_block"
	mod.VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION = 1
	mod.VK_EXT_LAYER_SETTINGS_EXTENSION_NAME = "VK_EXT_layer_settings"
	mod.VK_EXT_LAYER_SETTINGS_SPEC_VERSION = 2
	mod.VK_EXT_LEGACY_DITHERING_EXTENSION_NAME = "VK_EXT_legacy_dithering"
	mod.VK_EXT_LEGACY_DITHERING_SPEC_VERSION = 2
	mod.VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME = "VK_EXT_legacy_vertex_attributes"
	mod.VK_EXT_LEGACY_VERTEX_ATTRIBUTES_SPEC_VERSION = 1
	mod.VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_line_rasterization"
	mod.VK_EXT_LINE_RASTERIZATION_SPEC_VERSION = 1
	mod.VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME = "VK_EXT_load_store_op_none"
	mod.VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION = 1
	mod.VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME = "VK_EXT_map_memory_placed"
	mod.VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION = 1
	mod.VK_EXT_MEMORY_BUDGET_EXTENSION_NAME = "VK_EXT_memory_budget"
	mod.VK_EXT_MEMORY_BUDGET_SPEC_VERSION = 1
	mod.VK_EXT_MEMORY_DECOMPRESSION_EXTENSION_NAME = "VK_EXT_memory_decompression"
	mod.VK_EXT_MEMORY_DECOMPRESSION_SPEC_VERSION = 1
	mod.VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME = "VK_EXT_memory_priority"
	mod.VK_EXT_MEMORY_PRIORITY_SPEC_VERSION = 1
	mod.VK_EXT_MESH_SHADER_EXTENSION_NAME = "VK_EXT_mesh_shader"
	mod.VK_EXT_MESH_SHADER_SPEC_VERSION = 1
	mod.VK_EXT_METAL_OBJECTS_EXTENSION_NAME = "VK_EXT_metal_objects"
	mod.VK_EXT_METAL_OBJECTS_SPEC_VERSION = 2
	mod.VK_EXT_METAL_SURFACE_EXTENSION_NAME = "VK_EXT_metal_surface"
	mod.VK_EXT_METAL_SURFACE_SPEC_VERSION = 1
	mod.VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME = "VK_EXT_multisampled_render_to_single_sampled"
	mod.VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION = 1
	mod.VK_EXT_MULTI_DRAW_EXTENSION_NAME = "VK_EXT_multi_draw"
	mod.VK_EXT_MULTI_DRAW_SPEC_VERSION = 1
	mod.VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_EXT_mutable_descriptor_type"
	mod.VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION = 1
	mod.VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME = "VK_EXT_nested_command_buffer"
	mod.VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION = 1
	mod.VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME = "VK_EXT_non_seamless_cube_map"
	mod.VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION = 1
	mod.VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME = "VK_EXT_opacity_micromap"
	mod.VK_EXT_OPACITY_MICROMAP_SPEC_VERSION = 2
	mod.VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME = "VK_EXT_pageable_device_local_memory"
	mod.VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION = 1
	mod.VK_EXT_PCI_BUS_INFO_EXTENSION_NAME = "VK_EXT_pci_bus_info"
	mod.VK_EXT_PCI_BUS_INFO_SPEC_VERSION = 2
	mod.VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME = "VK_EXT_physical_device_drm"
	mod.VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME = "VK_EXT_pipeline_creation_cache_control"
	mod.VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION = 3
	mod.VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = "VK_EXT_pipeline_creation_feedback"
	mod.VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME = "VK_EXT_pipeline_library_group_handles"
	mod.VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME = "VK_EXT_pipeline_properties"
	mod.VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME = "VK_EXT_pipeline_protected_access"
	mod.VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION = 1
	mod.VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_pipeline_robustness"
	mod.VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION = 1
	mod.VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = "VK_EXT_post_depth_coverage"
	mod.VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION = 1
	mod.VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME = "VK_EXT_present_mode_fifo_latest_ready"
	mod.VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION = 1
	mod.VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME = "VK_EXT_primitives_generated_query"
	mod.VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION = 1
	mod.VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME = "VK_EXT_primitive_topology_list_restart"
	mod.VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION = 1
	mod.VK_EXT_PRIVATE_DATA_EXTENSION_NAME = "VK_EXT_private_data"
	mod.VK_EXT_PRIVATE_DATA_SPEC_VERSION = 1
	mod.VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME = "VK_EXT_provoking_vertex"
	mod.VK_EXT_PROVOKING_VERTEX_SPEC_VERSION = 1
	mod.VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = "VK_EXT_queue_family_foreign"
	mod.VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION = 1
	mod.VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_EXT_rasterization_order_attachment_access"
	mod.VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION = 1
	mod.VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME = "VK_EXT_rgba10x6_formats"
	mod.VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION = 1
	mod.VK_EXT_ROBUSTNESS_2_EXTENSION_NAME = "VK_EXT_robustness2"
	mod.VK_EXT_ROBUSTNESS_2_SPEC_VERSION = 1
	mod.VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = "VK_EXT_sampler_filter_minmax"
	mod.VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION = 2
	mod.VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = "VK_EXT_sample_locations"
	mod.VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION = 1
	mod.VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = "VK_EXT_scalar_block_layout"
	mod.VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION = 1
	mod.VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = "VK_EXT_separate_stencil_usage"
	mod.VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME = "VK_EXT_shader_64bit_indexing"
	mod.VK_EXT_SHADER_64BIT_INDEXING_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME = "VK_EXT_shader_atomic_float2"
	mod.VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME = "VK_EXT_shader_atomic_float"
	mod.VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME = "VK_EXT_shader_demote_to_helper_invocation"
	mod.VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_FLOAT8_EXTENSION_NAME = "VK_EXT_shader_float8"
	mod.VK_EXT_SHADER_FLOAT8_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME = "VK_EXT_shader_image_atomic_int64"
	mod.VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME = "VK_EXT_shader_module_identifier"
	mod.VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_OBJECT_EXTENSION_NAME = "VK_EXT_shader_object"
	mod.VK_EXT_SHADER_OBJECT_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME = "VK_EXT_shader_replicated_composites"
	mod.VK_EXT_SHADER_REPLICATED_COMPOSITES_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = "VK_EXT_shader_stencil_export"
	mod.VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = "VK_EXT_shader_subgroup_ballot"
	mod.VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = "VK_EXT_shader_subgroup_vote"
	mod.VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME = "VK_EXT_shader_tile_image"
	mod.VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_EXTENSION_NAME = "VK_EXT_shader_uniform_buffer_unsized_array"
	mod.VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_SPEC_VERSION = 1
	mod.VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = "VK_EXT_shader_viewport_index_layer"
	mod.VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION = 1
	mod.VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME = "VK_EXT_subgroup_size_control"
	mod.VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION = 2
	mod.VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME = "VK_EXT_subpass_merge_feedback"
	mod.VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION = 2
	mod.VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME = "VK_EXT_surface_maintenance1"
	mod.VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = "VK_EXT_swapchain_colorspace"
	mod.VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION = 5
	mod.VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME = "VK_EXT_swapchain_maintenance1"
	mod.VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME = "VK_EXT_texel_buffer_alignment"
	mod.VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION = 1
	mod.VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME = "VK_EXT_texture_compression_astc_hdr"
	mod.VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION = 1
	mod.VK_EXT_TOOLING_INFO_EXTENSION_NAME = "VK_EXT_tooling_info"
	mod.VK_EXT_TOOLING_INFO_SPEC_VERSION = 1
	mod.VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = "VK_EXT_transform_feedback"
	mod.VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION = 1
	mod.VK_EXT_VALIDATION_CACHE_EXTENSION_NAME = "VK_EXT_validation_cache"
	mod.VK_EXT_VALIDATION_CACHE_SPEC_VERSION = 1
	mod.VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME = "VK_EXT_validation_features"
	mod.VK_EXT_VALIDATION_FEATURES_SPEC_VERSION = 6
	mod.VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME = "VK_EXT_validation_flags"
	mod.VK_EXT_VALIDATION_FLAGS_SPEC_VERSION = 3
	mod.VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_EXT_vertex_attribute_divisor"
	mod.VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 3
	mod.VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_vertex_attribute_robustness"
	mod.VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION = 1
	mod.VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_vertex_input_dynamic_state"
	mod.VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION = 2
	mod.VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME = "VK_EXT_ycbcr_2plane_444_formats"
	mod.VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION = 1
	mod.VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = "VK_EXT_ycbcr_image_arrays"
	mod.VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION = 1
	mod.VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME = "VK_EXT_zero_initialize_device_memory"
	mod.VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_SPEC_VERSION = 1
	mod.VK_EXT_acquire_drm_display = 1
	mod.VK_EXT_astc_decode_mode = 1
	mod.VK_EXT_attachment_feedback_loop_dynamic_state = 1
	mod.VK_EXT_attachment_feedback_loop_layout = 1
	mod.VK_EXT_blend_operation_advanced = 1
	mod.VK_EXT_border_color_swizzle = 1
	mod.VK_EXT_buffer_device_address = 1
	mod.VK_EXT_calibrated_timestamps = 1
	mod.VK_EXT_color_write_enable = 1
	mod.VK_EXT_conditional_rendering = 1
	mod.VK_EXT_conservative_rasterization = 1
	mod.VK_EXT_custom_border_color = 1
	mod.VK_EXT_debug_marker = 1
	mod.VK_EXT_debug_report = 1
	mod.VK_EXT_debug_utils = 1
	mod.VK_EXT_depth_bias_control = 1
	mod.VK_EXT_depth_clamp_control = 1
	mod.VK_EXT_depth_clamp_zero_one = 1
	mod.VK_EXT_depth_clip_control = 1
	mod.VK_EXT_depth_clip_enable = 1
	mod.VK_EXT_depth_range_unrestricted = 1
	mod.VK_EXT_descriptor_buffer = 1
	mod.VK_EXT_descriptor_indexing = 1
	mod.VK_EXT_device_address_binding_report = 1
	mod.VK_EXT_device_fault = 1
	mod.VK_EXT_device_generated_commands = 1
	mod.VK_EXT_device_memory_report = 1
	mod.VK_EXT_direct_mode_display = 1
	mod.VK_EXT_directfb_surface = 1
	mod.VK_EXT_discard_rectangles = 1
	mod.VK_EXT_display_control = 1
	mod.VK_EXT_display_surface_counter = 1
	mod.VK_EXT_dynamic_rendering_unused_attachments = 1
	mod.VK_EXT_extended_dynamic_state = 1
	mod.VK_EXT_extended_dynamic_state2 = 1
	mod.VK_EXT_extended_dynamic_state3 = 1
	mod.VK_EXT_external_memory_acquire_unmodified = 1
	mod.VK_EXT_external_memory_dma_buf = 1
	mod.VK_EXT_external_memory_host = 1
	mod.VK_EXT_external_memory_metal = 1
	mod.VK_EXT_filter_cubic = 1
	mod.VK_EXT_fragment_density_map = 1
	mod.VK_EXT_fragment_density_map2 = 1
	mod.VK_EXT_fragment_density_map_offset = 1
	mod.VK_EXT_fragment_shader_interlock = 1
	mod.VK_EXT_frame_boundary = 1
	mod.VK_EXT_global_priority = 1
	mod.VK_EXT_global_priority_query = 1
	mod.VK_EXT_graphics_pipeline_library = 1
	mod.VK_EXT_hdr_metadata = 1
	mod.VK_EXT_headless_surface = 1
	mod.VK_EXT_host_image_copy = 1
	mod.VK_EXT_host_query_reset = 1
	mod.VK_EXT_image_2d_view_of_3d = 1
	mod.VK_EXT_image_compression_control = 1
	mod.VK_EXT_image_compression_control_swapchain = 1
	mod.VK_EXT_image_drm_format_modifier = 1
	mod.VK_EXT_image_robustness = 1
	mod.VK_EXT_image_sliced_view_of_3d = 1
	mod.VK_EXT_image_view_min_lod = 1
	mod.VK_EXT_index_type_uint8 = 1
	mod.VK_EXT_inline_uniform_block = 1
	mod.VK_EXT_layer_settings = 1
	mod.VK_EXT_legacy_dithering = 1
	mod.VK_EXT_legacy_vertex_attributes = 1
	mod.VK_EXT_line_rasterization = 1
	mod.VK_EXT_load_store_op_none = 1
	mod.VK_EXT_map_memory_placed = 1
	mod.VK_EXT_memory_budget = 1
	mod.VK_EXT_memory_decompression = 1
	mod.VK_EXT_memory_priority = 1
	mod.VK_EXT_mesh_shader = 1
	mod.VK_EXT_metal_objects = 1
	mod.VK_EXT_metal_surface = 1
	mod.VK_EXT_multi_draw = 1
	mod.VK_EXT_multisampled_render_to_single_sampled = 1
	mod.VK_EXT_mutable_descriptor_type = 1
	mod.VK_EXT_nested_command_buffer = 1
	mod.VK_EXT_non_seamless_cube_map = 1
	mod.VK_EXT_opacity_micromap = 1
	mod.VK_EXT_pageable_device_local_memory = 1
	mod.VK_EXT_pci_bus_info = 1
	mod.VK_EXT_physical_device_drm = 1
	mod.VK_EXT_pipeline_creation_cache_control = 1
	mod.VK_EXT_pipeline_creation_feedback = 1
	mod.VK_EXT_pipeline_library_group_handles = 1
	mod.VK_EXT_pipeline_properties = 1
	mod.VK_EXT_pipeline_protected_access = 1
	mod.VK_EXT_pipeline_robustness = 1
	mod.VK_EXT_post_depth_coverage = 1
	mod.VK_EXT_present_mode_fifo_latest_ready = 1
	mod.VK_EXT_primitive_topology_list_restart = 1
	mod.VK_EXT_primitives_generated_query = 1
	mod.VK_EXT_private_data = 1
	mod.VK_EXT_provoking_vertex = 1
	mod.VK_EXT_queue_family_foreign = 1
	mod.VK_EXT_rasterization_order_attachment_access = 1
	mod.VK_EXT_rgba10x6_formats = 1
	mod.VK_EXT_robustness2 = 1
	mod.VK_EXT_sample_locations = 1
	mod.VK_EXT_sampler_filter_minmax = 1
	mod.VK_EXT_scalar_block_layout = 1
	mod.VK_EXT_separate_stencil_usage = 1
	mod.VK_EXT_shader_64bit_indexing = 1
	mod.VK_EXT_shader_atomic_float = 1
	mod.VK_EXT_shader_atomic_float2 = 1
	mod.VK_EXT_shader_demote_to_helper_invocation = 1
	mod.VK_EXT_shader_float8 = 1
	mod.VK_EXT_shader_image_atomic_int64 = 1
	mod.VK_EXT_shader_module_identifier = 1
	mod.VK_EXT_shader_object = 1
	mod.VK_EXT_shader_replicated_composites = 1
	mod.VK_EXT_shader_stencil_export = 1
	mod.VK_EXT_shader_subgroup_ballot = 1
	mod.VK_EXT_shader_subgroup_vote = 1
	mod.VK_EXT_shader_tile_image = 1
	mod.VK_EXT_shader_uniform_buffer_unsized_array = 1
	mod.VK_EXT_shader_viewport_index_layer = 1
	mod.VK_EXT_subgroup_size_control = 1
	mod.VK_EXT_subpass_merge_feedback = 1
	mod.VK_EXT_surface_maintenance1 = 1
	mod.VK_EXT_swapchain_colorspace = 1
	mod.VK_EXT_swapchain_maintenance1 = 1
	mod.VK_EXT_texel_buffer_alignment = 1
	mod.VK_EXT_texture_compression_astc_hdr = 1
	mod.VK_EXT_tooling_info = 1
	mod.VK_EXT_transform_feedback = 1
	mod.VK_EXT_validation_cache = 1
	mod.VK_EXT_validation_features = 1
	mod.VK_EXT_validation_flags = 1
	mod.VK_EXT_vertex_attribute_divisor = 1
	mod.VK_EXT_vertex_attribute_robustness = 1
	mod.VK_EXT_vertex_input_dynamic_state = 1
	mod.VK_EXT_ycbcr_2plane_444_formats = 1
	mod.VK_EXT_ycbcr_image_arrays = 1
	mod.VK_EXT_zero_initialize_device_memory = 1
	mod.VK_FALSE = 0
	mod.VK_GGP_FRAME_TOKEN_EXTENSION_NAME = "VK_GGP_frame_token"
	mod.VK_GGP_FRAME_TOKEN_SPEC_VERSION = 1
	mod.VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME = "VK_GGP_stream_descriptor_surface"
	mod.VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION = 1
	mod.VK_GGP_frame_token = 1
	mod.VK_GGP_stream_descriptor_surface = 1
	mod.VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME = "VK_GOOGLE_decorate_string"
	mod.VK_GOOGLE_DECORATE_STRING_SPEC_VERSION = 1
	mod.VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = "VK_GOOGLE_display_timing"
	mod.VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION = 1
	mod.VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME = "VK_GOOGLE_hlsl_functionality1"
	mod.VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION = 1
	mod.VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME = "VK_GOOGLE_hlsl_functionality1"
	mod.VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION = 1
	mod.VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME = "VK_GOOGLE_surfaceless_query"
	mod.VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION = 2
	mod.VK_GOOGLE_USER_TYPE_EXTENSION_NAME = "VK_GOOGLE_user_type"
	mod.VK_GOOGLE_USER_TYPE_SPEC_VERSION = 1
	mod.VK_GOOGLE_decorate_string = 1
	mod.VK_GOOGLE_display_timing = 1
	mod.VK_GOOGLE_hlsl_functionality1 = 1
	mod.VK_GOOGLE_surfaceless_query = 1
	mod.VK_GOOGLE_user_type = 1
	mod.VK_HEADER_VERSION = 330
	mod.VK_HEADER_VERSION_COMPLETE = bit.bor( bit.lshift( ffi.cast("uint32_t", 0) , 29) ,  bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 4) , 12) ,  ffi.cast("uint32_t", 330) )
	mod.VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME = "VK_HUAWEI_cluster_culling_shader"
	mod.VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION = 3
	mod.VK_HUAWEI_HDR_VIVID_EXTENSION_NAME = "VK_HUAWEI_hdr_vivid"
	mod.VK_HUAWEI_HDR_VIVID_SPEC_VERSION = 1
	mod.VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME = "VK_HUAWEI_invocation_mask"
	mod.VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION = 1
	mod.VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME = "VK_HUAWEI_subpass_shading"
	mod.VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION = 3
	mod.VK_HUAWEI_cluster_culling_shader = 1
	mod.VK_HUAWEI_hdr_vivid = 1
	mod.VK_HUAWEI_invocation_mask = 1
	mod.VK_HUAWEI_subpass_shading = 1
	mod.VK_IMG_FILTER_CUBIC_EXTENSION_NAME = "VK_IMG_filter_cubic"
	mod.VK_IMG_FILTER_CUBIC_SPEC_VERSION = 1
	mod.VK_IMG_FORMAT_PVRTC_EXTENSION_NAME = "VK_IMG_format_pvrtc"
	mod.VK_IMG_FORMAT_PVRTC_SPEC_VERSION = 1
	mod.VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME = "VK_IMG_relaxed_line_rasterization"
	mod.VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION = 1
	mod.VK_IMG_filter_cubic = 1
	mod.VK_IMG_format_pvrtc = 1
	mod.VK_IMG_relaxed_line_rasterization = 1
	mod.VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_INTEL_performance_query"
	mod.VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION = 2
	mod.VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME = "VK_INTEL_shader_integer_functions2"
	mod.VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION = 1
	mod.VK_INTEL_performance_query = 1
	mod.VK_INTEL_shader_integer_functions2 = 1
	mod.VK_KHR_16BIT_STORAGE_EXTENSION_NAME = "VK_KHR_16bit_storage"
	mod.VK_KHR_16BIT_STORAGE_SPEC_VERSION = 1
	mod.VK_KHR_16bit_storage = 1
	mod.VK_KHR_8BIT_STORAGE_EXTENSION_NAME = "VK_KHR_8bit_storage"
	mod.VK_KHR_8BIT_STORAGE_SPEC_VERSION = 1
	mod.VK_KHR_8bit_storage = 1
	mod.VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_KHR_acceleration_structure"
	mod.VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION = 13
	mod.VK_KHR_ANDROID_SURFACE_EXTENSION_NAME = "VK_KHR_android_surface"
	mod.VK_KHR_ANDROID_SURFACE_SPEC_VERSION = 6
	mod.VK_KHR_BIND_MEMORY_2_EXTENSION_NAME = "VK_KHR_bind_memory2"
	mod.VK_KHR_BIND_MEMORY_2_SPEC_VERSION = 1
	mod.VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_KHR_buffer_device_address"
	mod.VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 1
	mod.VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_KHR_calibrated_timestamps"
	mod.VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 1
	mod.VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_KHR_compute_shader_derivatives"
	mod.VK_KHR_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1
	mod.VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_KHR_cooperative_matrix"
	mod.VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION = 2
	mod.VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME = "VK_KHR_copy_commands2"
	mod.VK_KHR_COPY_COMMANDS_2_SPEC_VERSION = 1
	mod.VK_KHR_COPY_MEMORY_INDIRECT_EXTENSION_NAME = "VK_KHR_copy_memory_indirect"
	mod.VK_KHR_COPY_MEMORY_INDIRECT_SPEC_VERSION = 1
	mod.VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME = "VK_KHR_create_renderpass2"
	mod.VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION = 1
	mod.VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_KHR_dedicated_allocation"
	mod.VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION = 3
	mod.VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME = "VK_KHR_deferred_host_operations"
	mod.VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION = 4
	mod.VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME = "VK_KHR_depth_clamp_zero_one"
	mod.VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION = 1
	mod.VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = "VK_KHR_depth_stencil_resolve"
	mod.VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION = 1
	mod.VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = "VK_KHR_descriptor_update_template"
	mod.VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION = 1
	mod.VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = "VK_KHR_device_group_creation"
	mod.VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION = 1
	mod.VK_KHR_DEVICE_GROUP_EXTENSION_NAME = "VK_KHR_device_group"
	mod.VK_KHR_DEVICE_GROUP_SPEC_VERSION = 4
	mod.VK_KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display"
	mod.VK_KHR_DISPLAY_SPEC_VERSION = 23
	mod.VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain"
	mod.VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 10
	mod.VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_KHR_draw_indirect_count"
	mod.VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1
	mod.VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME = "VK_KHR_driver_properties"
	mod.VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION = 1
	mod.VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME = "VK_KHR_dynamic_rendering"
	mod.VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME = "VK_KHR_dynamic_rendering_local_read"
	mod.VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION = 1
	mod.VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_fence_capabilities"
	mod.VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME = "VK_KHR_external_fence"
	mod.VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = "VK_KHR_external_fence_fd"
	mod.VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_FENCE_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_memory_capabilities"
	mod.VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_KHR_external_memory"
	mod.VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = "VK_KHR_external_memory_fd"
	mod.VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_semaphore_capabilities"
	mod.VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = "VK_KHR_external_semaphore"
	mod.VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = "VK_KHR_external_semaphore_fd"
	mod.VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION = 1
	mod.VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1
	mod.VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME = "VK_KHR_format_feature_flags2"
	mod.VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION = 2
	mod.VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_KHR_fragment_shader_barycentric"
	mod.VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1
	mod.VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME = "VK_KHR_fragment_shading_rate"
	mod.VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION = 2
	mod.VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_display_properties2"
	mod.VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION = 1
	mod.VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME = "VK_KHR_get_memory_requirements2"
	mod.VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION = 1
	mod.VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_physical_device_properties2"
	mod.VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION = 2
	mod.VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = "VK_KHR_get_surface_capabilities2"
	mod.VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION = 1
	mod.VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_KHR_global_priority"
	mod.VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION = 1
	mod.VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME = "VK_KHR_imageless_framebuffer"
	mod.VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION = 1
	mod.VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = "VK_KHR_image_format_list"
	mod.VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION = 1
	mod.VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = "VK_KHR_incremental_present"
	mod.VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION = 2
	mod.VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_KHR_index_type_uint8"
	mod.VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION = 1
	mod.VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME = "VK_KHR_line_rasterization"
	mod.VK_KHR_LINE_RASTERIZATION_SPEC_VERSION = 1
	mod.VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME = "VK_KHR_load_store_op_none"
	mod.VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE1_EXTENSION_NAME = "VK_KHR_maintenance1"
	mod.VK_KHR_MAINTENANCE1_SPEC_VERSION = 2
	mod.VK_KHR_MAINTENANCE2_EXTENSION_NAME = "VK_KHR_maintenance2"
	mod.VK_KHR_MAINTENANCE2_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE3_EXTENSION_NAME = "VK_KHR_maintenance3"
	mod.VK_KHR_MAINTENANCE3_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_10_EXTENSION_NAME = "VK_KHR_maintenance10"
	mod.VK_KHR_MAINTENANCE_10_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_maintenance1"
	mod.VK_KHR_MAINTENANCE_1_SPEC_VERSION = 2
	mod.VK_KHR_MAINTENANCE_2_EXTENSION_NAME = "VK_KHR_maintenance2"
	mod.VK_KHR_MAINTENANCE_2_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_3_EXTENSION_NAME = "VK_KHR_maintenance3"
	mod.VK_KHR_MAINTENANCE_3_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_4_EXTENSION_NAME = "VK_KHR_maintenance4"
	mod.VK_KHR_MAINTENANCE_4_SPEC_VERSION = 2
	mod.VK_KHR_MAINTENANCE_5_EXTENSION_NAME = "VK_KHR_maintenance5"
	mod.VK_KHR_MAINTENANCE_5_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_6_EXTENSION_NAME = "VK_KHR_maintenance6"
	mod.VK_KHR_MAINTENANCE_6_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_7_EXTENSION_NAME = "VK_KHR_maintenance7"
	mod.VK_KHR_MAINTENANCE_7_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_8_EXTENSION_NAME = "VK_KHR_maintenance8"
	mod.VK_KHR_MAINTENANCE_8_SPEC_VERSION = 1
	mod.VK_KHR_MAINTENANCE_9_EXTENSION_NAME = "VK_KHR_maintenance9"
	mod.VK_KHR_MAINTENANCE_9_SPEC_VERSION = 1
	mod.VK_KHR_MAP_MEMORY_2_EXTENSION_NAME = "VK_KHR_map_memory2"
	mod.VK_KHR_MAP_MEMORY_2_SPEC_VERSION = 1
	mod.VK_KHR_MULTIVIEW_EXTENSION_NAME = "VK_KHR_multiview"
	mod.VK_KHR_MULTIVIEW_SPEC_VERSION = 1
	mod.VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_KHR_performance_query"
	mod.VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION = 1
	mod.VK_KHR_PIPELINE_BINARY_EXTENSION_NAME = "VK_KHR_pipeline_binary"
	mod.VK_KHR_PIPELINE_BINARY_SPEC_VERSION = 1
	mod.VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME = "VK_KHR_pipeline_executable_properties"
	mod.VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION = 1
	mod.VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_KHR_pipeline_library"
	mod.VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION = 1
	mod.VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME = "VK_KHR_portability_enumeration"
	mod.VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_ID_2_EXTENSION_NAME = "VK_KHR_present_id2"
	mod.VK_KHR_PRESENT_ID_2_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_ID_EXTENSION_NAME = "VK_KHR_present_id"
	mod.VK_KHR_PRESENT_ID_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME = "VK_KHR_present_mode_fifo_latest_ready"
	mod.VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_WAIT_2_EXTENSION_NAME = "VK_KHR_present_wait2"
	mod.VK_KHR_PRESENT_WAIT_2_SPEC_VERSION = 1
	mod.VK_KHR_PRESENT_WAIT_EXTENSION_NAME = "VK_KHR_present_wait"
	mod.VK_KHR_PRESENT_WAIT_SPEC_VERSION = 1
	mod.VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = "VK_KHR_push_descriptor"
	mod.VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION = 2
	mod.VK_KHR_RAY_QUERY_EXTENSION_NAME = "VK_KHR_ray_query"
	mod.VK_KHR_RAY_QUERY_SPEC_VERSION = 1
	mod.VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_ray_tracing_maintenance1"
	mod.VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME = "VK_KHR_ray_tracing_pipeline"
	mod.VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION = 1
	mod.VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME = "VK_KHR_ray_tracing_position_fetch"
	mod.VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION = 1
	mod.VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = "VK_KHR_relaxed_block_layout"
	mod.VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION = 1
	mod.VK_KHR_ROBUSTNESS_2_EXTENSION_NAME = "VK_KHR_robustness2"
	mod.VK_KHR_ROBUSTNESS_2_SPEC_VERSION = 1
	mod.VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = "VK_KHR_sampler_mirror_clamp_to_edge"
	mod.VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 3
	mod.VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = "VK_KHR_sampler_ycbcr_conversion"
	mod.VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION = 14
	mod.VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME = "VK_KHR_separate_depth_stencil_layouts"
	mod.VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = "VK_KHR_shader_atomic_int64"
	mod.VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME = "VK_KHR_shader_bfloat16"
	mod.VK_KHR_SHADER_BFLOAT16_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_CLOCK_EXTENSION_NAME = "VK_KHR_shader_clock"
	mod.VK_KHR_SHADER_CLOCK_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = "VK_KHR_shader_draw_parameters"
	mod.VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME = "VK_KHR_shader_expect_assume"
	mod.VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = "VK_KHR_shader_float16_int8"
	mod.VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME = "VK_KHR_shader_float_controls2"
	mod.VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = "VK_KHR_shader_float_controls"
	mod.VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION = 4
	mod.VK_KHR_SHADER_FMA_EXTENSION_NAME = "VK_KHR_shader_fma"
	mod.VK_KHR_SHADER_FMA_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME = "VK_KHR_shader_integer_dot_product"
	mod.VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME = "VK_KHR_shader_maximal_reconvergence"
	mod.VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME = "VK_KHR_shader_non_semantic_info"
	mod.VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME = "VK_KHR_shader_quad_control"
	mod.VK_KHR_SHADER_QUAD_CONTROL_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME = "VK_KHR_shader_relaxed_extended_instruction"
	mod.VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME = "VK_KHR_shader_subgroup_extended_types"
	mod.VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME = "VK_KHR_shader_subgroup_rotate"
	mod.VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION = 2
	mod.VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME = "VK_KHR_shader_subgroup_uniform_control_flow"
	mod.VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME = "VK_KHR_shader_terminate_invocation"
	mod.VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION = 1
	mod.VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME = "VK_KHR_shader_untyped_pointers"
	mod.VK_KHR_SHADER_UNTYPED_POINTERS_SPEC_VERSION = 1
	mod.VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = "VK_KHR_shared_presentable_image"
	mod.VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION = 1
	mod.VK_KHR_SPIRV_1_4_EXTENSION_NAME = "VK_KHR_spirv_1_4"
	mod.VK_KHR_SPIRV_1_4_SPEC_VERSION = 1
	mod.VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = "VK_KHR_storage_buffer_storage_class"
	mod.VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION = 1
	mod.VK_KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface"
	mod.VK_KHR_SURFACE_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_surface_maintenance1"
	mod.VK_KHR_SURFACE_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = "VK_KHR_surface_protected_capabilities"
	mod.VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_KHR_SURFACE_SPEC_VERSION = 25
	mod.VK_KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain"
	mod.VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_swapchain_maintenance1"
	mod.VK_KHR_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = "VK_KHR_swapchain_mutable_format"
	mod.VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION = 1
	mod.VK_KHR_SWAPCHAIN_SPEC_VERSION = 70
	mod.VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME = "VK_KHR_synchronization2"
	mod.VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION = 1
	mod.VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME = "VK_KHR_timeline_semaphore"
	mod.VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION = 2
	mod.VK_KHR_UNIFIED_IMAGE_LAYOUTS_EXTENSION_NAME = "VK_KHR_unified_image_layouts"
	mod.VK_KHR_UNIFIED_IMAGE_LAYOUTS_SPEC_VERSION = 1
	mod.VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME = "VK_KHR_uniform_buffer_standard_layout"
	mod.VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION = 1
	mod.VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME = "VK_KHR_variable_pointers"
	mod.VK_KHR_VARIABLE_POINTERS_SPEC_VERSION = 1
	mod.VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_KHR_vertex_attribute_divisor"
	mod.VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME = "VK_KHR_video_decode_av1"
	mod.VK_KHR_VIDEO_DECODE_AV1_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME = "VK_KHR_video_decode_h264"
	mod.VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION = 9
	mod.VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME = "VK_KHR_video_decode_h265"
	mod.VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION = 8
	mod.VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_decode_queue"
	mod.VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION = 8
	mod.VK_KHR_VIDEO_DECODE_VP9_EXTENSION_NAME = "VK_KHR_video_decode_vp9"
	mod.VK_KHR_VIDEO_DECODE_VP9_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME = "VK_KHR_video_encode_av1"
	mod.VK_KHR_VIDEO_ENCODE_AV1_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME = "VK_KHR_video_encode_h264"
	mod.VK_KHR_VIDEO_ENCODE_H264_SPEC_VERSION = 14
	mod.VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME = "VK_KHR_video_encode_h265"
	mod.VK_KHR_VIDEO_ENCODE_H265_SPEC_VERSION = 14
	mod.VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_EXTENSION_NAME = "VK_KHR_video_encode_intra_refresh"
	mod.VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME = "VK_KHR_video_encode_quantization_map"
	mod.VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_SPEC_VERSION = 2
	mod.VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_encode_queue"
	mod.VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION = 12
	mod.VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_video_maintenance1"
	mod.VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME = "VK_KHR_video_maintenance2"
	mod.VK_KHR_VIDEO_MAINTENANCE_2_SPEC_VERSION = 1
	mod.VK_KHR_VIDEO_QUEUE_EXTENSION_NAME = "VK_KHR_video_queue"
	mod.VK_KHR_VIDEO_QUEUE_SPEC_VERSION = 8
	mod.VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = "VK_KHR_vulkan_memory_model"
	mod.VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION = 3
	mod.VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME = "VK_KHR_wayland_surface"
	mod.VK_KHR_WAYLAND_SURFACE_SPEC_VERSION = 6
	mod.VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME = "VK_KHR_workgroup_memory_explicit_layout"
	mod.VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION = 1
	mod.VK_KHR_XLIB_SURFACE_EXTENSION_NAME = "VK_KHR_xlib_surface"
	mod.VK_KHR_XLIB_SURFACE_SPEC_VERSION = 6
	mod.VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME = "VK_KHR_zero_initialize_workgroup_memory"
	mod.VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION = 1
	mod.VK_KHR_acceleration_structure = 1
	mod.VK_KHR_android_surface = 1
	mod.VK_KHR_bind_memory2 = 1
	mod.VK_KHR_buffer_device_address = 1
	mod.VK_KHR_calibrated_timestamps = 1
	mod.VK_KHR_compute_shader_derivatives = 1
	mod.VK_KHR_cooperative_matrix = 1
	mod.VK_KHR_copy_commands2 = 1
	mod.VK_KHR_copy_memory_indirect = 1
	mod.VK_KHR_create_renderpass2 = 1
	mod.VK_KHR_dedicated_allocation = 1
	mod.VK_KHR_deferred_host_operations = 1
	mod.VK_KHR_depth_clamp_zero_one = 1
	mod.VK_KHR_depth_stencil_resolve = 1
	mod.VK_KHR_descriptor_update_template = 1
	mod.VK_KHR_device_group = 1
	mod.VK_KHR_device_group_creation = 1
	mod.VK_KHR_display = 1
	mod.VK_KHR_display_swapchain = 1
	mod.VK_KHR_draw_indirect_count = 1
	mod.VK_KHR_driver_properties = 1
	mod.VK_KHR_dynamic_rendering = 1
	mod.VK_KHR_dynamic_rendering_local_read = 1
	mod.VK_KHR_external_fence = 1
	mod.VK_KHR_external_fence_capabilities = 1
	mod.VK_KHR_external_fence_fd = 1
	mod.VK_KHR_external_memory = 1
	mod.VK_KHR_external_memory_capabilities = 1
	mod.VK_KHR_external_memory_fd = 1
	mod.VK_KHR_external_semaphore = 1
	mod.VK_KHR_external_semaphore_capabilities = 1
	mod.VK_KHR_external_semaphore_fd = 1
	mod.VK_KHR_format_feature_flags2 = 1
	mod.VK_KHR_fragment_shader_barycentric = 1
	mod.VK_KHR_fragment_shading_rate = 1
	mod.VK_KHR_get_display_properties2 = 1
	mod.VK_KHR_get_memory_requirements2 = 1
	mod.VK_KHR_get_physical_device_properties2 = 1
	mod.VK_KHR_get_surface_capabilities2 = 1
	mod.VK_KHR_global_priority = 1
	mod.VK_KHR_image_format_list = 1
	mod.VK_KHR_imageless_framebuffer = 1
	mod.VK_KHR_incremental_present = 1
	mod.VK_KHR_index_type_uint8 = 1
	mod.VK_KHR_line_rasterization = 1
	mod.VK_KHR_load_store_op_none = 1
	mod.VK_KHR_maintenance1 = 1
	mod.VK_KHR_maintenance10 = 1
	mod.VK_KHR_maintenance2 = 1
	mod.VK_KHR_maintenance3 = 1
	mod.VK_KHR_maintenance4 = 1
	mod.VK_KHR_maintenance5 = 1
	mod.VK_KHR_maintenance6 = 1
	mod.VK_KHR_maintenance7 = 1
	mod.VK_KHR_maintenance8 = 1
	mod.VK_KHR_maintenance9 = 1
	mod.VK_KHR_map_memory2 = 1
	mod.VK_KHR_multiview = 1
	mod.VK_KHR_performance_query = 1
	mod.VK_KHR_pipeline_binary = 1
	mod.VK_KHR_pipeline_executable_properties = 1
	mod.VK_KHR_pipeline_library = 1
	mod.VK_KHR_portability_enumeration = 1
	mod.VK_KHR_present_id = 1
	mod.VK_KHR_present_id2 = 1
	mod.VK_KHR_present_mode_fifo_latest_ready = 1
	mod.VK_KHR_present_wait = 1
	mod.VK_KHR_present_wait2 = 1
	mod.VK_KHR_push_descriptor = 1
	mod.VK_KHR_ray_query = 1
	mod.VK_KHR_ray_tracing_maintenance1 = 1
	mod.VK_KHR_ray_tracing_pipeline = 1
	mod.VK_KHR_ray_tracing_position_fetch = 1
	mod.VK_KHR_relaxed_block_layout = 1
	mod.VK_KHR_robustness2 = 1
	mod.VK_KHR_sampler_mirror_clamp_to_edge = 1
	mod.VK_KHR_sampler_ycbcr_conversion = 1
	mod.VK_KHR_separate_depth_stencil_layouts = 1
	mod.VK_KHR_shader_atomic_int64 = 1
	mod.VK_KHR_shader_bfloat16 = 1
	mod.VK_KHR_shader_clock = 1
	mod.VK_KHR_shader_draw_parameters = 1
	mod.VK_KHR_shader_expect_assume = 1
	mod.VK_KHR_shader_float16_int8 = 1
	mod.VK_KHR_shader_float_controls = 1
	mod.VK_KHR_shader_float_controls2 = 1
	mod.VK_KHR_shader_fma = 1
	mod.VK_KHR_shader_integer_dot_product = 1
	mod.VK_KHR_shader_maximal_reconvergence = 1
	mod.VK_KHR_shader_non_semantic_info = 1
	mod.VK_KHR_shader_quad_control = 1
	mod.VK_KHR_shader_relaxed_extended_instruction = 1
	mod.VK_KHR_shader_subgroup_extended_types = 1
	mod.VK_KHR_shader_subgroup_rotate = 1
	mod.VK_KHR_shader_subgroup_uniform_control_flow = 1
	mod.VK_KHR_shader_terminate_invocation = 1
	mod.VK_KHR_shader_untyped_pointers = 1
	mod.VK_KHR_shared_presentable_image = 1
	mod.VK_KHR_spirv_1_4 = 1
	mod.VK_KHR_storage_buffer_storage_class = 1
	mod.VK_KHR_surface = 1
	mod.VK_KHR_surface_maintenance1 = 1
	mod.VK_KHR_surface_protected_capabilities = 1
	mod.VK_KHR_swapchain = 1
	mod.VK_KHR_swapchain_maintenance1 = 1
	mod.VK_KHR_swapchain_mutable_format = 1
	mod.VK_KHR_synchronization2 = 1
	mod.VK_KHR_timeline_semaphore = 1
	mod.VK_KHR_unified_image_layouts = 1
	mod.VK_KHR_uniform_buffer_standard_layout = 1
	mod.VK_KHR_variable_pointers = 1
	mod.VK_KHR_vertex_attribute_divisor = 1
	mod.VK_KHR_video_decode_av1 = 1
	mod.VK_KHR_video_decode_h264 = 1
	mod.VK_KHR_video_decode_h265 = 1
	mod.VK_KHR_video_decode_queue = 1
	mod.VK_KHR_video_decode_vp9 = 1
	mod.VK_KHR_video_encode_av1 = 1
	mod.VK_KHR_video_encode_h264 = 1
	mod.VK_KHR_video_encode_h265 = 1
	mod.VK_KHR_video_encode_intra_refresh = 1
	mod.VK_KHR_video_encode_quantization_map = 1
	mod.VK_KHR_video_encode_queue = 1
	mod.VK_KHR_video_maintenance1 = 1
	mod.VK_KHR_video_maintenance2 = 1
	mod.VK_KHR_video_queue = 1
	mod.VK_KHR_vulkan_memory_model = 1
	mod.VK_KHR_wayland_surface = 1
	mod.VK_KHR_workgroup_memory_explicit_layout = 1
	mod.VK_KHR_xlib_surface = 1
	mod.VK_KHR_zero_initialize_workgroup_memory = 1
	mod.VK_LOD_CLAMP_NONE = 1000.0
	mod.VK_LUID_SIZE = 8
	mod.VK_LUID_SIZE_KHR = 8
	mod.VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME = "VK_LUNARG_direct_driver_loading"
	mod.VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION = 1
	mod.VK_LUNARG_direct_driver_loading = 1
	mod.VK_MAX_DESCRIPTION_SIZE = 256
	mod.VK_MAX_DEVICE_GROUP_SIZE = 32
	mod.VK_MAX_DEVICE_GROUP_SIZE_KHR = 32
	mod.VK_MAX_DRIVER_INFO_SIZE = 256
	mod.VK_MAX_DRIVER_INFO_SIZE_KHR = 256
	mod.VK_MAX_DRIVER_NAME_SIZE = 256
	mod.VK_MAX_DRIVER_NAME_SIZE_KHR = 256
	mod.VK_MAX_EXTENSION_NAME_SIZE = 256
	mod.VK_MAX_GLOBAL_PRIORITY_SIZE = 16
	mod.VK_MAX_GLOBAL_PRIORITY_SIZE_EXT = 16
	mod.VK_MAX_GLOBAL_PRIORITY_SIZE_KHR = 16
	mod.VK_MAX_MEMORY_HEAPS = 16
	mod.VK_MAX_MEMORY_TYPES = 32
	mod.VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM = 128
	mod.VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256
	mod.VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR = 32
	mod.VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32
	mod.VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR = 7
	mod.VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR = 3
	mod.VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME = "VK_MESA_image_alignment_control"
	mod.VK_MESA_IMAGE_ALIGNMENT_CONTROL_SPEC_VERSION = 1
	mod.VK_MESA_image_alignment_control = 1
	mod.VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME = "VK_MSFT_layered_driver"
	mod.VK_MSFT_LAYERED_DRIVER_SPEC_VERSION = 1
	mod.VK_MSFT_layered_driver = 1
	mod.VK_MVK_IOS_SURFACE_EXTENSION_NAME = "VK_MVK_ios_surface"
	mod.VK_MVK_IOS_SURFACE_SPEC_VERSION = 3
	mod.VK_MVK_MACOS_SURFACE_EXTENSION_NAME = "VK_MVK_macos_surface"
	mod.VK_MVK_MACOS_SURFACE_SPEC_VERSION = 3
	mod.VK_MVK_ios_surface = 1
	mod.VK_MVK_macos_surface = 1
	mod.VK_NN_VI_SURFACE_EXTENSION_NAME = "VK_NN_vi_surface"
	mod.VK_NN_VI_SURFACE_SPEC_VERSION = 1
	mod.VK_NN_vi_surface = 1
	mod.VK_NULL_HANDLE = nil -- ((void*)0) -- Failed to parse: [string "local ffi = require('ffi') local x =  ( void ..."]:1: unexpected symbol near ')'
	mod.VK_NVX_BINARY_IMPORT_EXTENSION_NAME = "VK_NVX_binary_import"
	mod.VK_NVX_BINARY_IMPORT_SPEC_VERSION = 2
	mod.VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = "VK_NVX_image_view_handle"
	mod.VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION = 3
	mod.VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = "VK_NVX_multiview_per_view_attributes"
	mod.VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION = 1
	mod.VK_NVX_binary_import = 1
	mod.VK_NVX_image_view_handle = 1
	mod.VK_NVX_multiview_per_view_attributes = 1
	mod.VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = "VK_NV_clip_space_w_scaling"
	mod.VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION = 1
	mod.VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_NV_cluster_acceleration_structure"
	mod.VK_NV_CLUSTER_ACCELERATION_STRUCTURE_SPEC_VERSION = 4
	mod.VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME = "VK_NV_command_buffer_inheritance"
	mod.VK_NV_COMMAND_BUFFER_INHERITANCE_SPEC_VERSION = 1
	mod.VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_NV_compute_shader_derivatives"
	mod.VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1
	mod.VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME = "VK_NV_cooperative_matrix2"
	mod.VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION = 1
	mod.VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_NV_cooperative_matrix"
	mod.VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION = 1
	mod.VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME = "VK_NV_cooperative_vector"
	mod.VK_NV_COOPERATIVE_VECTOR_SPEC_VERSION = 4
	mod.VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME = "VK_NV_copy_memory_indirect"
	mod.VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION = 1
	mod.VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = "VK_NV_corner_sampled_image"
	mod.VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION = 2
	mod.VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME = "VK_NV_coverage_reduction_mode"
	mod.VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION = 1
	mod.VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_NV_dedicated_allocation"
	mod.VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = "VK_NV_dedicated_allocation_image_aliasing"
	mod.VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION = 1
	mod.VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION = 1
	mod.VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME = "VK_NV_descriptor_pool_overallocation"
	mod.VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION = 1
	mod.VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME = "VK_NV_device_diagnostics_config"
	mod.VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION = 2
	mod.VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = "VK_NV_device_diagnostic_checkpoints"
	mod.VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION = 2
	mod.VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME = "VK_NV_device_generated_commands_compute"
	mod.VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION = 2
	mod.VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_NV_device_generated_commands"
	mod.VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 3
	mod.VK_NV_DISPLAY_STEREO_EXTENSION_NAME = "VK_NV_display_stereo"
	mod.VK_NV_DISPLAY_STEREO_SPEC_VERSION = 1
	mod.VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME = "VK_NV_extended_sparse_address_space"
	mod.VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION = 1
	mod.VK_NV_EXTERNAL_COMPUTE_QUEUE_EXTENSION_NAME = "VK_NV_external_compute_queue"
	mod.VK_NV_EXTERNAL_COMPUTE_QUEUE_SPEC_VERSION = 1
	mod.VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_NV_external_memory_capabilities"
	mod.VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1
	mod.VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_NV_external_memory"
	mod.VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME = "VK_NV_external_memory_rdma"
	mod.VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION = 1
	mod.VK_NV_EXTERNAL_MEMORY_SPEC_VERSION = 1
	mod.VK_NV_FILL_RECTANGLE_EXTENSION_NAME = "VK_NV_fill_rectangle"
	mod.VK_NV_FILL_RECTANGLE_SPEC_VERSION = 1
	mod.VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = "VK_NV_fragment_coverage_to_color"
	mod.VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION = 1
	mod.VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_NV_fragment_shader_barycentric"
	mod.VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1
	mod.VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME = "VK_NV_fragment_shading_rate_enums"
	mod.VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION = 1
	mod.VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = "VK_NV_framebuffer_mixed_samples"
	mod.VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION = 1
	mod.VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = "VK_NV_geometry_shader_passthrough"
	mod.VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION = 1
	mod.VK_NV_GLSL_SHADER_EXTENSION_NAME = "VK_NV_glsl_shader"
	mod.VK_NV_GLSL_SHADER_SPEC_VERSION = 1
	mod.VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME = "VK_NV_inherited_viewport_scissor"
	mod.VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION = 1
	mod.VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME = "VK_NV_linear_color_attachment"
	mod.VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION = 1
	mod.VK_NV_LOW_LATENCY_2_EXTENSION_NAME = "VK_NV_low_latency2"
	mod.VK_NV_LOW_LATENCY_2_SPEC_VERSION = 2
	mod.VK_NV_LOW_LATENCY_EXTENSION_NAME = "VK_NV_low_latency"
	mod.VK_NV_LOW_LATENCY_SPEC_VERSION = 1
	mod.VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME = "VK_NV_memory_decompression"
	mod.VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION = 1
	mod.VK_NV_MESH_SHADER_EXTENSION_NAME = "VK_NV_mesh_shader"
	mod.VK_NV_MESH_SHADER_SPEC_VERSION = 1
	mod.VK_NV_OPTICAL_FLOW_EXTENSION_NAME = "VK_NV_optical_flow"
	mod.VK_NV_OPTICAL_FLOW_SPEC_VERSION = 1
	mod.VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_NV_partitioned_acceleration_structure"
	mod.VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_SPEC_VERSION = 1
	mod.VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME = "VK_NV_per_stage_descriptor_set"
	mod.VK_NV_PER_STAGE_DESCRIPTOR_SET_SPEC_VERSION = 1
	mod.VK_NV_PRESENT_BARRIER_EXTENSION_NAME = "VK_NV_present_barrier"
	mod.VK_NV_PRESENT_BARRIER_SPEC_VERSION = 1
	mod.VK_NV_PRESENT_METERING_EXTENSION_NAME = "VK_NV_present_metering"
	mod.VK_NV_PRESENT_METERING_SPEC_VERSION = 1
	mod.VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME = "VK_NV_raw_access_chains"
	mod.VK_NV_RAW_ACCESS_CHAINS_SPEC_VERSION = 1
	mod.VK_NV_RAY_TRACING_EXTENSION_NAME = "VK_NV_ray_tracing"
	mod.VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME = "VK_NV_ray_tracing_invocation_reorder"
	mod.VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION = 1
	mod.VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME = "VK_NV_ray_tracing_linear_swept_spheres"
	mod.VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_SPEC_VERSION = 1
	mod.VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME = "VK_NV_ray_tracing_motion_blur"
	mod.VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION = 1
	mod.VK_NV_RAY_TRACING_SPEC_VERSION = 3
	mod.VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME = "VK_NV_ray_tracing_validation"
	mod.VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION = 1
	mod.VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = "VK_NV_representative_fragment_test"
	mod.VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION = 2
	mod.VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = "VK_NV_sample_mask_override_coverage"
	mod.VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION = 1
	mod.VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = "VK_NV_scissor_exclusive"
	mod.VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION = 2
	mod.VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME = "VK_NV_shader_atomic_float16_vector"
	mod.VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION = 1
	mod.VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = "VK_NV_shader_image_footprint"
	mod.VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION = 2
	mod.VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME = "VK_NV_shader_sm_builtins"
	mod.VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION = 1
	mod.VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = "VK_NV_shader_subgroup_partitioned"
	mod.VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION = 1
	mod.VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME = "VK_NV_shading_rate_image"
	mod.VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION = 3
	mod.VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME = "VK_NV_viewport_array2"
	mod.VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION = 1
	mod.VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME = "VK_NV_viewport_array2"
	mod.VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION = 1
	mod.VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = "VK_NV_viewport_swizzle"
	mod.VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION = 1
	mod.VK_NV_clip_space_w_scaling = 1
	mod.VK_NV_cluster_acceleration_structure = 1
	mod.VK_NV_command_buffer_inheritance = 1
	mod.VK_NV_compute_shader_derivatives = 1
	mod.VK_NV_cooperative_matrix = 1
	mod.VK_NV_cooperative_matrix2 = 1
	mod.VK_NV_cooperative_vector = 1
	mod.VK_NV_copy_memory_indirect = 1
	mod.VK_NV_corner_sampled_image = 1
	mod.VK_NV_coverage_reduction_mode = 1
	mod.VK_NV_dedicated_allocation = 1
	mod.VK_NV_dedicated_allocation_image_aliasing = 1
	mod.VK_NV_descriptor_pool_overallocation = 1
	mod.VK_NV_device_diagnostic_checkpoints = 1
	mod.VK_NV_device_diagnostics_config = 1
	mod.VK_NV_device_generated_commands = 1
	mod.VK_NV_device_generated_commands_compute = 1
	mod.VK_NV_display_stereo = 1
	mod.VK_NV_extended_sparse_address_space = 1
	mod.VK_NV_external_compute_queue = 1
	mod.VK_NV_external_memory = 1
	mod.VK_NV_external_memory_capabilities = 1
	mod.VK_NV_external_memory_rdma = 1
	mod.VK_NV_fill_rectangle = 1
	mod.VK_NV_fragment_coverage_to_color = 1
	mod.VK_NV_fragment_shader_barycentric = 1
	mod.VK_NV_fragment_shading_rate_enums = 1
	mod.VK_NV_framebuffer_mixed_samples = 1
	mod.VK_NV_geometry_shader_passthrough = 1
	mod.VK_NV_glsl_shader = 1
	mod.VK_NV_inherited_viewport_scissor = 1
	mod.VK_NV_linear_color_attachment = 1
	mod.VK_NV_low_latency = 1
	mod.VK_NV_low_latency2 = 1
	mod.VK_NV_memory_decompression = 1
	mod.VK_NV_mesh_shader = 1
	mod.VK_NV_optical_flow = 1
	mod.VK_NV_partitioned_acceleration_structure = 1
	mod.VK_NV_per_stage_descriptor_set = 1
	mod.VK_NV_present_barrier = 1
	mod.VK_NV_present_metering = 1
	mod.VK_NV_raw_access_chains = 1
	mod.VK_NV_ray_tracing = 1
	mod.VK_NV_ray_tracing_invocation_reorder = 1
	mod.VK_NV_ray_tracing_linear_swept_spheres = 1
	mod.VK_NV_ray_tracing_motion_blur = 1
	mod.VK_NV_ray_tracing_validation = 1
	mod.VK_NV_representative_fragment_test = 1
	mod.VK_NV_sample_mask_override_coverage = 1
	mod.VK_NV_scissor_exclusive = 1
	mod.VK_NV_shader_atomic_float16_vector = 1
	mod.VK_NV_shader_image_footprint = 1
	mod.VK_NV_shader_sm_builtins = 1
	mod.VK_NV_shader_subgroup_partitioned = 1
	mod.VK_NV_shading_rate_image = 1
	mod.VK_NV_viewport_array2 = 1
	mod.VK_NV_viewport_swizzle = 1
	mod.VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV =  bit.bnot(0) 
	mod.VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME = "VK_QCOM_filter_cubic_clamp"
	mod.VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION = 1
	mod.VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME = "VK_QCOM_filter_cubic_weights"
	mod.VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION = 1
	mod.VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = "VK_QCOM_fragment_density_map_offset"
	mod.VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION = 3
	mod.VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME = "VK_QCOM_image_processing2"
	mod.VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION = 1
	mod.VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME = "VK_QCOM_image_processing"
	mod.VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION = 1
	mod.VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME = "VK_QCOM_multiview_per_view_render_areas"
	mod.VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION = 1
	mod.VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME = "VK_QCOM_multiview_per_view_viewports"
	mod.VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION = 1
	mod.VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME = "VK_QCOM_render_pass_shader_resolve"
	mod.VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION = 4
	mod.VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME = "VK_QCOM_render_pass_store_ops"
	mod.VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION = 2
	mod.VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME = "VK_QCOM_render_pass_transform"
	mod.VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION = 5
	mod.VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME = "VK_QCOM_rotated_copy_commands"
	mod.VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION = 2
	mod.VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME = "VK_QCOM_tile_memory_heap"
	mod.VK_QCOM_TILE_MEMORY_HEAP_SPEC_VERSION = 1
	mod.VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME = "VK_QCOM_tile_properties"
	mod.VK_QCOM_TILE_PROPERTIES_SPEC_VERSION = 1
	mod.VK_QCOM_TILE_SHADING_EXTENSION_NAME = "VK_QCOM_tile_shading"
	mod.VK_QCOM_TILE_SHADING_SPEC_VERSION = 2
	mod.VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME = "VK_QCOM_ycbcr_degamma"
	mod.VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION = 1
	mod.VK_QCOM_filter_cubic_clamp = 1
	mod.VK_QCOM_filter_cubic_weights = 1
	mod.VK_QCOM_fragment_density_map_offset = 1
	mod.VK_QCOM_image_processing = 1
	mod.VK_QCOM_image_processing2 = 1
	mod.VK_QCOM_multiview_per_view_render_areas = 1
	mod.VK_QCOM_multiview_per_view_viewports = 1
	mod.VK_QCOM_render_pass_shader_resolve = 1
	mod.VK_QCOM_render_pass_store_ops = 1
	mod.VK_QCOM_render_pass_transform = 1
	mod.VK_QCOM_rotated_copy_commands = 1
	mod.VK_QCOM_tile_memory_heap = 1
	mod.VK_QCOM_tile_properties = 1
	mod.VK_QCOM_tile_shading = 1
	mod.VK_QCOM_ycbcr_degamma = 1
	mod.VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME = "VK_QNX_external_memory_screen_buffer"
	mod.VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION = 1
	mod.VK_QNX_SCREEN_SURFACE_EXTENSION_NAME = "VK_QNX_screen_surface"
	mod.VK_QNX_SCREEN_SURFACE_SPEC_VERSION = 1
	mod.VK_QNX_external_memory_screen_buffer = 1
	mod.VK_QNX_screen_surface = 1
	mod.VK_QUEUE_FAMILY_EXTERNAL =  bit.bnot(1) 
	mod.VK_QUEUE_FAMILY_EXTERNAL_KHR =  bit.bnot(1) 
	mod.VK_QUEUE_FAMILY_FOREIGN_EXT =  bit.bnot(2) 
	mod.VK_QUEUE_FAMILY_IGNORED =  bit.bnot(0) 
	mod.VK_REMAINING_3D_SLICES_EXT =  bit.bnot(0) 
	mod.VK_REMAINING_ARRAY_LAYERS =  bit.bnot(0) 
	mod.VK_REMAINING_MIP_LEVELS =  bit.bnot(0) 
	mod.VK_SEC_AMIGO_PROFILING_EXTENSION_NAME = "VK_SEC_amigo_profiling"
	mod.VK_SEC_AMIGO_PROFILING_SPEC_VERSION = 1
	mod.VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_EXTENSION_NAME = "VK_SEC_pipeline_cache_incremental_mode"
	mod.VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_SPEC_VERSION = 1
	mod.VK_SEC_amigo_profiling = 1
	mod.VK_SEC_pipeline_cache_incremental_mode = 1
	mod.VK_SHADER_UNUSED_KHR =  bit.bnot(0) 
	mod.VK_SHADER_UNUSED_NV =  bit.bnot(0) 
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0 = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_av1_decode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0 = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_av1_encode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_SPEC_VERSION = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0 = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264_decode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0 = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264_encode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0 = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265_decode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0 = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265_encode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_API_VERSION_1_0_0 = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_vp9_decode"
	mod.VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_SPEC_VERSION = bit.bor( bit.lshift( ffi.cast("uint32_t", 1) , 22) ,  bit.lshift( ffi.cast("uint32_t", 0) , 12) ,  ffi.cast("uint32_t", 0) )
	mod.VK_SUBPASS_EXTERNAL =  bit.bnot(0) 
	mod.VK_TRUE = 1
	mod.VK_USE_64_BIT_PTR_DEFINES = 1
	mod.VK_UUID_SIZE = 16
	mod.VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME = "VK_VALVE_descriptor_set_host_mapping"
	mod.VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION = 1
	mod.VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_EXTENSION_NAME = "VK_VALVE_fragment_density_map_layered"
	mod.VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_SPEC_VERSION = 1
	mod.VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_VALVE_mutable_descriptor_type"
	mod.VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION = 1
	mod.VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_EXTENSION_NAME = "VK_VALVE_video_encode_rgb_conversion"
	mod.VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_SPEC_VERSION = 1
	mod.VK_VALVE_descriptor_set_host_mapping = 1
	mod.VK_VALVE_fragment_density_map_layered = 1
	mod.VK_VALVE_mutable_descriptor_type = 1
	mod.VK_VALVE_video_encode_rgb_conversion = 1
	mod.VK_VERSION_1_0 = 1
	mod.VK_VERSION_1_1 = 1
	mod.VK_VERSION_1_2 = 1
	mod.VK_VERSION_1_3 = 1
	mod.VK_VERSION_1_4 = 1
	mod.VK_WHOLE_SIZE =  bit.bnot(0LL) 
	mod.VULKAN_ANDROID_H_ = 1
	mod.VULKAN_CORE_H_ = 1
	mod.VULKAN_DIRECTFB_H_ = 1
	mod.VULKAN_GGP_H_ = 1
	mod.VULKAN_H_ = 1
	mod.VULKAN_IOS_H_ = 1
	mod.VULKAN_MACOS_H_ = 1
	mod.VULKAN_METAL_H_ = 1
	mod.VULKAN_SCREEN_H_ = 1
	mod.VULKAN_VIDEO_CODECS_COMMON_H_ = 1
	mod.VULKAN_VIDEO_CODEC_AV1STD_DECODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_AV1STD_ENCODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_AV1STD_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H264STD_DECODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H264STD_ENCODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H264STD_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H265STD_DECODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H265STD_ENCODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_H265STD_H_ = 1
	mod.VULKAN_VIDEO_CODEC_VP9STD_DECODE_H_ = 1
	mod.VULKAN_VIDEO_CODEC_VP9STD_H_ = 1
	mod.VULKAN_VI_H_ = 1
	mod.VULKAN_WAYLAND_H_ = 1
	mod.VULKAN_XLIB_H_ = 1
	mod.__DATE__ = "Nov 06 2025"
	mod.__GNUC_MINOR__ = 2
	mod.__GNUC_PATCHLEVEL__ = 1
	mod.__GNUC__ = 4
	mod.__LP64__ = 1
	mod.__STDC_HOSTED__ = 1
	mod.__STDC_VERSION__ = 201710
	mod.__STDC__ = 1
	mod.__TIME__ = "06:52:43"
	mod.vulkan_video_codec_av1std = 1
	mod.vulkan_video_codec_av1std_decode = 1
	mod.vulkan_video_codec_av1std_encode = 1
	mod.vulkan_video_codec_h264std = 1
	mod.vulkan_video_codec_h264std_decode = 1
	mod.vulkan_video_codec_h264std_encode = 1
	mod.vulkan_video_codec_h265std = 1
	mod.vulkan_video_codec_h265std_decode = 1
	mod.vulkan_video_codec_h265std_encode = 1
	mod.vulkan_video_codec_vp9std = 1
	mod.vulkan_video_codec_vp9std_decode = 1
	mod.vulkan_video_codecs_common = 1
end
mod.VkSamplerYcbcrConversion = ffi.typeof([[int ]])
mod.VkDescriptorUpdateTemplate = ffi.typeof([[int ]])
mod.Display = ffi.typeof([[void*]])
mod.VisualID = ffi.typeof([[void*]])
mod.Window = ffi.typeof([[void*]])
mod.IDirectFB = ffi.typeof([[void*]])
mod.IDirectFBSurface = ffi.typeof([[void*]])
mod.GgpStreamDescriptor = ffi.typeof([[void*]])
mod.GgpFrameToken = ffi.typeof([[void*]])
mod._screen_context = ffi.typeof([[void*]])
mod.SECURITY_ATTRIBUTES = ffi.typeof([[void*]])
mod.VkBool32 = ffi.typeof([[uint32_t ]])
mod.VkDeviceAddress = ffi.typeof([[uint64_t ]])
mod.VkDeviceSize = ffi.typeof([[uint64_t ]])
mod.VkFlags = ffi.typeof([[uint32_t ]])
mod.VkSampleMask = ffi.typeof([[uint32_t ]])
mod.VkBuffer = ffi.typeof([[void*]])
mod.VkImage = ffi.typeof([[void*]])
mod.VkInstance = ffi.typeof([[void*]])
mod.VkPhysicalDevice = ffi.typeof([[void*]])
mod.VkDevice = ffi.typeof([[void*]])
mod.VkQueue = ffi.typeof([[void*]])
mod.VkSemaphore = ffi.typeof([[void*]])
mod.VkCommandBuffer = ffi.typeof([[void*]])
mod.VkFence = ffi.typeof([[void*]])
mod.VkDeviceMemory = ffi.typeof([[void*]])
mod.VkQueryPool = ffi.typeof([[void*]])
mod.VkImageView = ffi.typeof([[void*]])
mod.VkCommandPool = ffi.typeof([[void*]])
mod.VkRenderPass = ffi.typeof([[void*]])
mod.VkFramebuffer = ffi.typeof([[void*]])
mod.VkEvent = ffi.typeof([[void*]])
mod.VkBufferView = ffi.typeof([[void*]])
mod.VkShaderModule = ffi.typeof([[void*]])
mod.VkPipelineCache = ffi.typeof([[void*]])
mod.VkPipelineLayout = ffi.typeof([[void*]])
mod.VkPipeline = ffi.typeof([[void*]])
mod.VkDescriptorSetLayout = ffi.typeof([[void*]])
mod.VkSampler = ffi.typeof([[void*]])
mod.VkDescriptorSet = ffi.typeof([[void*]])
mod.VkDescriptorPool = ffi.typeof([[void*]])
mod.VkResult = ffi.typeof([[enum {
	VK_SUCCESS = 0,
	VK_NOT_READY = 1,
	VK_TIMEOUT = 2,
	VK_EVENT_SET = 3,
	VK_EVENT_RESET = 4,
	VK_INCOMPLETE = 5,
	VK_ERROR_OUT_OF_HOST_MEMORY = -1,
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
	VK_ERROR_INITIALIZATION_FAILED = -3,
	VK_ERROR_DEVICE_LOST = -4,
	VK_ERROR_MEMORY_MAP_FAILED = -5,
	VK_ERROR_LAYER_NOT_PRESENT = -6,
	VK_ERROR_EXTENSION_NOT_PRESENT = -7,
	VK_ERROR_FEATURE_NOT_PRESENT = -8,
	VK_ERROR_INCOMPATIBLE_DRIVER = -9,
	VK_ERROR_TOO_MANY_OBJECTS = -10,
	VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
	VK_ERROR_FRAGMENTED_POOL = -12,
	VK_ERROR_UNKNOWN = -13,
	VK_ERROR_VALIDATION_FAILED = -1000011001,
	VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
	VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
	VK_ERROR_FRAGMENTATION = -1000161000,
	VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
	VK_ERROR_NOT_PERMITTED = -1000174001,
	VK_ERROR_SURFACE_LOST_KHR = -1000000000,
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
	VK_SUBOPTIMAL_KHR = 1000001003,
	VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
	VK_ERROR_INVALID_SHADER_NV = -1000012000,
	VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
	VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
	VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
	VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
	VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
	VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
	VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
	VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
	VK_THREAD_IDLE_KHR = 1000268000,
	VK_THREAD_DONE_KHR = 1000268001,
	VK_OPERATION_DEFERRED_KHR = 1000268002,
	VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
	VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
	VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
	VK_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
	VK_PIPELINE_BINARY_MISSING_KHR = 1000483000,
	VK_ERROR_NOT_ENOUGH_SPACE_KHR = -1000483000,
	VK_ERROR_VALIDATION_FAILED_EXT = VK_ERROR_VALIDATION_FAILED,
	VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
	VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
	VK_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION,
	VK_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED,
	VK_ERROR_NOT_PERMITTED_KHR = VK_ERROR_NOT_PERMITTED,
	VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
	VK_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
	VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
	VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT = VK_INCOMPATIBLE_SHADER_BINARY_EXT,
	VK_RESULT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkStructureType = ffi.typeof([[enum {
	VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
	VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
	VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
	VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
	VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES = 55,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES = 56,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO = 1000174000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES = 1000388000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES = 1000388001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES = 1000265000,
	VK_STRUCTURE_TYPE_MEMORY_MAP_INFO = 1000271000,
	VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO = 1000271001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES = 1000470000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES = 1000470001,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO = 1000470004,
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 = 1000338002,
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 = 1000338003,
	VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO = 1000470006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES = 1000545000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES = 1000545001,
	VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS = 1000545002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES = 1000270000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES = 1000270001,
	VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY = 1000270002,
	VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY = 1000270003,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO = 1000270004,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO = 1000270005,
	VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO = 1000270006,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO = 1000270007,
	VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE = 1000270008,
	VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY = 1000270009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES = 1000416000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES = 1000528000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES = 1000544000,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO = 1000470005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO = 1000545003,
	VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO = 1000545004,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO = 1000545005,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO = 1000545006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES = 1000466000,
	VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO = 1000068000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES = 1000068001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES = 1000068002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES = 1000259000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO = 1000259001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES = 1000259002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES = 1000525000,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO = 1000190001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES = 1000190002,
	VK_STRUCTURE_TYPE_RENDERING_AREA_INFO = 1000470003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES = 1000232000,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO = 1000232001,
	VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO = 1000232002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
	VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
	VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
	VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
	VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
	VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
	VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
	VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
	VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
	VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
	VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
	VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
	VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
	VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
	VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
	VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX = 1000029004,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR = 1000038000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000038001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000038002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR = 1000038003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR = 1000038004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR = 1000038005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR = 1000038006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR = 1000038007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR = 1000038008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR = 1000038009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR = 1000038010,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR = 1000038011,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR = 1000038012,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000038013,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR = 1000039000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000039001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000039002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR = 1000039003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR = 1000039004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR = 1000039005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR = 1000039006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR = 1000039007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR = 1000039009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR = 1000039010,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR = 1000039011,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR = 1000039012,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR = 1000039013,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000039014,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
	VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
	VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
	VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
	VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
	VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
	VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
	VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
	VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
	VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
	VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
	VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
	VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
	VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
	VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
	VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
	VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
	VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG = 1000110000,
	VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
	VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
	VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
	VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
	VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
	VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
	VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
	VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
	VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
	VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR = 1000141000,
	VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
	VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
	VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
	VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
	VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
	VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
	VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
	VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
	VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
	VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
	VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
	VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
	VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
	VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
	VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
	VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
	VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
	VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
	VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
	VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
	VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
	VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
	VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
	VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR = 1000235000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
	VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
	VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
	VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
	VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
	VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
	VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
	VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000,
	VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001,
	VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
	VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
	VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
	VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
	VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
	VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
	VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM = 1000309000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM = 1000309001,
	VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM = 1000309002,
	VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM = 1000309003,
	VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM = 1000309004,
	VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM = 1000309005,
	VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000,
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
	VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
	VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
	VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
	VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
	VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
	VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
	VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
	VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
	VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
	VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
	VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
	VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
	VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
	VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
	VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
	VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
	VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
	VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
	VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
	VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
	VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
	VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
	VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
	VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
	VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
	VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
	VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
	VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
	VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT = 1000375000,
	VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT = 1000375001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
	VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
	VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
	VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR = 1000387000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE = 1000390000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE = 1000390001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE = 1000390002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE = 1000390003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001,
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
	VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
	VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
	VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
	VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI = 1000404002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
	VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM = 1000417000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM = 1000417001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM = 1000417002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM = 1000424000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM = 1000424001,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM = 1000424002,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM = 1000424003,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM = 1000424004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001,
	VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV = 1000429008,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV = 1000429009,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV = 1000429010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR = 1000434000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT = 1000451000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT = 1000451001,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
	VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
	VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000,
	VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001,
	VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM = 1000460000,
	VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM = 1000460001,
	VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM = 1000460002,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM = 1000460003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM = 1000460004,
	VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM = 1000460005,
	VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM = 1000460006,
	VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM = 1000460007,
	VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM = 1000460008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM = 1000460009,
	VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM = 1000460010,
	VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM = 1000460011,
	VK_STRUCTURE_TYPE_TENSOR_COPY_ARM = 1000460012,
	VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM = 1000460013,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM = 1000460014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM = 1000460015,
	VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM = 1000460016,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM = 1000460017,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM = 1000460018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM = 1000460019,
	VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM = 1000460020,
	VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460021,
	VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460022,
	VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM = 1000460023,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
	VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID = 1000468000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD = 1000476000,
	VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD = 1000476001,
	VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD = 1000476002,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR = 1000479000,
	VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR = 1000479001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR = 1000479002,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR = 1000480000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR = 1000480001,
	VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR = 1000480002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001,
	VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR = 1000483000,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR = 1000483001,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR = 1000483002,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR = 1000483003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR = 1000483004,
	VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR = 1000483005,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR = 1000483006,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR = 1000483007,
	VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR = 1000483008,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR = 1000483009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
	VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
	VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR = 1000274000,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR = 1000274001,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR = 1000274002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR = 1000275000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR = 1000275001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR = 1000275002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR = 1000275003,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR = 1000275004,
	VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR = 1000275005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV = 1000491000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491001,
	VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491002,
	VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV = 1000491004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV = 1000492000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV = 1000492001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT = 1000495000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT = 1000495001,
	VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT = 1000496000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
	VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV = 1000505000,
	VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV = 1000505001,
	VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV = 1000505002,
	VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV = 1000505003,
	VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV = 1000505004,
	VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV = 1000505005,
	VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV = 1000505006,
	VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV = 1000505007,
	VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV = 1000505008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM = 1000507000,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM = 1000507001,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM = 1000507002,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM = 1000507003,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM = 1000507004,
	VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM = 1000507005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM = 1000507006,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM = 1000507007,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM = 1000507008,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM = 1000507009,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM = 1000507010,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM = 1000507011,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM = 1000507012,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM = 1000507013,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM = 1000507014,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM = 1000507016,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM = 1000507017,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM = 1000507018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM = 1000507019,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM = 1000507015,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000,
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR = 1000201000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR = 1000511000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR = 1000512000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR = 1000512001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR = 1000512003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000512004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR = 1000512005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR = 1000513000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000513001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR = 1000513002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR = 1000513003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR = 1000513004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR = 1000513005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR = 1000513006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR = 1000513007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR = 1000513008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR = 1000513009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR = 1000513010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR = 1000514000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR = 1000514001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR = 1000514002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR = 1000514003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR = 1000515000,
	VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR = 1000515001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV = 1000516000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM = 1000518000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM = 1000518001,
	VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM = 1000518002,
	VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM = 1000519000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM = 1000519001,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM = 1000519002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM = 1000520000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM = 1000520001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM = 1000521000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR = 1000527000,
	VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT = 1000527001,
	VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
	VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
	VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT = 1000530000,
	VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR = 1000184000,
	VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT = 1000545007,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT = 1000545008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV = 1000546000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM = 1000547000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM = 1000547001,
	VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM = 1000547002,
	VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM = 1000547003,
	VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM = 1000547004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR = 1000549000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR = 1000426001,
	VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR = 1000549002,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR = 1000549003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT = 1000427000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT = 1000427001,
	VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT = 1000550002,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV = 1000551000,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV = 1000551001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR = 1000552000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR = 1000552001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR = 1000552002,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR = 1000552003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR = 1000552004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553000,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR = 1000553002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000553005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR = 1000553009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553004,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553007,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV = 1000555000,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV = 1000556000,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV = 1000556001,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV = 1000556002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV = 1000556003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR = 1000558000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV = 1000559000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR = 1000562000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR = 1000562001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR = 1000562002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR = 1000562003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR = 1000562004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV = 1000563000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT = 1000564000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT = 1000567000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV = 1000568000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV = 1000569000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000569001,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV = 1000569002,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV = 1000569003,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV = 1000569004,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV = 1000569005,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV = 1000569006,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000569007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV = 1000570000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000570001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570002,
	VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV = 1000570003,
	VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV = 1000570004,
	VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV = 1000570005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT = 1000572000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT = 1000572001,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT = 1000572002,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT = 1000572003,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT = 1000572004,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT = 1000572006,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT = 1000572007,
	VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT = 1000572008,
	VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT = 1000572009,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT = 1000572010,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT = 1000572011,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT = 1000572012,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT = 1000572013,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT = 1000572014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR = 1000574000,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR = 1000574002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA = 1000575000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA = 1000575001,
	VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR = 1000579000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT = 1000582001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR = 1000584000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR = 1000584001,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR = 1000584002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR = 1000586000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586003,
	VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS = 1000685000,
	VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS = 1000453001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS = 1000453002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS = 1000453003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI = 1000590000,
	VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI = 1000590001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV = 1000593000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM = 1000596000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT = 1000602000,
	VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT = 1000602001,
	VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT = 1000602002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR = 1000421000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM = 1000609000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE = 1000611000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE = 1000611001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE = 1000611002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR = 1000286000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR = 1000286001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT = 1000425000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT = 1000425001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT = 1000425002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT = 1000620000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR = 1000361000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT = 1000627000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR = 1000630000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR = 1000630001,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR = 1000630002,
	VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR = 1000619003,
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR = 1000630004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC = 1000637000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT = 1000642000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
	VK_STRUCTURE_TYPE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_INFO,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
	VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
	VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
	VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
	VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES,
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
	VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT = VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY,
	VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT = VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO,
	VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT = VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO,
	VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
	VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
	VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO,
	VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR,
	VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT = VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2,
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2,
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2,
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
	VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_COPY_2,
	VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_IMAGE_COPY_2,
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT,
	VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
	VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_AREA_INFO,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO,
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
	VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
	VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
	VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR = VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO,
	VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO,
	VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT = VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR,
	VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageLayout = ffi.typeof([[enum {
	VK_IMAGE_LAYOUT_UNDEFINED = 0,
	VK_IMAGE_LAYOUT_GENERAL = 1,
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
	VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
	VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ = 1000232000,
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
	VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
	VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
	VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
	VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
	VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM = 1000460000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR = 1000553000,
	VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT = 1000620000,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
	VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
	VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR = VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
	VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkObjectType = ffi.typeof([[enum {
	VK_OBJECT_TYPE_UNKNOWN = 0,
	VK_OBJECT_TYPE_INSTANCE = 1,
	VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
	VK_OBJECT_TYPE_DEVICE = 3,
	VK_OBJECT_TYPE_QUEUE = 4,
	VK_OBJECT_TYPE_SEMAPHORE = 5,
	VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
	VK_OBJECT_TYPE_FENCE = 7,
	VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
	VK_OBJECT_TYPE_BUFFER = 9,
	VK_OBJECT_TYPE_IMAGE = 10,
	VK_OBJECT_TYPE_EVENT = 11,
	VK_OBJECT_TYPE_QUERY_POOL = 12,
	VK_OBJECT_TYPE_BUFFER_VIEW = 13,
	VK_OBJECT_TYPE_IMAGE_VIEW = 14,
	VK_OBJECT_TYPE_SHADER_MODULE = 15,
	VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
	VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
	VK_OBJECT_TYPE_RENDER_PASS = 18,
	VK_OBJECT_TYPE_PIPELINE = 19,
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
	VK_OBJECT_TYPE_SAMPLER = 21,
	VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
	VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
	VK_OBJECT_TYPE_FRAMEBUFFER = 24,
	VK_OBJECT_TYPE_COMMAND_POOL = 25,
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
	VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
	VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
	VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
	VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
	VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
	VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
	VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
	VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
	VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
	VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
	VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
	VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
	VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
	VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
	VK_OBJECT_TYPE_TENSOR_ARM = 1000460000,
	VK_OBJECT_TYPE_TENSOR_VIEW_ARM = 1000460001,
	VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
	VK_OBJECT_TYPE_SHADER_EXT = 1000482000,
	VK_OBJECT_TYPE_PIPELINE_BINARY_KHR = 1000483000,
	VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM = 1000507000,
	VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV = 1000556000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT = 1000572000,
	VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT = 1000572001,
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT,
	VK_OBJECT_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkVendorId = ffi.typeof([[enum {
	VK_VENDOR_ID_KHRONOS = 0x10000,
	VK_VENDOR_ID_VIV = 0x10001,
	VK_VENDOR_ID_VSI = 0x10002,
	VK_VENDOR_ID_KAZAN = 0x10003,
	VK_VENDOR_ID_CODEPLAY = 0x10004,
	VK_VENDOR_ID_MESA = 0x10005,
	VK_VENDOR_ID_POCL = 0x10006,
	VK_VENDOR_ID_MOBILEYE = 0x10007,
	VK_VENDOR_ID_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSystemAllocationScope = ffi.typeof([[enum {
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
	VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkInternalAllocationType = ffi.typeof([[enum {
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
	VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFormat = ffi.typeof([[enum {
	VK_FORMAT_UNDEFINED = 0,
	VK_FORMAT_R4G4_UNORM_PACK8 = 1,
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
	VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
	VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
	VK_FORMAT_R8_UNORM = 9,
	VK_FORMAT_R8_SNORM = 10,
	VK_FORMAT_R8_USCALED = 11,
	VK_FORMAT_R8_SSCALED = 12,
	VK_FORMAT_R8_UINT = 13,
	VK_FORMAT_R8_SINT = 14,
	VK_FORMAT_R8_SRGB = 15,
	VK_FORMAT_R8G8_UNORM = 16,
	VK_FORMAT_R8G8_SNORM = 17,
	VK_FORMAT_R8G8_USCALED = 18,
	VK_FORMAT_R8G8_SSCALED = 19,
	VK_FORMAT_R8G8_UINT = 20,
	VK_FORMAT_R8G8_SINT = 21,
	VK_FORMAT_R8G8_SRGB = 22,
	VK_FORMAT_R8G8B8_UNORM = 23,
	VK_FORMAT_R8G8B8_SNORM = 24,
	VK_FORMAT_R8G8B8_USCALED = 25,
	VK_FORMAT_R8G8B8_SSCALED = 26,
	VK_FORMAT_R8G8B8_UINT = 27,
	VK_FORMAT_R8G8B8_SINT = 28,
	VK_FORMAT_R8G8B8_SRGB = 29,
	VK_FORMAT_B8G8R8_UNORM = 30,
	VK_FORMAT_B8G8R8_SNORM = 31,
	VK_FORMAT_B8G8R8_USCALED = 32,
	VK_FORMAT_B8G8R8_SSCALED = 33,
	VK_FORMAT_B8G8R8_UINT = 34,
	VK_FORMAT_B8G8R8_SINT = 35,
	VK_FORMAT_B8G8R8_SRGB = 36,
	VK_FORMAT_R8G8B8A8_UNORM = 37,
	VK_FORMAT_R8G8B8A8_SNORM = 38,
	VK_FORMAT_R8G8B8A8_USCALED = 39,
	VK_FORMAT_R8G8B8A8_SSCALED = 40,
	VK_FORMAT_R8G8B8A8_UINT = 41,
	VK_FORMAT_R8G8B8A8_SINT = 42,
	VK_FORMAT_R8G8B8A8_SRGB = 43,
	VK_FORMAT_B8G8R8A8_UNORM = 44,
	VK_FORMAT_B8G8R8A8_SNORM = 45,
	VK_FORMAT_B8G8R8A8_USCALED = 46,
	VK_FORMAT_B8G8R8A8_SSCALED = 47,
	VK_FORMAT_B8G8R8A8_UINT = 48,
	VK_FORMAT_B8G8R8A8_SINT = 49,
	VK_FORMAT_B8G8R8A8_SRGB = 50,
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
	VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
	VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
	VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
	VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
	VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
	VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
	VK_FORMAT_R16_UNORM = 70,
	VK_FORMAT_R16_SNORM = 71,
	VK_FORMAT_R16_USCALED = 72,
	VK_FORMAT_R16_SSCALED = 73,
	VK_FORMAT_R16_UINT = 74,
	VK_FORMAT_R16_SINT = 75,
	VK_FORMAT_R16_SFLOAT = 76,
	VK_FORMAT_R16G16_UNORM = 77,
	VK_FORMAT_R16G16_SNORM = 78,
	VK_FORMAT_R16G16_USCALED = 79,
	VK_FORMAT_R16G16_SSCALED = 80,
	VK_FORMAT_R16G16_UINT = 81,
	VK_FORMAT_R16G16_SINT = 82,
	VK_FORMAT_R16G16_SFLOAT = 83,
	VK_FORMAT_R16G16B16_UNORM = 84,
	VK_FORMAT_R16G16B16_SNORM = 85,
	VK_FORMAT_R16G16B16_USCALED = 86,
	VK_FORMAT_R16G16B16_SSCALED = 87,
	VK_FORMAT_R16G16B16_UINT = 88,
	VK_FORMAT_R16G16B16_SINT = 89,
	VK_FORMAT_R16G16B16_SFLOAT = 90,
	VK_FORMAT_R16G16B16A16_UNORM = 91,
	VK_FORMAT_R16G16B16A16_SNORM = 92,
	VK_FORMAT_R16G16B16A16_USCALED = 93,
	VK_FORMAT_R16G16B16A16_SSCALED = 94,
	VK_FORMAT_R16G16B16A16_UINT = 95,
	VK_FORMAT_R16G16B16A16_SINT = 96,
	VK_FORMAT_R16G16B16A16_SFLOAT = 97,
	VK_FORMAT_R32_UINT = 98,
	VK_FORMAT_R32_SINT = 99,
	VK_FORMAT_R32_SFLOAT = 100,
	VK_FORMAT_R32G32_UINT = 101,
	VK_FORMAT_R32G32_SINT = 102,
	VK_FORMAT_R32G32_SFLOAT = 103,
	VK_FORMAT_R32G32B32_UINT = 104,
	VK_FORMAT_R32G32B32_SINT = 105,
	VK_FORMAT_R32G32B32_SFLOAT = 106,
	VK_FORMAT_R32G32B32A32_UINT = 107,
	VK_FORMAT_R32G32B32A32_SINT = 108,
	VK_FORMAT_R32G32B32A32_SFLOAT = 109,
	VK_FORMAT_R64_UINT = 110,
	VK_FORMAT_R64_SINT = 111,
	VK_FORMAT_R64_SFLOAT = 112,
	VK_FORMAT_R64G64_UINT = 113,
	VK_FORMAT_R64G64_SINT = 114,
	VK_FORMAT_R64G64_SFLOAT = 115,
	VK_FORMAT_R64G64B64_UINT = 116,
	VK_FORMAT_R64G64B64_SINT = 117,
	VK_FORMAT_R64G64B64_SFLOAT = 118,
	VK_FORMAT_R64G64B64A64_UINT = 119,
	VK_FORMAT_R64G64B64A64_SINT = 120,
	VK_FORMAT_R64G64B64A64_SFLOAT = 121,
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
	VK_FORMAT_D16_UNORM = 124,
	VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
	VK_FORMAT_D32_SFLOAT = 126,
	VK_FORMAT_S8_UINT = 127,
	VK_FORMAT_D16_UNORM_S8_UINT = 128,
	VK_FORMAT_D24_UNORM_S8_UINT = 129,
	VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
	VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
	VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
	VK_FORMAT_BC2_UNORM_BLOCK = 135,
	VK_FORMAT_BC2_SRGB_BLOCK = 136,
	VK_FORMAT_BC3_UNORM_BLOCK = 137,
	VK_FORMAT_BC3_SRGB_BLOCK = 138,
	VK_FORMAT_BC4_UNORM_BLOCK = 139,
	VK_FORMAT_BC4_SNORM_BLOCK = 140,
	VK_FORMAT_BC5_UNORM_BLOCK = 141,
	VK_FORMAT_BC5_SNORM_BLOCK = 142,
	VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
	VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
	VK_FORMAT_BC7_UNORM_BLOCK = 145,
	VK_FORMAT_BC7_SRGB_BLOCK = 146,
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
	VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
	VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
	VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
	VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
	VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
	VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
	VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
	VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
	VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
	VK_FORMAT_A1B5G5R5_UNORM_PACK16 = 1000470000,
	VK_FORMAT_A8_UNORM = 1000470001,
	VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
	VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
	VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
	VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
	VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
	VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
	VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
	VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
	VK_FORMAT_R8_BOOL_ARM = 1000460000,
	VK_FORMAT_R16G16_SFIXED5_NV = 1000464000,
	VK_FORMAT_R10X6_UINT_PACK16_ARM = 1000609000,
	VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM = 1000609001,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM = 1000609002,
	VK_FORMAT_R12X4_UINT_PACK16_ARM = 1000609003,
	VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM = 1000609004,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM = 1000609005,
	VK_FORMAT_R14X2_UINT_PACK16_ARM = 1000609006,
	VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM = 1000609007,
	VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM = 1000609008,
	VK_FORMAT_R14X2_UNORM_PACK16_ARM = 1000609009,
	VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM = 1000609010,
	VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM = 1000609011,
	VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM = 1000609012,
	VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM = 1000609013,
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK,
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK,
	VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
	VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
	VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
	VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
	VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
	VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = VK_FORMAT_G16_B16R16_2PLANE_444_UNORM,
	VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = VK_FORMAT_A4R4G4B4_UNORM_PACK16,
	VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = VK_FORMAT_A4B4G4R4_UNORM_PACK16,
	VK_FORMAT_R16G16_S10_5_NV = VK_FORMAT_R16G16_SFIXED5_NV,
	VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR = VK_FORMAT_A1B5G5R5_UNORM_PACK16,
	VK_FORMAT_A8_UNORM_KHR = VK_FORMAT_A8_UNORM,
	VK_FORMAT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageTiling = ffi.typeof([[enum {
	VK_IMAGE_TILING_OPTIMAL = 0,
	VK_IMAGE_TILING_LINEAR = 1,
	VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
	VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageType = ffi.typeof([[enum {
	VK_IMAGE_TYPE_1D = 0,
	VK_IMAGE_TYPE_2D = 1,
	VK_IMAGE_TYPE_3D = 2,
	VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceType = ffi.typeof([[enum {
	VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
	VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
	VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryType = ffi.typeof([[enum {
	VK_QUERY_TYPE_OCCLUSION = 0,
	VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
	VK_QUERY_TYPE_TIMESTAMP = 2,
	VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
	VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
	VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000,
	VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
	VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
	VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
	VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
	VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSharingMode = ffi.typeof([[enum {
	VK_SHARING_MODE_EXCLUSIVE = 0,
	VK_SHARING_MODE_CONCURRENT = 1,
	VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkComponentSwizzle = ffi.typeof([[enum {
	VK_COMPONENT_SWIZZLE_IDENTITY = 0,
	VK_COMPONENT_SWIZZLE_ZERO = 1,
	VK_COMPONENT_SWIZZLE_ONE = 2,
	VK_COMPONENT_SWIZZLE_R = 3,
	VK_COMPONENT_SWIZZLE_G = 4,
	VK_COMPONENT_SWIZZLE_B = 5,
	VK_COMPONENT_SWIZZLE_A = 6,
	VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageViewType = ffi.typeof([[enum {
	VK_IMAGE_VIEW_TYPE_1D = 0,
	VK_IMAGE_VIEW_TYPE_2D = 1,
	VK_IMAGE_VIEW_TYPE_3D = 2,
	VK_IMAGE_VIEW_TYPE_CUBE = 3,
	VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
	VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
	VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandBufferLevel = ffi.typeof([[enum {
	VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
	VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
	VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkIndexType = ffi.typeof([[enum {
	VK_INDEX_TYPE_UINT16 = 0,
	VK_INDEX_TYPE_UINT32 = 1,
	VK_INDEX_TYPE_UINT8 = 1000265000,
	VK_INDEX_TYPE_NONE_KHR = 1000165000,
	VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR,
	VK_INDEX_TYPE_UINT8_EXT = VK_INDEX_TYPE_UINT8,
	VK_INDEX_TYPE_UINT8_KHR = VK_INDEX_TYPE_UINT8,
	VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineCacheHeaderVersion = ffi.typeof([[enum {
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
	VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBorderColor = ffi.typeof([[enum {
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
	VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
	VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
	VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
	VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
	VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFilter = ffi.typeof([[enum {
	VK_FILTER_NEAREST = 0,
	VK_FILTER_LINEAR = 1,
	VK_FILTER_CUBIC_EXT = 1000015000,
	VK_FILTER_CUBIC_IMG = VK_FILTER_CUBIC_EXT,
	VK_FILTER_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerAddressMode = ffi.typeof([[enum {
	VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
	VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerMipmapMode = ffi.typeof([[enum {
	VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
	VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
	VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCompareOp = ffi.typeof([[enum {
	VK_COMPARE_OP_NEVER = 0,
	VK_COMPARE_OP_LESS = 1,
	VK_COMPARE_OP_EQUAL = 2,
	VK_COMPARE_OP_LESS_OR_EQUAL = 3,
	VK_COMPARE_OP_GREATER = 4,
	VK_COMPARE_OP_NOT_EQUAL = 5,
	VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
	VK_COMPARE_OP_ALWAYS = 7,
	VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorType = ffi.typeof([[enum {
	VK_DESCRIPTOR_TYPE_SAMPLER = 0,
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
	VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
	VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
	VK_DESCRIPTOR_TYPE_TENSOR_ARM = 1000460000,
	VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
	VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570000,
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK,
	VK_DESCRIPTOR_TYPE_MUTABLE_VALVE = VK_DESCRIPTOR_TYPE_MUTABLE_EXT,
	VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineBindPoint = ffi.typeof([[enum {
	VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
	VK_PIPELINE_BIND_POINT_COMPUTE = 1,
	VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
	VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
	VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM = 1000507000,
	VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
	VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBlendFactor = ffi.typeof([[enum {
	VK_BLEND_FACTOR_ZERO = 0,
	VK_BLEND_FACTOR_ONE = 1,
	VK_BLEND_FACTOR_SRC_COLOR = 2,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
	VK_BLEND_FACTOR_DST_COLOR = 4,
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
	VK_BLEND_FACTOR_SRC_ALPHA = 6,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
	VK_BLEND_FACTOR_DST_ALPHA = 8,
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
	VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
	VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
	VK_BLEND_FACTOR_SRC1_COLOR = 15,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
	VK_BLEND_FACTOR_SRC1_ALPHA = 17,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
	VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBlendOp = ffi.typeof([[enum {
	VK_BLEND_OP_ADD = 0,
	VK_BLEND_OP_SUBTRACT = 1,
	VK_BLEND_OP_REVERSE_SUBTRACT = 2,
	VK_BLEND_OP_MIN = 3,
	VK_BLEND_OP_MAX = 4,
	VK_BLEND_OP_ZERO_EXT = 1000148000,
	VK_BLEND_OP_SRC_EXT = 1000148001,
	VK_BLEND_OP_DST_EXT = 1000148002,
	VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
	VK_BLEND_OP_DST_OVER_EXT = 1000148004,
	VK_BLEND_OP_SRC_IN_EXT = 1000148005,
	VK_BLEND_OP_DST_IN_EXT = 1000148006,
	VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
	VK_BLEND_OP_DST_OUT_EXT = 1000148008,
	VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
	VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
	VK_BLEND_OP_XOR_EXT = 1000148011,
	VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
	VK_BLEND_OP_SCREEN_EXT = 1000148013,
	VK_BLEND_OP_OVERLAY_EXT = 1000148014,
	VK_BLEND_OP_DARKEN_EXT = 1000148015,
	VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
	VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
	VK_BLEND_OP_COLORBURN_EXT = 1000148018,
	VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
	VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
	VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
	VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
	VK_BLEND_OP_INVERT_EXT = 1000148023,
	VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
	VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
	VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
	VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
	VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
	VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
	VK_BLEND_OP_HARDMIX_EXT = 1000148030,
	VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
	VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
	VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
	VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
	VK_BLEND_OP_PLUS_EXT = 1000148035,
	VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
	VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
	VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
	VK_BLEND_OP_MINUS_EXT = 1000148039,
	VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
	VK_BLEND_OP_CONTRAST_EXT = 1000148041,
	VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
	VK_BLEND_OP_RED_EXT = 1000148043,
	VK_BLEND_OP_GREEN_EXT = 1000148044,
	VK_BLEND_OP_BLUE_EXT = 1000148045,
	VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDynamicState = ffi.typeof([[enum {
	VK_DYNAMIC_STATE_VIEWPORT = 0,
	VK_DYNAMIC_STATE_SCISSOR = 1,
	VK_DYNAMIC_STATE_LINE_WIDTH = 2,
	VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
	VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
	VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
	VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
	VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
	VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
	VK_DYNAMIC_STATE_LINE_STIPPLE = 1000259000,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
	VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
	VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
	VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
	VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
	VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
	VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
	VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
	VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
	VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
	VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
	VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
	VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
	VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
	VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
	VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
	VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
	VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
	VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
	VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
	VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
	VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
	VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
	VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
	VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
	VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
	VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
	VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
	VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
	VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
	VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
	VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
	VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
	VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
	VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT = 1000582000,
	VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = VK_DYNAMIC_STATE_LINE_STIPPLE,
	VK_DYNAMIC_STATE_CULL_MODE_EXT = VK_DYNAMIC_STATE_CULL_MODE,
	VK_DYNAMIC_STATE_FRONT_FACE_EXT = VK_DYNAMIC_STATE_FRONT_FACE,
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
	VK_DYNAMIC_STATE_STENCIL_OP_EXT = VK_DYNAMIC_STATE_STENCIL_OP,
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE,
	VK_DYNAMIC_STATE_LINE_STIPPLE_KHR = VK_DYNAMIC_STATE_LINE_STIPPLE,
	VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFrontFace = ffi.typeof([[enum {
	VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
	VK_FRONT_FACE_CLOCKWISE = 1,
	VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkVertexInputRate = ffi.typeof([[enum {
	VK_VERTEX_INPUT_RATE_VERTEX = 0,
	VK_VERTEX_INPUT_RATE_INSTANCE = 1,
	VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPrimitiveTopology = ffi.typeof([[enum {
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
	VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPolygonMode = ffi.typeof([[enum {
	VK_POLYGON_MODE_FILL = 0,
	VK_POLYGON_MODE_LINE = 1,
	VK_POLYGON_MODE_POINT = 2,
	VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
	VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkStencilOp = ffi.typeof([[enum {
	VK_STENCIL_OP_KEEP = 0,
	VK_STENCIL_OP_ZERO = 1,
	VK_STENCIL_OP_REPLACE = 2,
	VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
	VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
	VK_STENCIL_OP_INVERT = 5,
	VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
	VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
	VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkLogicOp = ffi.typeof([[enum {
	VK_LOGIC_OP_CLEAR = 0,
	VK_LOGIC_OP_AND = 1,
	VK_LOGIC_OP_AND_REVERSE = 2,
	VK_LOGIC_OP_COPY = 3,
	VK_LOGIC_OP_AND_INVERTED = 4,
	VK_LOGIC_OP_NO_OP = 5,
	VK_LOGIC_OP_XOR = 6,
	VK_LOGIC_OP_OR = 7,
	VK_LOGIC_OP_NOR = 8,
	VK_LOGIC_OP_EQUIVALENT = 9,
	VK_LOGIC_OP_INVERT = 10,
	VK_LOGIC_OP_OR_REVERSE = 11,
	VK_LOGIC_OP_COPY_INVERTED = 12,
	VK_LOGIC_OP_OR_INVERTED = 13,
	VK_LOGIC_OP_NAND = 14,
	VK_LOGIC_OP_SET = 15,
	VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAttachmentLoadOp = ffi.typeof([[enum {
	VK_ATTACHMENT_LOAD_OP_LOAD = 0,
	VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
	VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
	VK_ATTACHMENT_LOAD_OP_NONE = 1000400000,
	VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE,
	VK_ATTACHMENT_LOAD_OP_NONE_KHR = VK_ATTACHMENT_LOAD_OP_NONE,
	VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAttachmentStoreOp = ffi.typeof([[enum {
	VK_ATTACHMENT_STORE_OP_STORE = 0,
	VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
	VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
	VK_ATTACHMENT_STORE_OP_NONE_KHR = VK_ATTACHMENT_STORE_OP_NONE,
	VK_ATTACHMENT_STORE_OP_NONE_QCOM = VK_ATTACHMENT_STORE_OP_NONE,
	VK_ATTACHMENT_STORE_OP_NONE_EXT = VK_ATTACHMENT_STORE_OP_NONE,
	VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubpassContents = ffi.typeof([[enum {
	VK_SUBPASS_CONTENTS_INLINE = 0,
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
	VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 1000451000,
	VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT = VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR,
	VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAccessFlagBits = ffi.typeof([[enum {
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
	VK_ACCESS_INDEX_READ_BIT = 0x00000002,
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
	VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
	VK_ACCESS_SHADER_READ_BIT = 0x00000020,
	VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
	VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
	VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
	VK_ACCESS_HOST_READ_BIT = 0x00002000,
	VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
	VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
	VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
	VK_ACCESS_NONE = 0,
	VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
	VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
	VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000,
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000,
	VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
	VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000,
	VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = 0x00020000,
	VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = 0x00040000,
	VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
	VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT,
	VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT,
	VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,
	VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAccessFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageAspectFlagBits = ffi.typeof([[enum {
	VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
	VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
	VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
	VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
	VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
	VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
	VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
	VK_IMAGE_ASPECT_NONE = 0,
	VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
	VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
	VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
	VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
	VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
	VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
	VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
	VK_IMAGE_ASPECT_NONE_KHR = VK_IMAGE_ASPECT_NONE,
	VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageAspectFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFormatFeatureFlagBits = ffi.typeof([[enum {
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
	VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
	VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000,
	VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000,
	VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000,
	VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
	VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
	VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
	VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFormatFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageCreateFlagBits = ffi.typeof([[enum {
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
	VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
	VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
	VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
	VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
	VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
	VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
	VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00010000,
	VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x00040000,
	VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x00020000,
	VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00100000,
	VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT = 0x00008000,
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
	VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
	VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
	VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT,
	VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSampleCountFlagBits = ffi.typeof([[enum {
	VK_SAMPLE_COUNT_1_BIT = 0x00000001,
	VK_SAMPLE_COUNT_2_BIT = 0x00000002,
	VK_SAMPLE_COUNT_4_BIT = 0x00000004,
	VK_SAMPLE_COUNT_8_BIT = 0x00000008,
	VK_SAMPLE_COUNT_16_BIT = 0x00000010,
	VK_SAMPLE_COUNT_32_BIT = 0x00000020,
	VK_SAMPLE_COUNT_64_BIT = 0x00000040,
	VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSampleCountFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageUsageFlagBits = ffi.typeof([[enum {
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
	VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
	VK_IMAGE_USAGE_HOST_TRANSFER_BIT = 0x00400000,
	VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400,
	VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800,
	VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000,
	VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
	VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000,
	VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x00080000,
	VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000,
	VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x00100000,
	VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x00200000,
	VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM = 0x00800000,
	VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x02000000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x04000000,
	VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
	VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT = VK_IMAGE_USAGE_HOST_TRANSFER_BIT,
	VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageUsageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkInstanceCreateFlagBits = ffi.typeof([[enum {
	VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 0x00000001,
	VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkInstanceCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMemoryHeapFlagBits = ffi.typeof([[enum {
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
	VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM = 0x00000008,
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
	VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryHeapFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMemoryPropertyFlagBits = ffi.typeof([[enum {
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
	VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
	VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
	VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
	VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
	VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryPropertyFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueueFlagBits = ffi.typeof([[enum {
	VK_QUEUE_GRAPHICS_BIT = 0x00000001,
	VK_QUEUE_COMPUTE_BIT = 0x00000002,
	VK_QUEUE_TRANSFER_BIT = 0x00000004,
	VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
	VK_QUEUE_PROTECTED_BIT = 0x00000010,
	VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020,
	VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040,
	VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x00000100,
	VK_QUEUE_DATA_GRAPH_BIT_ARM = 0x00000400,
	VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueueFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDeviceCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDeviceQueueCreateFlagBits = ffi.typeof([[enum {
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
	VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDeviceQueueCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineStageFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
	VK_PIPELINE_STAGE_NONE = 0,
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x00080000,
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x00100000,
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT = 0x00020000,
	VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT,
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT,
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT,
	VK_PIPELINE_STAGE_NONE_KHR = VK_PIPELINE_STAGE_NONE,
	VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineStageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMemoryMapFlagBits = ffi.typeof([[enum {
	VK_MEMORY_MAP_PLACED_BIT_EXT = 0x00000001,
	VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryMapFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSparseMemoryBindFlagBits = ffi.typeof([[enum {
	VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
	VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSparseMemoryBindFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSparseImageFormatFlagBits = ffi.typeof([[enum {
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
	VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSparseImageFormatFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFenceCreateFlagBits = ffi.typeof([[enum {
	VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
	VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFenceCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSemaphoreCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueryPoolCreateFlagBits = ffi.typeof([[enum {
	VK_QUERY_POOL_CREATE_RESET_BIT_KHR = 0x00000001,
	VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryPoolCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueryPipelineStatisticFlagBits = ffi.typeof([[enum {
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
	VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x00000800,
	VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x00001000,
	VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = 0x00002000,
	VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryPipelineStatisticFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueryResultFlagBits = ffi.typeof([[enum {
	VK_QUERY_RESULT_64_BIT = 0x00000001,
	VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
	VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
	VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x00000010,
	VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryResultFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBufferCreateFlagBits = ffi.typeof([[enum {
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000010,
	VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000020,
	VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00000040,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
	VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBufferCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBufferUsageFlagBits = ffi.typeof([[enum {
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000,
	VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000,
	VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00004000,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
	VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000,
	VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400,
	VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000,
	VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000,
	VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000,
	VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000,
	VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000,
	VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000,
	VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x01000000,
	VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
	VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
	VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkBufferUsageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageViewCreateFlagBits = ffi.typeof([[enum {
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
	VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000004,
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002,
	VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkImageViewCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDependencyFlagBits = ffi.typeof([[enum {
	VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
	VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
	VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
	VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x00000008,
	VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR = 0x00000020,
	VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR = 0x00000040,
	VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
	VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,
	VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDependencyFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandPoolCreateFlagBits = ffi.typeof([[enum {
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
	VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandPoolCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandPoolResetFlagBits = ffi.typeof([[enum {
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
	VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandPoolResetFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandBufferUsageFlagBits = ffi.typeof([[enum {
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
	VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandBufferUsageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueryControlFlagBits = ffi.typeof([[enum {
	VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
	VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueryControlFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandBufferResetFlagBits = ffi.typeof([[enum {
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
	VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCommandBufferResetFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkEventCreateFlagBits = ffi.typeof([[enum {
	VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x00000001,
	VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR = VK_EVENT_CREATE_DEVICE_ONLY_BIT,
	VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkEventCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBufferViewCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkShaderModuleCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCacheCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x00000001,
	VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR = 0x00000008,
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT = VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT,
	VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineCacheCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
	VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
	VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT = 0x08000000,
	VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT = 0x40000000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
	VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
	VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
	VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
	VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
	VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
	VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x00000800,
	VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000,
	VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000,
	VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400,
	VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000,
	VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000,
	VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000,
	VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000,
	VK_PIPELINE_CREATE_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
	VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
	VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
	VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
	VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT,
	VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT,
	VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineShaderStageCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x00000001,
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x00000002,
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
	VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineShaderStageCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkShaderStageFlagBits = ffi.typeof([[enum {
	VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
	VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
	VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
	VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
	VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
	VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
	VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x00000100,
	VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x00000200,
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x00000400,
	VK_SHADER_STAGE_MISS_BIT_KHR = 0x00000800,
	VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000,
	VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000,
	VK_SHADER_STAGE_TASK_BIT_EXT = 0x00000040,
	VK_SHADER_STAGE_MESH_BIT_EXT = 0x00000080,
	VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000,
	VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = 0x00080000,
	VK_SHADER_STAGE_RAYGEN_BIT_NV = VK_SHADER_STAGE_RAYGEN_BIT_KHR,
	VK_SHADER_STAGE_ANY_HIT_BIT_NV = VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
	VK_SHADER_STAGE_MISS_BIT_NV = VK_SHADER_STAGE_MISS_BIT_KHR,
	VK_SHADER_STAGE_INTERSECTION_BIT_NV = VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
	VK_SHADER_STAGE_CALLABLE_BIT_NV = VK_SHADER_STAGE_CALLABLE_BIT_KHR,
	VK_SHADER_STAGE_TASK_BIT_NV = VK_SHADER_STAGE_TASK_BIT_EXT,
	VK_SHADER_STAGE_MESH_BIT_NV = VK_SHADER_STAGE_MESH_BIT_EXT,
	VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineLayoutCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x00000002,
	VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineLayoutCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkShaderStageFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSamplerCreateFlagBits = ffi.typeof([[enum {
	VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
	VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
	VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
	VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 0x00000004,
	VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 0x00000010,
	VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorPoolCreateFlagBits = ffi.typeof([[enum {
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x00000002,
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 0x00000004,
	VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV = 0x00000008,
	VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV = 0x00000010,
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT,
	VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorPoolCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorPoolResetFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorSetLayoutCreateFlagBits = ffi.typeof([[enum {
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT = 0x00000001,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00000010,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 0x00000020,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00000080,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x00000004,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV = 0x00000040,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorSetLayoutCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkColorComponentFlagBits = ffi.typeof([[enum {
	VK_COLOR_COMPONENT_R_BIT = 0x00000001,
	VK_COLOR_COMPONENT_G_BIT = 0x00000002,
	VK_COLOR_COMPONENT_B_BIT = 0x00000004,
	VK_COLOR_COMPONENT_A_BIT = 0x00000008,
	VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkColorComponentFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCullModeFlagBits = ffi.typeof([[enum {
	VK_CULL_MODE_NONE = 0,
	VK_CULL_MODE_FRONT_BIT = 0x00000001,
	VK_CULL_MODE_BACK_BIT = 0x00000002,
	VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
	VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkCullModeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineVertexInputStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineInputAssemblyStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineTessellationStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineViewportStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineRasterizationStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineMultisampleStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineDepthStencilStateCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000001,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000002,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineDepthStencilStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineColorBlendStateCreateFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 0x00000001,
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineColorBlendStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineDynamicStateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAttachmentDescriptionFlagBits = ffi.typeof([[enum {
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
	VK_ATTACHMENT_DESCRIPTION_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR = 0x00000002,
	VK_ATTACHMENT_DESCRIPTION_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR = 0x00000004,
	VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkAttachmentDescriptionFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFramebufferCreateFlagBits = ffi.typeof([[enum {
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
	VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFramebufferCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkRenderPassCreateFlagBits = ffi.typeof([[enum {
	VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x00000002,
	VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x00000004,
	VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkRenderPassCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSubpassDescriptionFlagBits = ffi.typeof([[enum {
	VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
	VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
	VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x00000004,
	VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x00000008,
	VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM = 0x00000100,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 0x00000010,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000020,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000040,
	VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000080,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
	VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubpassDescriptionFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkStencilFaceFlagBits = ffi.typeof([[enum {
	VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
	VK_STENCIL_FACE_BACK_BIT = 0x00000002,
	VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
	VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK,
	VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkStencilFaceFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExtent2D = ffi.typeof([[struct {
	uint32_t width;
	uint32_t height;
}]])
mod.VkExtent3D = ffi.typeof([[struct {
	uint32_t width;
	uint32_t height;
	uint32_t depth;
}]])
mod.VkOffset2D = ffi.typeof([[struct {
	int32_t x;
	int32_t y;
}]])
mod.VkOffset3D = ffi.typeof([[struct {
	int32_t x;
	int32_t y;
	int32_t z;
}]])
mod.VkRect2D = ffi.typeof([[struct {
	$ offset;
	$ extent;
}]], mod.VkOffset2D, mod.VkExtent2D)
mod.VkBaseInStructure = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
mod.VkBaseOutStructure = ffi.typeof([[struct {
	$ sType;
	void* pNext;
}]], mod.VkStructureType)
mod.VkBufferMemoryBarrier = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcAccessMask;
	$ dstAccessMask;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ buffer;
	$ offset;
	$ size;
}]], mod.VkStructureType, mod.VkAccessFlags, mod.VkAccessFlags, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkImageSubresourceRange = ffi.typeof([[struct {
	$ aspectMask;
	uint32_t baseMipLevel;
	uint32_t levelCount;
	uint32_t baseArrayLayer;
	uint32_t layerCount;
}]], mod.VkImageAspectFlags)
mod.VkImageMemoryBarrier = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcAccessMask;
	$ dstAccessMask;
	$ oldLayout;
	$ newLayout;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ image;
	$ subresourceRange;
}]], mod.VkStructureType, mod.VkAccessFlags, mod.VkAccessFlags, mod.VkImageLayout, mod.VkImageLayout, mod.VkImage, mod.VkImageSubresourceRange)
mod.VkMemoryBarrier = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcAccessMask;
	$ dstAccessMask;
}]], mod.VkStructureType, mod.VkAccessFlags, mod.VkAccessFlags)
mod.PFN_vkAllocationFunction = ffi.typeof([[void*(*)(void*, size_t , size_t , $ )]], mod.VkSystemAllocationScope)
mod.PFN_vkFreeFunction = ffi.typeof([[void (*)(void*, void*)]])
mod.PFN_vkInternalAllocationNotification = ffi.typeof([[void (*)(void*, size_t , $ , $ )]], mod.VkInternalAllocationType, mod.VkSystemAllocationScope)
mod.PFN_vkInternalFreeNotification = ffi.typeof([[void (*)(void*, size_t , $ , $ )]], mod.VkInternalAllocationType, mod.VkSystemAllocationScope)
mod.PFN_vkReallocationFunction = ffi.typeof([[void*(*)(void*, void*, size_t , size_t , $ )]], mod.VkSystemAllocationScope)
mod.PFN_vkVoidFunction = ffi.typeof([[void (*)(void )]])
mod.VkAllocationCallbacks = ffi.typeof([[struct {
	void* pUserData;
	$ pfnAllocation;
	$ pfnReallocation;
	$ pfnFree;
	$ pfnInternalAllocation;
	$ pfnInternalFree;
}]], mod.PFN_vkAllocationFunction, mod.PFN_vkReallocationFunction, mod.PFN_vkFreeFunction, mod.PFN_vkInternalAllocationNotification, mod.PFN_vkInternalFreeNotification)
mod.VkApplicationInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const char* pApplicationName;
	uint32_t applicationVersion;
	const char* pEngineName;
	uint32_t engineVersion;
	uint32_t apiVersion;
}]], mod.VkStructureType)
mod.VkFormatProperties = ffi.typeof([[struct {
	$ linearTilingFeatures;
	$ optimalTilingFeatures;
	$ bufferFeatures;
}]], mod.VkFormatFeatureFlags, mod.VkFormatFeatureFlags, mod.VkFormatFeatureFlags)
mod.VkImageFormatProperties = ffi.typeof([[struct {
	$ maxExtent;
	uint32_t maxMipLevels;
	uint32_t maxArrayLayers;
	$ sampleCounts;
	$ maxResourceSize;
}]], mod.VkExtent3D, mod.VkSampleCountFlags, mod.VkDeviceSize)
mod.VkInstanceCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pApplicationInfo;
	uint32_t enabledLayerCount;
	const char** const ppEnabledLayerNames;
	uint32_t enabledExtensionCount;
	const char** const ppEnabledExtensionNames;
}]], mod.VkStructureType, mod.VkInstanceCreateFlags, mod.VkApplicationInfo)
mod.VkMemoryHeap = ffi.typeof([[struct {
	$ size;
	$ flags;
}]], mod.VkDeviceSize, mod.VkMemoryHeapFlags)
mod.VkMemoryType = ffi.typeof([[struct {
	$ propertyFlags;
	uint32_t heapIndex;
}]], mod.VkMemoryPropertyFlags)
mod.VkPhysicalDeviceFeatures = ffi.typeof([[struct {
	$ robustBufferAccess;
	$ fullDrawIndexUint32;
	$ imageCubeArray;
	$ independentBlend;
	$ geometryShader;
	$ tessellationShader;
	$ sampleRateShading;
	$ dualSrcBlend;
	$ logicOp;
	$ multiDrawIndirect;
	$ drawIndirectFirstInstance;
	$ depthClamp;
	$ depthBiasClamp;
	$ fillModeNonSolid;
	$ depthBounds;
	$ wideLines;
	$ largePoints;
	$ alphaToOne;
	$ multiViewport;
	$ samplerAnisotropy;
	$ textureCompressionETC2;
	$ textureCompressionASTC_LDR;
	$ textureCompressionBC;
	$ occlusionQueryPrecise;
	$ pipelineStatisticsQuery;
	$ vertexPipelineStoresAndAtomics;
	$ fragmentStoresAndAtomics;
	$ shaderTessellationAndGeometryPointSize;
	$ shaderImageGatherExtended;
	$ shaderStorageImageExtendedFormats;
	$ shaderStorageImageMultisample;
	$ shaderStorageImageReadWithoutFormat;
	$ shaderStorageImageWriteWithoutFormat;
	$ shaderUniformBufferArrayDynamicIndexing;
	$ shaderSampledImageArrayDynamicIndexing;
	$ shaderStorageBufferArrayDynamicIndexing;
	$ shaderStorageImageArrayDynamicIndexing;
	$ shaderClipDistance;
	$ shaderCullDistance;
	$ shaderFloat64;
	$ shaderInt64;
	$ shaderInt16;
	$ shaderResourceResidency;
	$ shaderResourceMinLod;
	$ sparseBinding;
	$ sparseResidencyBuffer;
	$ sparseResidencyImage2D;
	$ sparseResidencyImage3D;
	$ sparseResidency2Samples;
	$ sparseResidency4Samples;
	$ sparseResidency8Samples;
	$ sparseResidency16Samples;
	$ sparseResidencyAliased;
	$ variableMultisampleRate;
	$ inheritedQueries;
}]], mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceLimits = ffi.typeof([[struct {
	uint32_t maxImageDimension1D;
	uint32_t maxImageDimension2D;
	uint32_t maxImageDimension3D;
	uint32_t maxImageDimensionCube;
	uint32_t maxImageArrayLayers;
	uint32_t maxTexelBufferElements;
	uint32_t maxUniformBufferRange;
	uint32_t maxStorageBufferRange;
	uint32_t maxPushConstantsSize;
	uint32_t maxMemoryAllocationCount;
	uint32_t maxSamplerAllocationCount;
	$ bufferImageGranularity;
	$ sparseAddressSpaceSize;
	uint32_t maxBoundDescriptorSets;
	uint32_t maxPerStageDescriptorSamplers;
	uint32_t maxPerStageDescriptorUniformBuffers;
	uint32_t maxPerStageDescriptorStorageBuffers;
	uint32_t maxPerStageDescriptorSampledImages;
	uint32_t maxPerStageDescriptorStorageImages;
	uint32_t maxPerStageDescriptorInputAttachments;
	uint32_t maxPerStageResources;
	uint32_t maxDescriptorSetSamplers;
	uint32_t maxDescriptorSetUniformBuffers;
	uint32_t maxDescriptorSetUniformBuffersDynamic;
	uint32_t maxDescriptorSetStorageBuffers;
	uint32_t maxDescriptorSetStorageBuffersDynamic;
	uint32_t maxDescriptorSetSampledImages;
	uint32_t maxDescriptorSetStorageImages;
	uint32_t maxDescriptorSetInputAttachments;
	uint32_t maxVertexInputAttributes;
	uint32_t maxVertexInputBindings;
	uint32_t maxVertexInputAttributeOffset;
	uint32_t maxVertexInputBindingStride;
	uint32_t maxVertexOutputComponents;
	uint32_t maxTessellationGenerationLevel;
	uint32_t maxTessellationPatchSize;
	uint32_t maxTessellationControlPerVertexInputComponents;
	uint32_t maxTessellationControlPerVertexOutputComponents;
	uint32_t maxTessellationControlPerPatchOutputComponents;
	uint32_t maxTessellationControlTotalOutputComponents;
	uint32_t maxTessellationEvaluationInputComponents;
	uint32_t maxTessellationEvaluationOutputComponents;
	uint32_t maxGeometryShaderInvocations;
	uint32_t maxGeometryInputComponents;
	uint32_t maxGeometryOutputComponents;
	uint32_t maxGeometryOutputVertices;
	uint32_t maxGeometryTotalOutputComponents;
	uint32_t maxFragmentInputComponents;
	uint32_t maxFragmentOutputAttachments;
	uint32_t maxFragmentDualSrcAttachments;
	uint32_t maxFragmentCombinedOutputResources;
	uint32_t maxComputeSharedMemorySize;
	uint32_t maxComputeWorkGroupCount[3];
	uint32_t maxComputeWorkGroupInvocations;
	uint32_t maxComputeWorkGroupSize[3];
	uint32_t subPixelPrecisionBits;
	uint32_t subTexelPrecisionBits;
	uint32_t mipmapPrecisionBits;
	uint32_t maxDrawIndexedIndexValue;
	uint32_t maxDrawIndirectCount;
	float maxSamplerLodBias;
	float maxSamplerAnisotropy;
	uint32_t maxViewports;
	uint32_t maxViewportDimensions[2];
	float viewportBoundsRange[2];
	uint32_t viewportSubPixelBits;
	size_t minMemoryMapAlignment;
	$ minTexelBufferOffsetAlignment;
	$ minUniformBufferOffsetAlignment;
	$ minStorageBufferOffsetAlignment;
	int32_t minTexelOffset;
	uint32_t maxTexelOffset;
	int32_t minTexelGatherOffset;
	uint32_t maxTexelGatherOffset;
	float minInterpolationOffset;
	float maxInterpolationOffset;
	uint32_t subPixelInterpolationOffsetBits;
	uint32_t maxFramebufferWidth;
	uint32_t maxFramebufferHeight;
	uint32_t maxFramebufferLayers;
	$ framebufferColorSampleCounts;
	$ framebufferDepthSampleCounts;
	$ framebufferStencilSampleCounts;
	$ framebufferNoAttachmentsSampleCounts;
	uint32_t maxColorAttachments;
	$ sampledImageColorSampleCounts;
	$ sampledImageIntegerSampleCounts;
	$ sampledImageDepthSampleCounts;
	$ sampledImageStencilSampleCounts;
	$ storageImageSampleCounts;
	uint32_t maxSampleMaskWords;
	$ timestampComputeAndGraphics;
	float timestampPeriod;
	uint32_t maxClipDistances;
	uint32_t maxCullDistances;
	uint32_t maxCombinedClipAndCullDistances;
	uint32_t discreteQueuePriorities;
	float pointSizeRange[2];
	float lineWidthRange[2];
	float pointSizeGranularity;
	float lineWidthGranularity;
	$ strictLines;
	$ standardSampleLocations;
	$ optimalBufferCopyOffsetAlignment;
	$ optimalBufferCopyRowPitchAlignment;
	$ nonCoherentAtomSize;
}]], mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkSampleCountFlags, mod.VkSampleCountFlags, mod.VkSampleCountFlags, mod.VkSampleCountFlags, mod.VkSampleCountFlags, mod.VkSampleCountFlags, mod.VkSampleCountFlags, mod.VkSampleCountFlags, mod.VkSampleCountFlags, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkPhysicalDeviceMemoryProperties = ffi.typeof([[struct {
	uint32_t memoryTypeCount;
	$ memoryTypes[32U];
	uint32_t memoryHeapCount;
	$ memoryHeaps[16U];
}]], mod.VkMemoryType, mod.VkMemoryHeap)
mod.VkPhysicalDeviceSparseProperties = ffi.typeof([[struct {
	$ residencyStandard2DBlockShape;
	$ residencyStandard2DMultisampleBlockShape;
	$ residencyStandard3DBlockShape;
	$ residencyAlignedMipSize;
	$ residencyNonResidentStrict;
}]], mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceProperties = ffi.typeof([[struct {
	uint32_t apiVersion;
	uint32_t driverVersion;
	uint32_t vendorID;
	uint32_t deviceID;
	$ deviceType;
	char deviceName[256U];
	uint8_t pipelineCacheUUID[16U];
	$ limits;
	$ sparseProperties;
}]], mod.VkPhysicalDeviceType, mod.VkPhysicalDeviceLimits, mod.VkPhysicalDeviceSparseProperties)
mod.VkQueueFamilyProperties = ffi.typeof([[struct {
	$ queueFlags;
	uint32_t queueCount;
	uint32_t timestampValidBits;
	$ minImageTransferGranularity;
}]], mod.VkQueueFlags, mod.VkExtent3D)
mod.VkDeviceQueueCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t queueFamilyIndex;
	uint32_t queueCount;
	const float* pQueuePriorities;
}]], mod.VkStructureType, mod.VkDeviceQueueCreateFlags)
mod.VkDeviceCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t queueCreateInfoCount;
	const $* pQueueCreateInfos;
	uint32_t enabledLayerCount;
	const char** const ppEnabledLayerNames;
	uint32_t enabledExtensionCount;
	const char** const ppEnabledExtensionNames;
	const $* pEnabledFeatures;
}]], mod.VkStructureType, mod.VkDeviceCreateFlags, mod.VkDeviceQueueCreateInfo, mod.VkPhysicalDeviceFeatures)
mod.VkExtensionProperties = ffi.typeof([[struct {
	char extensionName[256U];
	uint32_t specVersion;
}]])
mod.VkLayerProperties = ffi.typeof([[struct {
	char layerName[256U];
	uint32_t specVersion;
	uint32_t implementationVersion;
	char description[256U];
}]])
mod.VkSubmitInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreCount;
	const $* pWaitSemaphores;
	const $* pWaitDstStageMask;
	uint32_t commandBufferCount;
	const $* pCommandBuffers;
	uint32_t signalSemaphoreCount;
	const $* pSignalSemaphores;
}]], mod.VkStructureType, mod.VkSemaphore, mod.VkPipelineStageFlags, mod.VkCommandBuffer, mod.VkSemaphore)
mod.VkMappedMemoryRange = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ offset;
	$ size;
}]], mod.VkStructureType, mod.VkDeviceMemory, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkMemoryAllocateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ allocationSize;
	uint32_t memoryTypeIndex;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkMemoryRequirements = ffi.typeof([[struct {
	$ size;
	$ alignment;
	uint32_t memoryTypeBits;
}]], mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkSparseMemoryBind = ffi.typeof([[struct {
	$ resourceOffset;
	$ size;
	$ memory;
	$ memoryOffset;
	$ flags;
}]], mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceMemory, mod.VkDeviceSize, mod.VkSparseMemoryBindFlags)
mod.VkSparseBufferMemoryBindInfo = ffi.typeof([[struct {
	$ buffer;
	uint32_t bindCount;
	const $* pBinds;
}]], mod.VkBuffer, mod.VkSparseMemoryBind)
mod.VkSparseImageOpaqueMemoryBindInfo = ffi.typeof([[struct {
	$ image;
	uint32_t bindCount;
	const $* pBinds;
}]], mod.VkImage, mod.VkSparseMemoryBind)
mod.VkImageSubresource = ffi.typeof([[struct {
	$ aspectMask;
	uint32_t mipLevel;
	uint32_t arrayLayer;
}]], mod.VkImageAspectFlags)
mod.VkSparseImageMemoryBind = ffi.typeof([[struct {
	$ subresource;
	$ offset;
	$ extent;
	$ memory;
	$ memoryOffset;
	$ flags;
}]], mod.VkImageSubresource, mod.VkOffset3D, mod.VkExtent3D, mod.VkDeviceMemory, mod.VkDeviceSize, mod.VkSparseMemoryBindFlags)
mod.VkSparseImageMemoryBindInfo = ffi.typeof([[struct {
	$ image;
	uint32_t bindCount;
	const $* pBinds;
}]], mod.VkImage, mod.VkSparseImageMemoryBind)
mod.VkBindSparseInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreCount;
	const $* pWaitSemaphores;
	uint32_t bufferBindCount;
	const $* pBufferBinds;
	uint32_t imageOpaqueBindCount;
	const $* pImageOpaqueBinds;
	uint32_t imageBindCount;
	const $* pImageBinds;
	uint32_t signalSemaphoreCount;
	const $* pSignalSemaphores;
}]], mod.VkStructureType, mod.VkSemaphore, mod.VkSparseBufferMemoryBindInfo, mod.VkSparseImageOpaqueMemoryBindInfo, mod.VkSparseImageMemoryBindInfo, mod.VkSemaphore)
mod.VkSparseImageFormatProperties = ffi.typeof([[struct {
	$ aspectMask;
	$ imageGranularity;
	$ flags;
}]], mod.VkImageAspectFlags, mod.VkExtent3D, mod.VkSparseImageFormatFlags)
mod.VkSparseImageMemoryRequirements = ffi.typeof([[struct {
	$ formatProperties;
	uint32_t imageMipTailFirstLod;
	$ imageMipTailSize;
	$ imageMipTailOffset;
	$ imageMipTailStride;
}]], mod.VkSparseImageFormatProperties, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkFenceCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkFenceCreateFlags)
mod.VkSemaphoreCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkSemaphoreCreateFlags)
mod.VkQueryPoolCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ queryType;
	uint32_t queryCount;
	$ pipelineStatistics;
}]], mod.VkStructureType, mod.VkQueryPoolCreateFlags, mod.VkQueryType, mod.VkQueryPipelineStatisticFlags)
mod.VkBufferCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ size;
	$ usage;
	$ sharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
}]], mod.VkStructureType, mod.VkBufferCreateFlags, mod.VkDeviceSize, mod.VkBufferUsageFlags, mod.VkSharingMode)
mod.VkImageCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ imageType;
	$ format;
	$ extent;
	uint32_t mipLevels;
	uint32_t arrayLayers;
	$ samples;
	$ tiling;
	$ usage;
	$ sharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
	$ initialLayout;
}]], mod.VkStructureType, mod.VkImageCreateFlags, mod.VkImageType, mod.VkFormat, mod.VkExtent3D, mod.VkSampleCountFlagBits, mod.VkImageTiling, mod.VkImageUsageFlags, mod.VkSharingMode, mod.VkImageLayout)
mod.VkSubresourceLayout = ffi.typeof([[struct {
	$ offset;
	$ size;
	$ rowPitch;
	$ arrayPitch;
	$ depthPitch;
}]], mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkComponentMapping = ffi.typeof([[struct {
	$ r;
	$ g;
	$ b;
	$ a;
}]], mod.VkComponentSwizzle, mod.VkComponentSwizzle, mod.VkComponentSwizzle, mod.VkComponentSwizzle)
mod.VkImageViewCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ image;
	$ viewType;
	$ format;
	$ components;
	$ subresourceRange;
}]], mod.VkStructureType, mod.VkImageViewCreateFlags, mod.VkImage, mod.VkImageViewType, mod.VkFormat, mod.VkComponentMapping, mod.VkImageSubresourceRange)
mod.VkCommandPoolCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t queueFamilyIndex;
}]], mod.VkStructureType, mod.VkCommandPoolCreateFlags)
mod.VkCommandBufferAllocateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ commandPool;
	$ level;
	uint32_t commandBufferCount;
}]], mod.VkStructureType, mod.VkCommandPool, mod.VkCommandBufferLevel)
mod.VkCommandBufferInheritanceInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ renderPass;
	uint32_t subpass;
	$ framebuffer;
	$ occlusionQueryEnable;
	$ queryFlags;
	$ pipelineStatistics;
}]], mod.VkStructureType, mod.VkRenderPass, mod.VkFramebuffer, mod.VkBool32, mod.VkQueryControlFlags, mod.VkQueryPipelineStatisticFlags)
mod.VkCommandBufferBeginInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pInheritanceInfo;
}]], mod.VkStructureType, mod.VkCommandBufferUsageFlags, mod.VkCommandBufferInheritanceInfo)
mod.VkBufferCopy = ffi.typeof([[struct {
	$ srcOffset;
	$ dstOffset;
	$ size;
}]], mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkImageSubresourceLayers = ffi.typeof([[struct {
	$ aspectMask;
	uint32_t mipLevel;
	uint32_t baseArrayLayer;
	uint32_t layerCount;
}]], mod.VkImageAspectFlags)
mod.VkBufferImageCopy = ffi.typeof([[struct {
	$ bufferOffset;
	uint32_t bufferRowLength;
	uint32_t bufferImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]], mod.VkDeviceSize, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkImageCopy = ffi.typeof([[struct {
	$ srcSubresource;
	$ srcOffset;
	$ dstSubresource;
	$ dstOffset;
	$ extent;
}]], mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkDispatchIndirectCommand = ffi.typeof([[struct {
	uint32_t x;
	uint32_t y;
	uint32_t z;
}]])
mod.VkPipelineCacheHeaderVersionOne = ffi.typeof([[struct {
	uint32_t headerSize;
	$ headerVersion;
	uint32_t vendorID;
	uint32_t deviceID;
	uint8_t pipelineCacheUUID[16U];
}]], mod.VkPipelineCacheHeaderVersion)
mod.VkEventCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkEventCreateFlags)
mod.VkBufferViewCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ buffer;
	$ format;
	$ offset;
	$ range;
}]], mod.VkStructureType, mod.VkBufferViewCreateFlags, mod.VkBuffer, mod.VkFormat, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkShaderModuleCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	size_t codeSize;
	const uint32_t* pCode;
}]], mod.VkStructureType, mod.VkShaderModuleCreateFlags)
mod.VkPipelineCacheCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	size_t initialDataSize;
	const void* pInitialData;
}]], mod.VkStructureType, mod.VkPipelineCacheCreateFlags)
mod.VkSpecializationMapEntry = ffi.typeof([[struct {
	uint32_t constantID;
	uint32_t offset;
	size_t size;
}]])
mod.VkSpecializationInfo = ffi.typeof([[struct {
	uint32_t mapEntryCount;
	const $* pMapEntries;
	size_t dataSize;
	const void* pData;
}]], mod.VkSpecializationMapEntry)
mod.VkPipelineShaderStageCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ stage;
	$ module;
	const char* pName;
	const $* pSpecializationInfo;
}]], mod.VkStructureType, mod.VkPipelineShaderStageCreateFlags, mod.VkShaderStageFlagBits, mod.VkShaderModule, mod.VkSpecializationInfo)
mod.VkComputePipelineCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ stage;
	$ layout;
	$ basePipelineHandle;
	int32_t basePipelineIndex;
}]], mod.VkStructureType, mod.VkPipelineCreateFlags, mod.VkPipelineShaderStageCreateInfo, mod.VkPipelineLayout, mod.VkPipeline)
mod.VkPushConstantRange = ffi.typeof([[struct {
	$ stageFlags;
	uint32_t offset;
	uint32_t size;
}]], mod.VkShaderStageFlags)
mod.VkPipelineLayoutCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t setLayoutCount;
	const $* pSetLayouts;
	uint32_t pushConstantRangeCount;
	const $* pPushConstantRanges;
}]], mod.VkStructureType, mod.VkPipelineLayoutCreateFlags, mod.VkDescriptorSetLayout, mod.VkPushConstantRange)
mod.VkSamplerCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ magFilter;
	$ minFilter;
	$ mipmapMode;
	$ addressModeU;
	$ addressModeV;
	$ addressModeW;
	float mipLodBias;
	$ anisotropyEnable;
	float maxAnisotropy;
	$ compareEnable;
	$ compareOp;
	float minLod;
	float maxLod;
	$ borderColor;
	$ unnormalizedCoordinates;
}]], mod.VkStructureType, mod.VkSamplerCreateFlags, mod.VkFilter, mod.VkFilter, mod.VkSamplerMipmapMode, mod.VkSamplerAddressMode, mod.VkSamplerAddressMode, mod.VkSamplerAddressMode, mod.VkBool32, mod.VkBool32, mod.VkCompareOp, mod.VkBorderColor, mod.VkBool32)
mod.VkCopyDescriptorSet = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcSet;
	uint32_t srcBinding;
	uint32_t srcArrayElement;
	$ dstSet;
	uint32_t dstBinding;
	uint32_t dstArrayElement;
	uint32_t descriptorCount;
}]], mod.VkStructureType, mod.VkDescriptorSet, mod.VkDescriptorSet)
mod.VkDescriptorBufferInfo = ffi.typeof([[struct {
	$ buffer;
	$ offset;
	$ range;
}]], mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkDescriptorImageInfo = ffi.typeof([[struct {
	$ sampler;
	$ imageView;
	$ imageLayout;
}]], mod.VkSampler, mod.VkImageView, mod.VkImageLayout)
mod.VkDescriptorPoolSize = ffi.typeof([[struct {
	$ type;
	uint32_t descriptorCount;
}]], mod.VkDescriptorType)
mod.VkDescriptorPoolCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t maxSets;
	uint32_t poolSizeCount;
	const $* pPoolSizes;
}]], mod.VkStructureType, mod.VkDescriptorPoolCreateFlags, mod.VkDescriptorPoolSize)
mod.VkDescriptorSetAllocateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ descriptorPool;
	uint32_t descriptorSetCount;
	const $* pSetLayouts;
}]], mod.VkStructureType, mod.VkDescriptorPool, mod.VkDescriptorSetLayout)
mod.VkDescriptorSetLayoutBinding = ffi.typeof([[struct {
	uint32_t binding;
	$ descriptorType;
	uint32_t descriptorCount;
	$ stageFlags;
	const $* pImmutableSamplers;
}]], mod.VkDescriptorType, mod.VkShaderStageFlags, mod.VkSampler)
mod.VkDescriptorSetLayoutCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t bindingCount;
	const $* pBindings;
}]], mod.VkStructureType, mod.VkDescriptorSetLayoutCreateFlags, mod.VkDescriptorSetLayoutBinding)
mod.VkWriteDescriptorSet = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ dstSet;
	uint32_t dstBinding;
	uint32_t dstArrayElement;
	uint32_t descriptorCount;
	$ descriptorType;
	const $* pImageInfo;
	const $* pBufferInfo;
	const $* pTexelBufferView;
}]], mod.VkStructureType, mod.VkDescriptorSet, mod.VkDescriptorType, mod.VkDescriptorImageInfo, mod.VkDescriptorBufferInfo, mod.VkBufferView)
mod.VkClearColorValue = ffi.typeof([[union {
	float float32[4];
	int32_t int32[4];
	uint32_t uint32[4];
}]])
mod.VkDrawIndexedIndirectCommand = ffi.typeof([[struct {
	uint32_t indexCount;
	uint32_t instanceCount;
	uint32_t firstIndex;
	int32_t vertexOffset;
	uint32_t firstInstance;
}]])
mod.VkDrawIndirectCommand = ffi.typeof([[struct {
	uint32_t vertexCount;
	uint32_t instanceCount;
	uint32_t firstVertex;
	uint32_t firstInstance;
}]])
mod.VkVertexInputBindingDescription = ffi.typeof([[struct {
	uint32_t binding;
	uint32_t stride;
	$ inputRate;
}]], mod.VkVertexInputRate)
mod.VkVertexInputAttributeDescription = ffi.typeof([[struct {
	uint32_t location;
	uint32_t binding;
	$ format;
	uint32_t offset;
}]], mod.VkFormat)
mod.VkPipelineVertexInputStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t vertexBindingDescriptionCount;
	const $* pVertexBindingDescriptions;
	uint32_t vertexAttributeDescriptionCount;
	const $* pVertexAttributeDescriptions;
}]], mod.VkStructureType, mod.VkPipelineVertexInputStateCreateFlags, mod.VkVertexInputBindingDescription, mod.VkVertexInputAttributeDescription)
mod.VkPipelineInputAssemblyStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ topology;
	$ primitiveRestartEnable;
}]], mod.VkStructureType, mod.VkPipelineInputAssemblyStateCreateFlags, mod.VkPrimitiveTopology, mod.VkBool32)
mod.VkPipelineTessellationStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t patchControlPoints;
}]], mod.VkStructureType, mod.VkPipelineTessellationStateCreateFlags)
mod.VkViewport = ffi.typeof([[struct {
	float x;
	float y;
	float width;
	float height;
	float minDepth;
	float maxDepth;
}]])
mod.VkPipelineViewportStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t viewportCount;
	const $* pViewports;
	uint32_t scissorCount;
	const $* pScissors;
}]], mod.VkStructureType, mod.VkPipelineViewportStateCreateFlags, mod.VkViewport, mod.VkRect2D)
mod.VkPipelineRasterizationStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ depthClampEnable;
	$ rasterizerDiscardEnable;
	$ polygonMode;
	$ cullMode;
	$ frontFace;
	$ depthBiasEnable;
	float depthBiasConstantFactor;
	float depthBiasClamp;
	float depthBiasSlopeFactor;
	float lineWidth;
}]], mod.VkStructureType, mod.VkPipelineRasterizationStateCreateFlags, mod.VkBool32, mod.VkBool32, mod.VkPolygonMode, mod.VkCullModeFlags, mod.VkFrontFace, mod.VkBool32)
mod.VkPipelineMultisampleStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ rasterizationSamples;
	$ sampleShadingEnable;
	float minSampleShading;
	const $* pSampleMask;
	$ alphaToCoverageEnable;
	$ alphaToOneEnable;
}]], mod.VkStructureType, mod.VkPipelineMultisampleStateCreateFlags, mod.VkSampleCountFlagBits, mod.VkBool32, mod.VkSampleMask, mod.VkBool32, mod.VkBool32)
mod.VkStencilOpState = ffi.typeof([[struct {
	$ failOp;
	$ passOp;
	$ depthFailOp;
	$ compareOp;
	uint32_t compareMask;
	uint32_t writeMask;
	uint32_t reference;
}]], mod.VkStencilOp, mod.VkStencilOp, mod.VkStencilOp, mod.VkCompareOp)
mod.VkPipelineDepthStencilStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ depthTestEnable;
	$ depthWriteEnable;
	$ depthCompareOp;
	$ depthBoundsTestEnable;
	$ stencilTestEnable;
	$ front;
	$ back;
	float minDepthBounds;
	float maxDepthBounds;
}]], mod.VkStructureType, mod.VkPipelineDepthStencilStateCreateFlags, mod.VkBool32, mod.VkBool32, mod.VkCompareOp, mod.VkBool32, mod.VkBool32, mod.VkStencilOpState, mod.VkStencilOpState)
mod.VkPipelineColorBlendAttachmentState = ffi.typeof([[struct {
	$ blendEnable;
	$ srcColorBlendFactor;
	$ dstColorBlendFactor;
	$ colorBlendOp;
	$ srcAlphaBlendFactor;
	$ dstAlphaBlendFactor;
	$ alphaBlendOp;
	$ colorWriteMask;
}]], mod.VkBool32, mod.VkBlendFactor, mod.VkBlendFactor, mod.VkBlendOp, mod.VkBlendFactor, mod.VkBlendFactor, mod.VkBlendOp, mod.VkColorComponentFlags)
mod.VkPipelineColorBlendStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ logicOpEnable;
	$ logicOp;
	uint32_t attachmentCount;
	const $* pAttachments;
	float blendConstants[4];
}]], mod.VkStructureType, mod.VkPipelineColorBlendStateCreateFlags, mod.VkBool32, mod.VkLogicOp, mod.VkPipelineColorBlendAttachmentState)
mod.VkPipelineDynamicStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t dynamicStateCount;
	const $* pDynamicStates;
}]], mod.VkStructureType, mod.VkPipelineDynamicStateCreateFlags, mod.VkDynamicState)
mod.VkGraphicsPipelineCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t stageCount;
	const $* pStages;
	const $* pVertexInputState;
	const $* pInputAssemblyState;
	const $* pTessellationState;
	const $* pViewportState;
	const $* pRasterizationState;
	const $* pMultisampleState;
	const $* pDepthStencilState;
	const $* pColorBlendState;
	const $* pDynamicState;
	$ layout;
	$ renderPass;
	uint32_t subpass;
	$ basePipelineHandle;
	int32_t basePipelineIndex;
}]], mod.VkStructureType, mod.VkPipelineCreateFlags, mod.VkPipelineShaderStageCreateInfo, mod.VkPipelineVertexInputStateCreateInfo, mod.VkPipelineInputAssemblyStateCreateInfo, mod.VkPipelineTessellationStateCreateInfo, mod.VkPipelineViewportStateCreateInfo, mod.VkPipelineRasterizationStateCreateInfo, mod.VkPipelineMultisampleStateCreateInfo, mod.VkPipelineDepthStencilStateCreateInfo, mod.VkPipelineColorBlendStateCreateInfo, mod.VkPipelineDynamicStateCreateInfo, mod.VkPipelineLayout, mod.VkRenderPass, mod.VkPipeline)
mod.VkAttachmentDescription = ffi.typeof([[struct {
	$ flags;
	$ format;
	$ samples;
	$ loadOp;
	$ storeOp;
	$ stencilLoadOp;
	$ stencilStoreOp;
	$ initialLayout;
	$ finalLayout;
}]], mod.VkAttachmentDescriptionFlags, mod.VkFormat, mod.VkSampleCountFlagBits, mod.VkAttachmentLoadOp, mod.VkAttachmentStoreOp, mod.VkAttachmentLoadOp, mod.VkAttachmentStoreOp, mod.VkImageLayout, mod.VkImageLayout)
mod.VkAttachmentReference = ffi.typeof([[struct {
	uint32_t attachment;
	$ layout;
}]], mod.VkImageLayout)
mod.VkFramebufferCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ renderPass;
	uint32_t attachmentCount;
	const $* pAttachments;
	uint32_t width;
	uint32_t height;
	uint32_t layers;
}]], mod.VkStructureType, mod.VkFramebufferCreateFlags, mod.VkRenderPass, mod.VkImageView)
mod.VkSubpassDescription = ffi.typeof([[struct {
	$ flags;
	$ pipelineBindPoint;
	uint32_t inputAttachmentCount;
	const $* pInputAttachments;
	uint32_t colorAttachmentCount;
	const $* pColorAttachments;
	const $* pResolveAttachments;
	const $* pDepthStencilAttachment;
	uint32_t preserveAttachmentCount;
	const uint32_t* pPreserveAttachments;
}]], mod.VkSubpassDescriptionFlags, mod.VkPipelineBindPoint, mod.VkAttachmentReference, mod.VkAttachmentReference, mod.VkAttachmentReference, mod.VkAttachmentReference)
mod.VkSubpassDependency = ffi.typeof([[struct {
	uint32_t srcSubpass;
	uint32_t dstSubpass;
	$ srcStageMask;
	$ dstStageMask;
	$ srcAccessMask;
	$ dstAccessMask;
	$ dependencyFlags;
}]], mod.VkPipelineStageFlags, mod.VkPipelineStageFlags, mod.VkAccessFlags, mod.VkAccessFlags, mod.VkDependencyFlags)
mod.VkRenderPassCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t attachmentCount;
	const $* pAttachments;
	uint32_t subpassCount;
	const $* pSubpasses;
	uint32_t dependencyCount;
	const $* pDependencies;
}]], mod.VkStructureType, mod.VkRenderPassCreateFlags, mod.VkAttachmentDescription, mod.VkSubpassDescription, mod.VkSubpassDependency)
mod.VkClearDepthStencilValue = ffi.typeof([[struct {
	float depth;
	uint32_t stencil;
}]])
mod.VkClearValue = ffi.typeof([[union {
	$ color;
	$ depthStencil;
}]], mod.VkClearColorValue, mod.VkClearDepthStencilValue)
mod.VkClearAttachment = ffi.typeof([[struct {
	$ aspectMask;
	uint32_t colorAttachment;
	$ clearValue;
}]], mod.VkImageAspectFlags, mod.VkClearValue)
mod.VkClearRect = ffi.typeof([[struct {
	$ rect;
	uint32_t baseArrayLayer;
	uint32_t layerCount;
}]], mod.VkRect2D)
mod.VkImageBlit = ffi.typeof([[struct {
	$ srcSubresource;
	$ srcOffsets[2];
	$ dstSubresource;
	$ dstOffsets[2];
}]], mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkImageSubresourceLayers, mod.VkOffset3D)
mod.VkImageResolve = ffi.typeof([[struct {
	$ srcSubresource;
	$ srcOffset;
	$ dstSubresource;
	$ dstOffset;
	$ extent;
}]], mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkRenderPassBeginInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ renderPass;
	$ framebuffer;
	$ renderArea;
	uint32_t clearValueCount;
	const $* pClearValues;
}]], mod.VkStructureType, mod.VkRenderPass, mod.VkFramebuffer, mod.VkRect2D, mod.VkClearValue)
mod.PFN_vkCreateInstance = ffi.typeof([[$ (*)(const $*, const $*, $*)]], mod.VkResult, mod.VkInstanceCreateInfo, mod.VkAllocationCallbacks, mod.VkInstance)
mod.PFN_vkDestroyInstance = ffi.typeof([[void (*)($ , const $*)]], mod.VkInstance, mod.VkAllocationCallbacks)
mod.PFN_vkEnumeratePhysicalDevices = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkInstance, mod.VkPhysicalDevice)
mod.PFN_vkGetPhysicalDeviceFeatures = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures)
mod.PFN_vkGetPhysicalDeviceFormatProperties = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkPhysicalDevice, mod.VkFormat, mod.VkFormatProperties)
mod.PFN_vkGetPhysicalDeviceImageFormatProperties = ffi.typeof([[$ (*)($ , $ , $ , $ , $ , $ , $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkFormat, mod.VkImageType, mod.VkImageTiling, mod.VkImageUsageFlags, mod.VkImageCreateFlags, mod.VkImageFormatProperties)
mod.PFN_vkGetPhysicalDeviceProperties = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties)
mod.PFN_vkGetPhysicalDeviceQueueFamilyProperties = ffi.typeof([[void (*)($ , uint32_t*, $*)]], mod.VkPhysicalDevice, mod.VkQueueFamilyProperties)
mod.PFN_vkGetPhysicalDeviceMemoryProperties = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties)
mod.PFN_vkGetInstanceProcAddr = ffi.typeof([[$ (*)($ , const char*)]], mod.PFN_vkVoidFunction, mod.VkInstance)
mod.PFN_vkGetDeviceProcAddr = ffi.typeof([[$ (*)($ , const char*)]], mod.PFN_vkVoidFunction, mod.VkDevice)
mod.PFN_vkCreateDevice = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDeviceCreateInfo, mod.VkAllocationCallbacks, mod.VkDevice)
mod.PFN_vkDestroyDevice = ffi.typeof([[void (*)($ , const $*)]], mod.VkDevice, mod.VkAllocationCallbacks)
mod.PFN_vkEnumerateInstanceExtensionProperties = ffi.typeof([[$ (*)(const char*, uint32_t*, $*)]], mod.VkResult, mod.VkExtensionProperties)
mod.PFN_vkEnumerateDeviceExtensionProperties = ffi.typeof([[$ (*)($ , const char*, uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkExtensionProperties)
mod.PFN_vkEnumerateInstanceLayerProperties = ffi.typeof([[$ (*)(uint32_t*, $*)]], mod.VkResult, mod.VkLayerProperties)
mod.PFN_vkEnumerateDeviceLayerProperties = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkLayerProperties)
mod.PFN_vkGetDeviceQueue = ffi.typeof([[void (*)($ , uint32_t , uint32_t , $*)]], mod.VkDevice, mod.VkQueue)
mod.PFN_vkQueueSubmit = ffi.typeof([[$ (*)($ , uint32_t , const $*, $ )]], mod.VkResult, mod.VkQueue, mod.VkSubmitInfo, mod.VkFence)
mod.PFN_vkQueueWaitIdle = ffi.typeof([[$ (*)($ )]], mod.VkResult, mod.VkQueue)
mod.PFN_vkDeviceWaitIdle = ffi.typeof([[$ (*)($ )]], mod.VkResult, mod.VkDevice)
mod.PFN_vkAllocateMemory = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkMemoryAllocateInfo, mod.VkAllocationCallbacks, mod.VkDeviceMemory)
mod.PFN_vkFreeMemory = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkDeviceMemory, mod.VkAllocationCallbacks)
mod.PFN_vkMapMemory = ffi.typeof([[$ (*)($ , $ , $ , $ , $ , void**)]], mod.VkResult, mod.VkDevice, mod.VkDeviceMemory, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkMemoryMapFlags)
mod.PFN_vkUnmapMemory = ffi.typeof([[void (*)($ , $ )]], mod.VkDevice, mod.VkDeviceMemory)
mod.PFN_vkFlushMappedMemoryRanges = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkMappedMemoryRange)
mod.PFN_vkInvalidateMappedMemoryRanges = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkMappedMemoryRange)
mod.PFN_vkGetDeviceMemoryCommitment = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.PFN_vkBindBufferMemory = ffi.typeof([[$ (*)($ , $ , $ , $ )]], mod.VkResult, mod.VkDevice, mod.VkBuffer, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.PFN_vkBindImageMemory = ffi.typeof([[$ (*)($ , $ , $ , $ )]], mod.VkResult, mod.VkDevice, mod.VkImage, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.PFN_vkGetBufferMemoryRequirements = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkBuffer, mod.VkMemoryRequirements)
mod.PFN_vkGetImageMemoryRequirements = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkImage, mod.VkMemoryRequirements)
mod.PFN_vkGetImageSparseMemoryRequirements = ffi.typeof([[void (*)($ , $ , uint32_t*, $*)]], mod.VkDevice, mod.VkImage, mod.VkSparseImageMemoryRequirements)
mod.PFN_vkGetPhysicalDeviceSparseImageFormatProperties = ffi.typeof([[void (*)($ , $ , $ , $ , $ , $ , uint32_t*, $*)]], mod.VkPhysicalDevice, mod.VkFormat, mod.VkImageType, mod.VkSampleCountFlagBits, mod.VkImageUsageFlags, mod.VkImageTiling, mod.VkSparseImageFormatProperties)
mod.PFN_vkQueueBindSparse = ffi.typeof([[$ (*)($ , uint32_t , const $*, $ )]], mod.VkResult, mod.VkQueue, mod.VkBindSparseInfo, mod.VkFence)
mod.PFN_vkCreateFence = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkFenceCreateInfo, mod.VkAllocationCallbacks, mod.VkFence)
mod.PFN_vkDestroyFence = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkFence, mod.VkAllocationCallbacks)
mod.PFN_vkResetFences = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkFence)
mod.PFN_vkGetFenceStatus = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkFence)
mod.PFN_vkWaitForFences = ffi.typeof([[$ (*)($ , uint32_t , const $*, $ , uint64_t )]], mod.VkResult, mod.VkDevice, mod.VkFence, mod.VkBool32)
mod.PFN_vkCreateSemaphore = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreCreateInfo, mod.VkAllocationCallbacks, mod.VkSemaphore)
mod.PFN_vkDestroySemaphore = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkSemaphore, mod.VkAllocationCallbacks)
mod.PFN_vkCreateQueryPool = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkQueryPoolCreateInfo, mod.VkAllocationCallbacks, mod.VkQueryPool)
mod.PFN_vkDestroyQueryPool = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkQueryPool, mod.VkAllocationCallbacks)
mod.PFN_vkGetQueryPoolResults = ffi.typeof([[$ (*)($ , $ , uint32_t , uint32_t , size_t , void*, $ , $ )]], mod.VkResult, mod.VkDevice, mod.VkQueryPool, mod.VkDeviceSize, mod.VkQueryResultFlags)
mod.PFN_vkCreateBuffer = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkBufferCreateInfo, mod.VkAllocationCallbacks, mod.VkBuffer)
mod.PFN_vkDestroyBuffer = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkBuffer, mod.VkAllocationCallbacks)
mod.PFN_vkCreateImage = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkImageCreateInfo, mod.VkAllocationCallbacks, mod.VkImage)
mod.PFN_vkDestroyImage = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkImage, mod.VkAllocationCallbacks)
mod.PFN_vkGetImageSubresourceLayout = ffi.typeof([[void (*)($ , $ , const $*, $*)]], mod.VkDevice, mod.VkImage, mod.VkImageSubresource, mod.VkSubresourceLayout)
mod.PFN_vkCreateImageView = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkImageViewCreateInfo, mod.VkAllocationCallbacks, mod.VkImageView)
mod.PFN_vkDestroyImageView = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkImageView, mod.VkAllocationCallbacks)
mod.PFN_vkCreateCommandPool = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkCommandPoolCreateInfo, mod.VkAllocationCallbacks, mod.VkCommandPool)
mod.PFN_vkDestroyCommandPool = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkCommandPool, mod.VkAllocationCallbacks)
mod.PFN_vkResetCommandPool = ffi.typeof([[$ (*)($ , $ , $ )]], mod.VkResult, mod.VkDevice, mod.VkCommandPool, mod.VkCommandPoolResetFlags)
mod.PFN_vkAllocateCommandBuffers = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkCommandBufferAllocateInfo, mod.VkCommandBuffer)
mod.PFN_vkFreeCommandBuffers = ffi.typeof([[void (*)($ , $ , uint32_t , const $*)]], mod.VkDevice, mod.VkCommandPool, mod.VkCommandBuffer)
mod.PFN_vkBeginCommandBuffer = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkCommandBuffer, mod.VkCommandBufferBeginInfo)
mod.PFN_vkEndCommandBuffer = ffi.typeof([[$ (*)($ )]], mod.VkResult, mod.VkCommandBuffer)
mod.PFN_vkResetCommandBuffer = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkCommandBuffer, mod.VkCommandBufferResetFlags)
mod.PFN_vkCmdCopyBuffer = ffi.typeof([[void (*)($ , $ , $ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkBuffer, mod.VkBufferCopy)
mod.PFN_vkCmdCopyImage = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageCopy)
mod.PFN_vkCmdCopyBufferToImage = ffi.typeof([[void (*)($ , $ , $ , $ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkImage, mod.VkImageLayout, mod.VkBufferImageCopy)
mod.PFN_vkCmdCopyImageToBuffer = ffi.typeof([[void (*)($ , $ , $ , $ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkBuffer, mod.VkBufferImageCopy)
mod.PFN_vkCmdUpdateBuffer = ffi.typeof([[void (*)($ , $ , $ , $ , const void*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
mod.PFN_vkCmdFillBuffer = ffi.typeof([[void (*)($ , $ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
mod.PFN_vkCmdPipelineBarrier = ffi.typeof([[void (*)($ , $ , $ , $ , uint32_t , const $*, uint32_t , const $*, uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkPipelineStageFlags, mod.VkPipelineStageFlags, mod.VkDependencyFlags, mod.VkMemoryBarrier, mod.VkBufferMemoryBarrier, mod.VkImageMemoryBarrier)
mod.PFN_vkCmdBeginQuery = ffi.typeof([[void (*)($ , $ , uint32_t , $ )]], mod.VkCommandBuffer, mod.VkQueryPool, mod.VkQueryControlFlags)
mod.PFN_vkCmdEndQuery = ffi.typeof([[void (*)($ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkQueryPool)
mod.PFN_vkCmdResetQueryPool = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkQueryPool)
mod.PFN_vkCmdWriteTimestamp = ffi.typeof([[void (*)($ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkPipelineStageFlagBits, mod.VkQueryPool)
mod.PFN_vkCmdCopyQueryPoolResults = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t , $ , $ , $ , $ )]], mod.VkCommandBuffer, mod.VkQueryPool, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkQueryResultFlags)
mod.PFN_vkCmdExecuteCommands = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkCommandBuffer)
mod.PFN_vkCreateEvent = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkEventCreateInfo, mod.VkAllocationCallbacks, mod.VkEvent)
mod.PFN_vkDestroyEvent = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkEvent, mod.VkAllocationCallbacks)
mod.PFN_vkGetEventStatus = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkEvent)
mod.PFN_vkSetEvent = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkEvent)
mod.PFN_vkResetEvent = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkEvent)
mod.PFN_vkCreateBufferView = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkBufferViewCreateInfo, mod.VkAllocationCallbacks, mod.VkBufferView)
mod.PFN_vkDestroyBufferView = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkBufferView, mod.VkAllocationCallbacks)
mod.PFN_vkCreateShaderModule = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkShaderModuleCreateInfo, mod.VkAllocationCallbacks, mod.VkShaderModule)
mod.PFN_vkDestroyShaderModule = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkShaderModule, mod.VkAllocationCallbacks)
mod.PFN_vkCreatePipelineCache = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineCacheCreateInfo, mod.VkAllocationCallbacks, mod.VkPipelineCache)
mod.PFN_vkDestroyPipelineCache = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkPipelineCache, mod.VkAllocationCallbacks)
mod.PFN_vkGetPipelineCacheData = ffi.typeof([[$ (*)($ , $ , size_t*, void*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache)
mod.PFN_vkMergePipelineCaches = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache, mod.VkPipelineCache)
mod.PFN_vkCreateComputePipelines = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache, mod.VkComputePipelineCreateInfo, mod.VkAllocationCallbacks, mod.VkPipeline)
mod.PFN_vkDestroyPipeline = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkPipeline, mod.VkAllocationCallbacks)
mod.PFN_vkCreatePipelineLayout = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineLayoutCreateInfo, mod.VkAllocationCallbacks, mod.VkPipelineLayout)
mod.PFN_vkDestroyPipelineLayout = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkPipelineLayout, mod.VkAllocationCallbacks)
mod.PFN_vkCreateSampler = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkSamplerCreateInfo, mod.VkAllocationCallbacks, mod.VkSampler)
mod.PFN_vkDestroySampler = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkSampler, mod.VkAllocationCallbacks)
mod.PFN_vkCreateDescriptorSetLayout = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDescriptorSetLayoutCreateInfo, mod.VkAllocationCallbacks, mod.VkDescriptorSetLayout)
mod.PFN_vkDestroyDescriptorSetLayout = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkDescriptorSetLayout, mod.VkAllocationCallbacks)
mod.PFN_vkCreateDescriptorPool = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDescriptorPoolCreateInfo, mod.VkAllocationCallbacks, mod.VkDescriptorPool)
mod.PFN_vkDestroyDescriptorPool = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkDescriptorPool, mod.VkAllocationCallbacks)
mod.PFN_vkResetDescriptorPool = ffi.typeof([[$ (*)($ , $ , $ )]], mod.VkResult, mod.VkDevice, mod.VkDescriptorPool, mod.VkDescriptorPoolResetFlags)
mod.PFN_vkAllocateDescriptorSets = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDescriptorSetAllocateInfo, mod.VkDescriptorSet)
mod.PFN_vkFreeDescriptorSets = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDescriptorPool, mod.VkDescriptorSet)
mod.PFN_vkUpdateDescriptorSets = ffi.typeof([[void (*)($ , uint32_t , const $*, uint32_t , const $*)]], mod.VkDevice, mod.VkWriteDescriptorSet, mod.VkCopyDescriptorSet)
mod.PFN_vkCmdBindPipeline = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipeline)
mod.PFN_vkCmdBindDescriptorSets = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t , const $*, uint32_t , const uint32_t*)]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout, mod.VkDescriptorSet)
mod.PFN_vkCmdClearColorImage = ffi.typeof([[void (*)($ , $ , $ , const $*, uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkClearColorValue, mod.VkImageSubresourceRange)
mod.PFN_vkCmdDispatch = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDispatchIndirect = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdSetEvent = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags)
mod.PFN_vkCmdResetEvent = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags)
mod.PFN_vkCmdWaitEvents = ffi.typeof([[void (*)($ , uint32_t , const $*, $ , $ , uint32_t , const $*, uint32_t , const $*, uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags, mod.VkPipelineStageFlags, mod.VkMemoryBarrier, mod.VkBufferMemoryBarrier, mod.VkImageMemoryBarrier)
mod.PFN_vkCmdPushConstants = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t , const void*)]], mod.VkCommandBuffer, mod.VkPipelineLayout, mod.VkShaderStageFlags)
mod.PFN_vkCreateGraphicsPipelines = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache, mod.VkGraphicsPipelineCreateInfo, mod.VkAllocationCallbacks, mod.VkPipeline)
mod.PFN_vkCreateFramebuffer = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkFramebufferCreateInfo, mod.VkAllocationCallbacks, mod.VkFramebuffer)
mod.PFN_vkDestroyFramebuffer = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkFramebuffer, mod.VkAllocationCallbacks)
mod.PFN_vkCreateRenderPass = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkRenderPassCreateInfo, mod.VkAllocationCallbacks, mod.VkRenderPass)
mod.PFN_vkDestroyRenderPass = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkRenderPass, mod.VkAllocationCallbacks)
mod.PFN_vkGetRenderAreaGranularity = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkRenderPass, mod.VkExtent2D)
mod.PFN_vkCmdSetViewport = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkViewport)
mod.PFN_vkCmdSetScissor = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkRect2D)
mod.PFN_vkCmdSetLineWidth = ffi.typeof([[void (*)($ , float )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetDepthBias = ffi.typeof([[void (*)($ , float , float , float )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetBlendConstants = ffi.typeof([[void (*)($ , const float[4])]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetDepthBounds = ffi.typeof([[void (*)($ , float , float )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetStencilCompareMask = ffi.typeof([[void (*)($ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
mod.PFN_vkCmdSetStencilWriteMask = ffi.typeof([[void (*)($ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
mod.PFN_vkCmdSetStencilReference = ffi.typeof([[void (*)($ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
mod.PFN_vkCmdBindIndexBuffer = ffi.typeof([[void (*)($ , $ , $ , $ )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkIndexType)
mod.PFN_vkCmdBindVertexBuffers = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*, const $*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdDraw = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawIndexed = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t , int32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawIndirect = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdDrawIndexedIndirect = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdBlitImage = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , const $*, $ )]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageBlit, mod.VkFilter)
mod.PFN_vkCmdClearDepthStencilImage = ffi.typeof([[void (*)($ , $ , $ , const $*, uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkClearDepthStencilValue, mod.VkImageSubresourceRange)
mod.PFN_vkCmdClearAttachments = ffi.typeof([[void (*)($ , uint32_t , const $*, uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkClearAttachment, mod.VkClearRect)
mod.PFN_vkCmdResolveImage = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageResolve)
mod.PFN_vkCmdBeginRenderPass = ffi.typeof([[void (*)($ , const $*, $ )]], mod.VkCommandBuffer, mod.VkRenderPassBeginInfo, mod.VkSubpassContents)
mod.PFN_vkCmdNextSubpass = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkSubpassContents)
mod.PFN_vkCmdEndRenderPass = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
ffi.cdef([[$  vkCreateInstance(const $*, const $*, $*);]], mod.VkResult, mod.VkInstanceCreateInfo, mod.VkAllocationCallbacks, mod.VkInstance)
ffi.cdef([[void  vkDestroyInstance($ , const $*);]], mod.VkInstance, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkEnumeratePhysicalDevices($ , uint32_t*, $*);]], mod.VkResult, mod.VkInstance, mod.VkPhysicalDevice)
ffi.cdef([[void  vkGetPhysicalDeviceFeatures($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures)
ffi.cdef([[void  vkGetPhysicalDeviceFormatProperties($ , $ , $*);]], mod.VkPhysicalDevice, mod.VkFormat, mod.VkFormatProperties)
ffi.cdef([[$  vkGetPhysicalDeviceImageFormatProperties($ , $ , $ , $ , $ , $ , $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkFormat, mod.VkImageType, mod.VkImageTiling, mod.VkImageUsageFlags, mod.VkImageCreateFlags, mod.VkImageFormatProperties)
ffi.cdef([[void  vkGetPhysicalDeviceProperties($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties)
ffi.cdef([[void  vkGetPhysicalDeviceQueueFamilyProperties($ , uint32_t*, $*);]], mod.VkPhysicalDevice, mod.VkQueueFamilyProperties)
ffi.cdef([[void  vkGetPhysicalDeviceMemoryProperties($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties)
ffi.cdef([[$  vkGetInstanceProcAddr($ , const char*);]], mod.PFN_vkVoidFunction, mod.VkInstance)
ffi.cdef([[$  vkGetDeviceProcAddr($ , const char*);]], mod.PFN_vkVoidFunction, mod.VkDevice)
ffi.cdef([[$  vkCreateDevice($ , const $*, const $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDeviceCreateInfo, mod.VkAllocationCallbacks, mod.VkDevice)
ffi.cdef([[void  vkDestroyDevice($ , const $*);]], mod.VkDevice, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkEnumerateInstanceExtensionProperties(const char*, uint32_t*, $*);]], mod.VkResult, mod.VkExtensionProperties)
ffi.cdef([[$  vkEnumerateDeviceExtensionProperties($ , const char*, uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkExtensionProperties)
ffi.cdef([[$  vkEnumerateInstanceLayerProperties(uint32_t*, $*);]], mod.VkResult, mod.VkLayerProperties)
ffi.cdef([[$  vkEnumerateDeviceLayerProperties($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkLayerProperties)
ffi.cdef([[void  vkGetDeviceQueue($ , uint32_t , uint32_t , $*);]], mod.VkDevice, mod.VkQueue)
ffi.cdef([[$  vkQueueSubmit($ , uint32_t , const $*, $ );]], mod.VkResult, mod.VkQueue, mod.VkSubmitInfo, mod.VkFence)
ffi.cdef([[$  vkQueueWaitIdle($ );]], mod.VkResult, mod.VkQueue)
ffi.cdef([[$  vkDeviceWaitIdle($ );]], mod.VkResult, mod.VkDevice)
ffi.cdef([[$  vkAllocateMemory($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkMemoryAllocateInfo, mod.VkAllocationCallbacks, mod.VkDeviceMemory)
ffi.cdef([[void  vkFreeMemory($ , $ , const $*);]], mod.VkDevice, mod.VkDeviceMemory, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkMapMemory($ , $ , $ , $ , $ , void**);]], mod.VkResult, mod.VkDevice, mod.VkDeviceMemory, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkMemoryMapFlags)
ffi.cdef([[void  vkUnmapMemory($ , $ );]], mod.VkDevice, mod.VkDeviceMemory)
ffi.cdef([[$  vkFlushMappedMemoryRanges($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkMappedMemoryRange)
ffi.cdef([[$  vkInvalidateMappedMemoryRanges($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkMappedMemoryRange)
ffi.cdef([[void  vkGetDeviceMemoryCommitment($ , $ , $*);]], mod.VkDevice, mod.VkDeviceMemory, mod.VkDeviceSize)
ffi.cdef([[$  vkBindBufferMemory($ , $ , $ , $ );]], mod.VkResult, mod.VkDevice, mod.VkBuffer, mod.VkDeviceMemory, mod.VkDeviceSize)
ffi.cdef([[$  vkBindImageMemory($ , $ , $ , $ );]], mod.VkResult, mod.VkDevice, mod.VkImage, mod.VkDeviceMemory, mod.VkDeviceSize)
ffi.cdef([[void  vkGetBufferMemoryRequirements($ , $ , $*);]], mod.VkDevice, mod.VkBuffer, mod.VkMemoryRequirements)
ffi.cdef([[void  vkGetImageMemoryRequirements($ , $ , $*);]], mod.VkDevice, mod.VkImage, mod.VkMemoryRequirements)
ffi.cdef([[void  vkGetImageSparseMemoryRequirements($ , $ , uint32_t*, $*);]], mod.VkDevice, mod.VkImage, mod.VkSparseImageMemoryRequirements)
ffi.cdef([[void  vkGetPhysicalDeviceSparseImageFormatProperties($ , $ , $ , $ , $ , $ , uint32_t*, $*);]], mod.VkPhysicalDevice, mod.VkFormat, mod.VkImageType, mod.VkSampleCountFlagBits, mod.VkImageUsageFlags, mod.VkImageTiling, mod.VkSparseImageFormatProperties)
ffi.cdef([[$  vkQueueBindSparse($ , uint32_t , const $*, $ );]], mod.VkResult, mod.VkQueue, mod.VkBindSparseInfo, mod.VkFence)
ffi.cdef([[$  vkCreateFence($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkFenceCreateInfo, mod.VkAllocationCallbacks, mod.VkFence)
ffi.cdef([[void  vkDestroyFence($ , $ , const $*);]], mod.VkDevice, mod.VkFence, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkResetFences($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkFence)
ffi.cdef([[$  vkGetFenceStatus($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkFence)
ffi.cdef([[$  vkWaitForFences($ , uint32_t , const $*, $ , uint64_t );]], mod.VkResult, mod.VkDevice, mod.VkFence, mod.VkBool32)
ffi.cdef([[$  vkCreateSemaphore($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreCreateInfo, mod.VkAllocationCallbacks, mod.VkSemaphore)
ffi.cdef([[void  vkDestroySemaphore($ , $ , const $*);]], mod.VkDevice, mod.VkSemaphore, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateQueryPool($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkQueryPoolCreateInfo, mod.VkAllocationCallbacks, mod.VkQueryPool)
ffi.cdef([[void  vkDestroyQueryPool($ , $ , const $*);]], mod.VkDevice, mod.VkQueryPool, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkGetQueryPoolResults($ , $ , uint32_t , uint32_t , size_t , void*, $ , $ );]], mod.VkResult, mod.VkDevice, mod.VkQueryPool, mod.VkDeviceSize, mod.VkQueryResultFlags)
ffi.cdef([[$  vkCreateBuffer($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkBufferCreateInfo, mod.VkAllocationCallbacks, mod.VkBuffer)
ffi.cdef([[void  vkDestroyBuffer($ , $ , const $*);]], mod.VkDevice, mod.VkBuffer, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateImage($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkImageCreateInfo, mod.VkAllocationCallbacks, mod.VkImage)
ffi.cdef([[void  vkDestroyImage($ , $ , const $*);]], mod.VkDevice, mod.VkImage, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkGetImageSubresourceLayout($ , $ , const $*, $*);]], mod.VkDevice, mod.VkImage, mod.VkImageSubresource, mod.VkSubresourceLayout)
ffi.cdef([[$  vkCreateImageView($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkImageViewCreateInfo, mod.VkAllocationCallbacks, mod.VkImageView)
ffi.cdef([[void  vkDestroyImageView($ , $ , const $*);]], mod.VkDevice, mod.VkImageView, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateCommandPool($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkCommandPoolCreateInfo, mod.VkAllocationCallbacks, mod.VkCommandPool)
ffi.cdef([[void  vkDestroyCommandPool($ , $ , const $*);]], mod.VkDevice, mod.VkCommandPool, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkResetCommandPool($ , $ , $ );]], mod.VkResult, mod.VkDevice, mod.VkCommandPool, mod.VkCommandPoolResetFlags)
ffi.cdef([[$  vkAllocateCommandBuffers($ , const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkCommandBufferAllocateInfo, mod.VkCommandBuffer)
ffi.cdef([[void  vkFreeCommandBuffers($ , $ , uint32_t , const $*);]], mod.VkDevice, mod.VkCommandPool, mod.VkCommandBuffer)
ffi.cdef([[$  vkBeginCommandBuffer($ , const $*);]], mod.VkResult, mod.VkCommandBuffer, mod.VkCommandBufferBeginInfo)
ffi.cdef([[$  vkEndCommandBuffer($ );]], mod.VkResult, mod.VkCommandBuffer)
ffi.cdef([[$  vkResetCommandBuffer($ , $ );]], mod.VkResult, mod.VkCommandBuffer, mod.VkCommandBufferResetFlags)
ffi.cdef([[void  vkCmdCopyBuffer($ , $ , $ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkBuffer, mod.VkBufferCopy)
ffi.cdef([[void  vkCmdCopyImage($ , $ , $ , $ , $ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageCopy)
ffi.cdef([[void  vkCmdCopyBufferToImage($ , $ , $ , $ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkImage, mod.VkImageLayout, mod.VkBufferImageCopy)
ffi.cdef([[void  vkCmdCopyImageToBuffer($ , $ , $ , $ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkBuffer, mod.VkBufferImageCopy)
ffi.cdef([[void  vkCmdUpdateBuffer($ , $ , $ , $ , const void*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdFillBuffer($ , $ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdPipelineBarrier($ , $ , $ , $ , uint32_t , const $*, uint32_t , const $*, uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkPipelineStageFlags, mod.VkPipelineStageFlags, mod.VkDependencyFlags, mod.VkMemoryBarrier, mod.VkBufferMemoryBarrier, mod.VkImageMemoryBarrier)
ffi.cdef([[void  vkCmdBeginQuery($ , $ , uint32_t , $ );]], mod.VkCommandBuffer, mod.VkQueryPool, mod.VkQueryControlFlags)
ffi.cdef([[void  vkCmdEndQuery($ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkQueryPool)
ffi.cdef([[void  vkCmdResetQueryPool($ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkQueryPool)
ffi.cdef([[void  vkCmdWriteTimestamp($ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkPipelineStageFlagBits, mod.VkQueryPool)
ffi.cdef([[void  vkCmdCopyQueryPoolResults($ , $ , uint32_t , uint32_t , $ , $ , $ , $ );]], mod.VkCommandBuffer, mod.VkQueryPool, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkQueryResultFlags)
ffi.cdef([[void  vkCmdExecuteCommands($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkCommandBuffer)
ffi.cdef([[$  vkCreateEvent($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkEventCreateInfo, mod.VkAllocationCallbacks, mod.VkEvent)
ffi.cdef([[void  vkDestroyEvent($ , $ , const $*);]], mod.VkDevice, mod.VkEvent, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkGetEventStatus($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkEvent)
ffi.cdef([[$  vkSetEvent($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkEvent)
ffi.cdef([[$  vkResetEvent($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkEvent)
ffi.cdef([[$  vkCreateBufferView($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkBufferViewCreateInfo, mod.VkAllocationCallbacks, mod.VkBufferView)
ffi.cdef([[void  vkDestroyBufferView($ , $ , const $*);]], mod.VkDevice, mod.VkBufferView, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateShaderModule($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkShaderModuleCreateInfo, mod.VkAllocationCallbacks, mod.VkShaderModule)
ffi.cdef([[void  vkDestroyShaderModule($ , $ , const $*);]], mod.VkDevice, mod.VkShaderModule, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreatePipelineCache($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineCacheCreateInfo, mod.VkAllocationCallbacks, mod.VkPipelineCache)
ffi.cdef([[void  vkDestroyPipelineCache($ , $ , const $*);]], mod.VkDevice, mod.VkPipelineCache, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkGetPipelineCacheData($ , $ , size_t*, void*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache)
ffi.cdef([[$  vkMergePipelineCaches($ , $ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache, mod.VkPipelineCache)
ffi.cdef([[$  vkCreateComputePipelines($ , $ , uint32_t , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache, mod.VkComputePipelineCreateInfo, mod.VkAllocationCallbacks, mod.VkPipeline)
ffi.cdef([[void  vkDestroyPipeline($ , $ , const $*);]], mod.VkDevice, mod.VkPipeline, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreatePipelineLayout($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineLayoutCreateInfo, mod.VkAllocationCallbacks, mod.VkPipelineLayout)
ffi.cdef([[void  vkDestroyPipelineLayout($ , $ , const $*);]], mod.VkDevice, mod.VkPipelineLayout, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateSampler($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkSamplerCreateInfo, mod.VkAllocationCallbacks, mod.VkSampler)
ffi.cdef([[void  vkDestroySampler($ , $ , const $*);]], mod.VkDevice, mod.VkSampler, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateDescriptorSetLayout($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDescriptorSetLayoutCreateInfo, mod.VkAllocationCallbacks, mod.VkDescriptorSetLayout)
ffi.cdef([[void  vkDestroyDescriptorSetLayout($ , $ , const $*);]], mod.VkDevice, mod.VkDescriptorSetLayout, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateDescriptorPool($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDescriptorPoolCreateInfo, mod.VkAllocationCallbacks, mod.VkDescriptorPool)
ffi.cdef([[void  vkDestroyDescriptorPool($ , $ , const $*);]], mod.VkDevice, mod.VkDescriptorPool, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkResetDescriptorPool($ , $ , $ );]], mod.VkResult, mod.VkDevice, mod.VkDescriptorPool, mod.VkDescriptorPoolResetFlags)
ffi.cdef([[$  vkAllocateDescriptorSets($ , const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDescriptorSetAllocateInfo, mod.VkDescriptorSet)
ffi.cdef([[$  vkFreeDescriptorSets($ , $ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDescriptorPool, mod.VkDescriptorSet)
ffi.cdef([[void  vkUpdateDescriptorSets($ , uint32_t , const $*, uint32_t , const $*);]], mod.VkDevice, mod.VkWriteDescriptorSet, mod.VkCopyDescriptorSet)
ffi.cdef([[void  vkCmdBindPipeline($ , $ , $ );]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipeline)
ffi.cdef([[void  vkCmdBindDescriptorSets($ , $ , $ , uint32_t , uint32_t , const $*, uint32_t , const uint32_t*);]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout, mod.VkDescriptorSet)
ffi.cdef([[void  vkCmdClearColorImage($ , $ , $ , const $*, uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkClearColorValue, mod.VkImageSubresourceRange)
ffi.cdef([[void  vkCmdDispatch($ , uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdDispatchIndirect($ , $ , $ );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdSetEvent($ , $ , $ );]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags)
ffi.cdef([[void  vkCmdResetEvent($ , $ , $ );]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags)
ffi.cdef([[void  vkCmdWaitEvents($ , uint32_t , const $*, $ , $ , uint32_t , const $*, uint32_t , const $*, uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags, mod.VkPipelineStageFlags, mod.VkMemoryBarrier, mod.VkBufferMemoryBarrier, mod.VkImageMemoryBarrier)
ffi.cdef([[void  vkCmdPushConstants($ , $ , $ , uint32_t , uint32_t , const void*);]], mod.VkCommandBuffer, mod.VkPipelineLayout, mod.VkShaderStageFlags)
ffi.cdef([[$  vkCreateGraphicsPipelines($ , $ , uint32_t , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache, mod.VkGraphicsPipelineCreateInfo, mod.VkAllocationCallbacks, mod.VkPipeline)
ffi.cdef([[$  vkCreateFramebuffer($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkFramebufferCreateInfo, mod.VkAllocationCallbacks, mod.VkFramebuffer)
ffi.cdef([[void  vkDestroyFramebuffer($ , $ , const $*);]], mod.VkDevice, mod.VkFramebuffer, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateRenderPass($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkRenderPassCreateInfo, mod.VkAllocationCallbacks, mod.VkRenderPass)
ffi.cdef([[void  vkDestroyRenderPass($ , $ , const $*);]], mod.VkDevice, mod.VkRenderPass, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkGetRenderAreaGranularity($ , $ , $*);]], mod.VkDevice, mod.VkRenderPass, mod.VkExtent2D)
ffi.cdef([[void  vkCmdSetViewport($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkViewport)
ffi.cdef([[void  vkCmdSetScissor($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkRect2D)
ffi.cdef([[void  vkCmdSetLineWidth($ , float );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetDepthBias($ , float , float , float );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetBlendConstants($ , const float[4]);]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetDepthBounds($ , float , float );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetStencilCompareMask($ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
ffi.cdef([[void  vkCmdSetStencilWriteMask($ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
ffi.cdef([[void  vkCmdSetStencilReference($ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkStencilFaceFlags)
ffi.cdef([[void  vkCmdBindIndexBuffer($ , $ , $ , $ );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkIndexType)
ffi.cdef([[void  vkCmdBindVertexBuffers($ , uint32_t , uint32_t , const $*, const $*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDraw($ , uint32_t , uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdDrawIndexed($ , uint32_t , uint32_t , uint32_t , int32_t , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdDrawIndirect($ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawIndexedIndirect($ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdBlitImage($ , $ , $ , $ , $ , uint32_t , const $*, $ );]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageBlit, mod.VkFilter)
ffi.cdef([[void  vkCmdClearDepthStencilImage($ , $ , $ , const $*, uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkClearDepthStencilValue, mod.VkImageSubresourceRange)
ffi.cdef([[void  vkCmdClearAttachments($ , uint32_t , const $*, uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkClearAttachment, mod.VkClearRect)
ffi.cdef([[void  vkCmdResolveImage($ , $ , $ , $ , $ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageResolve)
ffi.cdef([[void  vkCmdBeginRenderPass($ , const $*, $ );]], mod.VkCommandBuffer, mod.VkRenderPassBeginInfo, mod.VkSubpassContents)
ffi.cdef([[void  vkCmdNextSubpass($ , $ );]], mod.VkCommandBuffer, mod.VkSubpassContents)
ffi.cdef([[void  vkCmdEndRenderPass($ );]], mod.VkCommandBuffer)
mod.VkDescriptorUpdateTemplateType = ffi.typeof([[enum {
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS = 1,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerYcbcrModelConversion = ffi.typeof([[enum {
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerYcbcrRange = ffi.typeof([[enum {
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
	VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkChromaLocation = ffi.typeof([[enum {
	VK_CHROMA_LOCATION_COSITED_EVEN = 0,
	VK_CHROMA_LOCATION_MIDPOINT = 1,
	VK_CHROMA_LOCATION_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN,
	VK_CHROMA_LOCATION_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT,
	VK_CHROMA_LOCATION_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPointClippingBehavior = ffi.typeof([[enum {
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
	VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkTessellationDomainOrigin = ffi.typeof([[enum {
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
	VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPeerMemoryFeatureFlagBits = ffi.typeof([[enum {
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001,
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002,
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004,
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008,
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
	VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPeerMemoryFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMemoryAllocateFlagBits = ffi.typeof([[enum {
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x00000002,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000004,
	VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT = 0x00000008,
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
	VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryAllocateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkCommandPoolTrimFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalMemoryHandleTypeFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x00000800,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x00001000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = 0x00004000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT = 0x00010000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT = 0x00020000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT = 0x00040000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalMemoryHandleTypeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalMemoryFeatureFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004,
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalMemoryFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalFenceHandleTypeFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalFenceHandleTypeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalFenceFeatureFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
	VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalFenceFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFenceImportFlagBits = ffi.typeof([[enum {
	VK_FENCE_IMPORT_TEMPORARY_BIT = 0x00000001,
	VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT,
	VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkFenceImportFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSemaphoreImportFlagBits = ffi.typeof([[enum {
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001,
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
	VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSemaphoreImportFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalSemaphoreHandleTypeFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x00000080,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalSemaphoreHandleTypeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalSemaphoreFeatureFlagBits = ffi.typeof([[enum {
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001,
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
	VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkExternalSemaphoreFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSubgroupFeatureFlagBits = ffi.typeof([[enum {
	VK_SUBGROUP_FEATURE_BASIC_BIT = 0x00000001,
	VK_SUBGROUP_FEATURE_VOTE_BIT = 0x00000002,
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004,
	VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008,
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010,
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
	VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
	VK_SUBGROUP_FEATURE_ROTATE_BIT = 0x00000200,
	VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT = 0x00000400,
	VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
	VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR = VK_SUBGROUP_FEATURE_ROTATE_BIT,
	VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR = VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT,
	VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubgroupFeatureFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorUpdateTemplateCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBindBufferMemoryInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ buffer;
	$ memory;
	$ memoryOffset;
}]], mod.VkStructureType, mod.VkBuffer, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.VkBindImageMemoryInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ memory;
	$ memoryOffset;
}]], mod.VkStructureType, mod.VkImage, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.VkMemoryDedicatedRequirements = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ prefersDedicatedAllocation;
	$ requiresDedicatedAllocation;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkMemoryDedicatedAllocateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ buffer;
}]], mod.VkStructureType, mod.VkImage, mod.VkBuffer)
mod.VkMemoryAllocateFlagsInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t deviceMask;
}]], mod.VkStructureType, mod.VkMemoryAllocateFlags)
mod.VkDeviceGroupCommandBufferBeginInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceMask;
}]], mod.VkStructureType)
mod.VkDeviceGroupSubmitInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreCount;
	const uint32_t* pWaitSemaphoreDeviceIndices;
	uint32_t commandBufferCount;
	const uint32_t* pCommandBufferDeviceMasks;
	uint32_t signalSemaphoreCount;
	const uint32_t* pSignalSemaphoreDeviceIndices;
}]], mod.VkStructureType)
mod.VkDeviceGroupBindSparseInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t resourceDeviceIndex;
	uint32_t memoryDeviceIndex;
}]], mod.VkStructureType)
mod.VkBindBufferMemoryDeviceGroupInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceIndexCount;
	const uint32_t* pDeviceIndices;
}]], mod.VkStructureType)
mod.VkBindImageMemoryDeviceGroupInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceIndexCount;
	const uint32_t* pDeviceIndices;
	uint32_t splitInstanceBindRegionCount;
	const $* pSplitInstanceBindRegions;
}]], mod.VkStructureType, mod.VkRect2D)
mod.VkPhysicalDeviceGroupProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t physicalDeviceCount;
	$ physicalDevices[32U];
	$ subsetAllocation;
}]], mod.VkStructureType, mod.VkPhysicalDevice, mod.VkBool32)
mod.VkDeviceGroupDeviceCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t physicalDeviceCount;
	const $* pPhysicalDevices;
}]], mod.VkStructureType, mod.VkPhysicalDevice)
mod.VkBufferMemoryRequirementsInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ buffer;
}]], mod.VkStructureType, mod.VkBuffer)
mod.VkImageMemoryRequirementsInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
}]], mod.VkStructureType, mod.VkImage)
mod.VkImageSparseMemoryRequirementsInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
}]], mod.VkStructureType, mod.VkImage)
mod.VkMemoryRequirements2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ memoryRequirements;
}]], mod.VkStructureType, mod.VkMemoryRequirements)
mod.VkSparseImageMemoryRequirements2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ memoryRequirements;
}]], mod.VkStructureType, mod.VkSparseImageMemoryRequirements)
mod.VkPhysicalDeviceFeatures2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ features;
}]], mod.VkStructureType, mod.VkPhysicalDeviceFeatures)
mod.VkPhysicalDeviceProperties2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ properties;
}]], mod.VkStructureType, mod.VkPhysicalDeviceProperties)
mod.VkFormatProperties2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ formatProperties;
}]], mod.VkStructureType, mod.VkFormatProperties)
mod.VkImageFormatProperties2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageFormatProperties;
}]], mod.VkStructureType, mod.VkImageFormatProperties)
mod.VkPhysicalDeviceImageFormatInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ format;
	$ type;
	$ tiling;
	$ usage;
	$ flags;
}]], mod.VkStructureType, mod.VkFormat, mod.VkImageType, mod.VkImageTiling, mod.VkImageUsageFlags, mod.VkImageCreateFlags)
mod.VkQueueFamilyProperties2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ queueFamilyProperties;
}]], mod.VkStructureType, mod.VkQueueFamilyProperties)
mod.VkPhysicalDeviceMemoryProperties2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ memoryProperties;
}]], mod.VkStructureType, mod.VkPhysicalDeviceMemoryProperties)
mod.VkSparseImageFormatProperties2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ properties;
}]], mod.VkStructureType, mod.VkSparseImageFormatProperties)
mod.VkPhysicalDeviceSparseImageFormatInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ format;
	$ type;
	$ samples;
	$ usage;
	$ tiling;
}]], mod.VkStructureType, mod.VkFormat, mod.VkImageType, mod.VkSampleCountFlagBits, mod.VkImageUsageFlags, mod.VkImageTiling)
mod.VkImageViewUsageCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ usage;
}]], mod.VkStructureType, mod.VkImageUsageFlags)
mod.VkPhysicalDeviceProtectedMemoryFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ protectedMemory;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceProtectedMemoryProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ protectedNoFault;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDeviceQueueInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t queueFamilyIndex;
	uint32_t queueIndex;
}]], mod.VkStructureType, mod.VkDeviceQueueCreateFlags)
mod.VkProtectedSubmitInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ protectedSubmit;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkBindImagePlaneMemoryInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ planeAspect;
}]], mod.VkStructureType, mod.VkImageAspectFlagBits)
mod.VkImagePlaneMemoryRequirementsInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ planeAspect;
}]], mod.VkStructureType, mod.VkImageAspectFlagBits)
mod.VkExternalMemoryProperties = ffi.typeof([[struct {
	$ externalMemoryFeatures;
	$ exportFromImportedHandleTypes;
	$ compatibleHandleTypes;
}]], mod.VkExternalMemoryFeatureFlags, mod.VkExternalMemoryHandleTypeFlags, mod.VkExternalMemoryHandleTypeFlags)
mod.VkPhysicalDeviceExternalImageFormatInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleType;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkExternalImageFormatProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ externalMemoryProperties;
}]], mod.VkStructureType, mod.VkExternalMemoryProperties)
mod.VkPhysicalDeviceExternalBufferInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ usage;
	$ handleType;
}]], mod.VkStructureType, mod.VkBufferCreateFlags, mod.VkBufferUsageFlags, mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkExternalBufferProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ externalMemoryProperties;
}]], mod.VkStructureType, mod.VkExternalMemoryProperties)
mod.VkPhysicalDeviceIDProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint8_t deviceUUID[16U];
	uint8_t driverUUID[16U];
	uint8_t deviceLUID[8U];
	uint32_t deviceNodeMask;
	$ deviceLUIDValid;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkExternalMemoryImageCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlags)
mod.VkExternalMemoryBufferCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlags)
mod.VkExportMemoryAllocateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlags)
mod.VkPhysicalDeviceExternalFenceInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleType;
}]], mod.VkStructureType, mod.VkExternalFenceHandleTypeFlagBits)
mod.VkExternalFenceProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ exportFromImportedHandleTypes;
	$ compatibleHandleTypes;
	$ externalFenceFeatures;
}]], mod.VkStructureType, mod.VkExternalFenceHandleTypeFlags, mod.VkExternalFenceHandleTypeFlags, mod.VkExternalFenceFeatureFlags)
mod.VkExportFenceCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]], mod.VkStructureType, mod.VkExternalFenceHandleTypeFlags)
mod.VkExportSemaphoreCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]], mod.VkStructureType, mod.VkExternalSemaphoreHandleTypeFlags)
mod.VkPhysicalDeviceExternalSemaphoreInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleType;
}]], mod.VkStructureType, mod.VkExternalSemaphoreHandleTypeFlagBits)
mod.VkExternalSemaphoreProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ exportFromImportedHandleTypes;
	$ compatibleHandleTypes;
	$ externalSemaphoreFeatures;
}]], mod.VkStructureType, mod.VkExternalSemaphoreHandleTypeFlags, mod.VkExternalSemaphoreHandleTypeFlags, mod.VkExternalSemaphoreFeatureFlags)
mod.VkPhysicalDeviceSubgroupProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t subgroupSize;
	$ supportedStages;
	$ supportedOperations;
	$ quadOperationsInAllStages;
}]], mod.VkStructureType, mod.VkShaderStageFlags, mod.VkSubgroupFeatureFlags, mod.VkBool32)
mod.VkPhysicalDevice16BitStorageFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ storageBuffer16BitAccess;
	$ uniformAndStorageBuffer16BitAccess;
	$ storagePushConstant16;
	$ storageInputOutput16;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceVariablePointersFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ variablePointersStorageBuffer;
	$ variablePointers;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceVariablePointerFeatures = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVariablePointersFeatures)
mod.VkDescriptorUpdateTemplateEntry = ffi.typeof([[struct {
	uint32_t dstBinding;
	uint32_t dstArrayElement;
	uint32_t descriptorCount;
	$ descriptorType;
	size_t offset;
	size_t stride;
}]], mod.VkDescriptorType)
mod.VkDescriptorUpdateTemplateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t descriptorUpdateEntryCount;
	const $* pDescriptorUpdateEntries;
	$ templateType;
	$ descriptorSetLayout;
	$ pipelineBindPoint;
	$ pipelineLayout;
	uint32_t set;
}]], mod.VkStructureType, mod.VkDescriptorUpdateTemplateCreateFlags, mod.VkDescriptorUpdateTemplateEntry, mod.VkDescriptorUpdateTemplateType, mod.VkDescriptorSetLayout, mod.VkPipelineBindPoint, mod.VkPipelineLayout)
mod.VkPhysicalDeviceMaintenance3Properties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxPerSetDescriptors;
	$ maxMemoryAllocationSize;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkDescriptorSetLayoutSupport = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ supported;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSamplerYcbcrConversionCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ format;
	$ ycbcrModel;
	$ ycbcrRange;
	$ components;
	$ xChromaOffset;
	$ yChromaOffset;
	$ chromaFilter;
	$ forceExplicitReconstruction;
}]], mod.VkStructureType, mod.VkFormat, mod.VkSamplerYcbcrModelConversion, mod.VkSamplerYcbcrRange, mod.VkComponentMapping, mod.VkChromaLocation, mod.VkChromaLocation, mod.VkFilter, mod.VkBool32)
mod.VkSamplerYcbcrConversionInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ conversion;
}]], mod.VkStructureType, mod.VkSamplerYcbcrConversion)
mod.VkPhysicalDeviceSamplerYcbcrConversionFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ samplerYcbcrConversion;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSamplerYcbcrConversionImageFormatProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t combinedImageSamplerDescriptorCount;
}]], mod.VkStructureType)
mod.VkDeviceGroupRenderPassBeginInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceMask;
	uint32_t deviceRenderAreaCount;
	const $* pDeviceRenderAreas;
}]], mod.VkStructureType, mod.VkRect2D)
mod.VkPhysicalDevicePointClippingProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pointClippingBehavior;
}]], mod.VkStructureType, mod.VkPointClippingBehavior)
mod.VkInputAttachmentAspectReference = ffi.typeof([[struct {
	uint32_t subpass;
	uint32_t inputAttachmentIndex;
	$ aspectMask;
}]], mod.VkImageAspectFlags)
mod.VkRenderPassInputAttachmentAspectCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t aspectReferenceCount;
	const $* pAspectReferences;
}]], mod.VkStructureType, mod.VkInputAttachmentAspectReference)
mod.VkPipelineTessellationDomainOriginStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ domainOrigin;
}]], mod.VkStructureType, mod.VkTessellationDomainOrigin)
mod.VkRenderPassMultiviewCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t subpassCount;
	const uint32_t* pViewMasks;
	uint32_t dependencyCount;
	const int32_t* pViewOffsets;
	uint32_t correlationMaskCount;
	const uint32_t* pCorrelationMasks;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceMultiviewFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ multiview;
	$ multiviewGeometryShader;
	$ multiviewTessellationShader;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceMultiviewProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxMultiviewViewCount;
	uint32_t maxMultiviewInstanceIndex;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceShaderDrawParametersFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderDrawParameters;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderDrawParameterFeatures = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderDrawParametersFeatures)
mod.PFN_vkEnumerateInstanceVersion = ffi.typeof([[$ (*)(uint32_t*)]], mod.VkResult)
mod.PFN_vkBindBufferMemory2 = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkBindBufferMemoryInfo)
mod.PFN_vkBindImageMemory2 = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkBindImageMemoryInfo)
mod.PFN_vkGetDeviceGroupPeerMemoryFeatures = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t , $*)]], mod.VkDevice, mod.VkPeerMemoryFeatureFlags)
mod.PFN_vkCmdSetDeviceMask = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkEnumeratePhysicalDeviceGroups = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkInstance, mod.VkPhysicalDeviceGroupProperties)
mod.PFN_vkGetImageMemoryRequirements2 = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkImageMemoryRequirementsInfo2, mod.VkMemoryRequirements2)
mod.PFN_vkGetBufferMemoryRequirements2 = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkBufferMemoryRequirementsInfo2, mod.VkMemoryRequirements2)
mod.PFN_vkGetImageSparseMemoryRequirements2 = ffi.typeof([[void (*)($ , const $*, uint32_t*, $*)]], mod.VkDevice, mod.VkImageSparseMemoryRequirementsInfo2, mod.VkSparseImageMemoryRequirements2)
mod.PFN_vkGetPhysicalDeviceFeatures2 = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures2)
mod.PFN_vkGetPhysicalDeviceProperties2 = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties2)
mod.PFN_vkGetPhysicalDeviceFormatProperties2 = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkPhysicalDevice, mod.VkFormat, mod.VkFormatProperties2)
mod.PFN_vkGetPhysicalDeviceImageFormatProperties2 = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceImageFormatInfo2, mod.VkImageFormatProperties2)
mod.PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = ffi.typeof([[void (*)($ , uint32_t*, $*)]], mod.VkPhysicalDevice, mod.VkQueueFamilyProperties2)
mod.PFN_vkGetPhysicalDeviceMemoryProperties2 = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties2)
mod.PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = ffi.typeof([[void (*)($ , const $*, uint32_t*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceSparseImageFormatInfo2, mod.VkSparseImageFormatProperties2)
mod.PFN_vkTrimCommandPool = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkDevice, mod.VkCommandPool, mod.VkCommandPoolTrimFlags)
mod.PFN_vkGetDeviceQueue2 = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceQueueInfo2, mod.VkQueue)
mod.PFN_vkGetPhysicalDeviceExternalBufferProperties = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalBufferInfo, mod.VkExternalBufferProperties)
mod.PFN_vkGetPhysicalDeviceExternalFenceProperties = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalFenceInfo, mod.VkExternalFenceProperties)
mod.PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalSemaphoreInfo, mod.VkExternalSemaphoreProperties)
mod.PFN_vkCmdDispatchBase = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCreateDescriptorUpdateTemplate = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDescriptorUpdateTemplateCreateInfo, mod.VkAllocationCallbacks, mod.VkDescriptorUpdateTemplate)
mod.PFN_vkDestroyDescriptorUpdateTemplate = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkDescriptorUpdateTemplate, mod.VkAllocationCallbacks)
mod.PFN_vkUpdateDescriptorSetWithTemplate = ffi.typeof([[void (*)($ , $ , $ , const void*)]], mod.VkDevice, mod.VkDescriptorSet, mod.VkDescriptorUpdateTemplate)
mod.PFN_vkGetDescriptorSetLayoutSupport = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDescriptorSetLayoutCreateInfo, mod.VkDescriptorSetLayoutSupport)
mod.PFN_vkCreateSamplerYcbcrConversion = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkSamplerYcbcrConversionCreateInfo, mod.VkAllocationCallbacks, mod.VkSamplerYcbcrConversion)
mod.PFN_vkDestroySamplerYcbcrConversion = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkSamplerYcbcrConversion, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkEnumerateInstanceVersion(uint32_t*);]], mod.VkResult)
ffi.cdef([[$  vkBindBufferMemory2($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkBindBufferMemoryInfo)
ffi.cdef([[$  vkBindImageMemory2($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkBindImageMemoryInfo)
ffi.cdef([[void  vkGetDeviceGroupPeerMemoryFeatures($ , uint32_t , uint32_t , uint32_t , $*);]], mod.VkDevice, mod.VkPeerMemoryFeatureFlags)
ffi.cdef([[void  vkCmdSetDeviceMask($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[$  vkEnumeratePhysicalDeviceGroups($ , uint32_t*, $*);]], mod.VkResult, mod.VkInstance, mod.VkPhysicalDeviceGroupProperties)
ffi.cdef([[void  vkGetImageMemoryRequirements2($ , const $*, $*);]], mod.VkDevice, mod.VkImageMemoryRequirementsInfo2, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkGetBufferMemoryRequirements2($ , const $*, $*);]], mod.VkDevice, mod.VkBufferMemoryRequirementsInfo2, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkGetImageSparseMemoryRequirements2($ , const $*, uint32_t*, $*);]], mod.VkDevice, mod.VkImageSparseMemoryRequirementsInfo2, mod.VkSparseImageMemoryRequirements2)
ffi.cdef([[void  vkGetPhysicalDeviceFeatures2($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures2)
ffi.cdef([[void  vkGetPhysicalDeviceProperties2($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceFormatProperties2($ , $ , $*);]], mod.VkPhysicalDevice, mod.VkFormat, mod.VkFormatProperties2)
ffi.cdef([[$  vkGetPhysicalDeviceImageFormatProperties2($ , const $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceImageFormatInfo2, mod.VkImageFormatProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceQueueFamilyProperties2($ , uint32_t*, $*);]], mod.VkPhysicalDevice, mod.VkQueueFamilyProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceMemoryProperties2($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceSparseImageFormatProperties2($ , const $*, uint32_t*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceSparseImageFormatInfo2, mod.VkSparseImageFormatProperties2)
ffi.cdef([[void  vkTrimCommandPool($ , $ , $ );]], mod.VkDevice, mod.VkCommandPool, mod.VkCommandPoolTrimFlags)
ffi.cdef([[void  vkGetDeviceQueue2($ , const $*, $*);]], mod.VkDevice, mod.VkDeviceQueueInfo2, mod.VkQueue)
ffi.cdef([[void  vkGetPhysicalDeviceExternalBufferProperties($ , const $*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalBufferInfo, mod.VkExternalBufferProperties)
ffi.cdef([[void  vkGetPhysicalDeviceExternalFenceProperties($ , const $*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalFenceInfo, mod.VkExternalFenceProperties)
ffi.cdef([[void  vkGetPhysicalDeviceExternalSemaphoreProperties($ , const $*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalSemaphoreInfo, mod.VkExternalSemaphoreProperties)
ffi.cdef([[void  vkCmdDispatchBase($ , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[$  vkCreateDescriptorUpdateTemplate($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDescriptorUpdateTemplateCreateInfo, mod.VkAllocationCallbacks, mod.VkDescriptorUpdateTemplate)
ffi.cdef([[void  vkDestroyDescriptorUpdateTemplate($ , $ , const $*);]], mod.VkDevice, mod.VkDescriptorUpdateTemplate, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkUpdateDescriptorSetWithTemplate($ , $ , $ , const void*);]], mod.VkDevice, mod.VkDescriptorSet, mod.VkDescriptorUpdateTemplate)
ffi.cdef([[void  vkGetDescriptorSetLayoutSupport($ , const $*, $*);]], mod.VkDevice, mod.VkDescriptorSetLayoutCreateInfo, mod.VkDescriptorSetLayoutSupport)
ffi.cdef([[$  vkCreateSamplerYcbcrConversion($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkSamplerYcbcrConversionCreateInfo, mod.VkAllocationCallbacks, mod.VkSamplerYcbcrConversion)
ffi.cdef([[void  vkDestroySamplerYcbcrConversion($ , $ , const $*);]], mod.VkDevice, mod.VkSamplerYcbcrConversion, mod.VkAllocationCallbacks)
mod.VkDriverId = ffi.typeof([[enum {
	VK_DRIVER_ID_AMD_PROPRIETARY = 1,
	VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
	VK_DRIVER_ID_MESA_RADV = 3,
	VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
	VK_DRIVER_ID_ARM_PROPRIETARY = 9,
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
	VK_DRIVER_ID_GGP_PROPRIETARY = 11,
	VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
	VK_DRIVER_ID_MESA_LLVMPIPE = 13,
	VK_DRIVER_ID_MOLTENVK = 14,
	VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
	VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
	VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
	VK_DRIVER_ID_MESA_TURNIP = 18,
	VK_DRIVER_ID_MESA_V3DV = 19,
	VK_DRIVER_ID_MESA_PANVK = 20,
	VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
	VK_DRIVER_ID_MESA_VENUS = 22,
	VK_DRIVER_ID_MESA_DOZEN = 23,
	VK_DRIVER_ID_MESA_NVK = 24,
	VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
	VK_DRIVER_ID_MESA_HONEYKRISP = 26,
	VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN = 27,
	VK_DRIVER_ID_MESA_KOSMICKRISP = 28,
	VK_DRIVER_ID_AMD_PROPRIETARY_KHR = VK_DRIVER_ID_AMD_PROPRIETARY,
	VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = VK_DRIVER_ID_AMD_OPEN_SOURCE,
	VK_DRIVER_ID_MESA_RADV_KHR = VK_DRIVER_ID_MESA_RADV,
	VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = VK_DRIVER_ID_NVIDIA_PROPRIETARY,
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
	VK_DRIVER_ID_ARM_PROPRIETARY_KHR = VK_DRIVER_ID_ARM_PROPRIETARY,
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
	VK_DRIVER_ID_GGP_PROPRIETARY_KHR = VK_DRIVER_ID_GGP_PROPRIETARY,
	VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = VK_DRIVER_ID_BROADCOM_PROPRIETARY,
	VK_DRIVER_ID_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkShaderFloatControlsIndependence = ffi.typeof([[enum {
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSemaphoreType = ffi.typeof([[enum {
	VK_SEMAPHORE_TYPE_BINARY = 0,
	VK_SEMAPHORE_TYPE_TIMELINE = 1,
	VK_SEMAPHORE_TYPE_BINARY_KHR = VK_SEMAPHORE_TYPE_BINARY,
	VK_SEMAPHORE_TYPE_TIMELINE_KHR = VK_SEMAPHORE_TYPE_TIMELINE,
	VK_SEMAPHORE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSamplerReductionMode = ffi.typeof([[enum {
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
	VK_SAMPLER_REDUCTION_MODE_MIN = 1,
	VK_SAMPLER_REDUCTION_MODE_MAX = 2,
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM = 1000521000,
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
	VK_SAMPLER_REDUCTION_MODE_MIN_EXT = VK_SAMPLER_REDUCTION_MODE_MIN,
	VK_SAMPLER_REDUCTION_MODE_MAX_EXT = VK_SAMPLER_REDUCTION_MODE_MAX,
	VK_SAMPLER_REDUCTION_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkResolveModeFlagBits = ffi.typeof([[enum {
	VK_RESOLVE_MODE_NONE = 0,
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x00000001,
	VK_RESOLVE_MODE_AVERAGE_BIT = 0x00000002,
	VK_RESOLVE_MODE_MIN_BIT = 0x00000004,
	VK_RESOLVE_MODE_MAX_BIT = 0x00000008,
	VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID = 0x00000010,
	VK_RESOLVE_MODE_NONE_KHR = VK_RESOLVE_MODE_NONE,
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
	VK_RESOLVE_MODE_AVERAGE_BIT_KHR = VK_RESOLVE_MODE_AVERAGE_BIT,
	VK_RESOLVE_MODE_MIN_BIT_KHR = VK_RESOLVE_MODE_MIN_BIT,
	VK_RESOLVE_MODE_MAX_BIT_KHR = VK_RESOLVE_MODE_MAX_BIT,
	VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID = VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID,
	VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkResolveModeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSemaphoreWaitFlagBits = ffi.typeof([[enum {
	VK_SEMAPHORE_WAIT_ANY_BIT = 0x00000001,
	VK_SEMAPHORE_WAIT_ANY_BIT_KHR = VK_SEMAPHORE_WAIT_ANY_BIT,
	VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSemaphoreWaitFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDescriptorBindingFlagBits = ffi.typeof([[enum {
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x00000001,
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x00000002,
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x00000004,
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x00000008,
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
	VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkDescriptorBindingFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceVulkan11Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ storageBuffer16BitAccess;
	$ uniformAndStorageBuffer16BitAccess;
	$ storagePushConstant16;
	$ storageInputOutput16;
	$ multiview;
	$ multiviewGeometryShader;
	$ multiviewTessellationShader;
	$ variablePointersStorageBuffer;
	$ variablePointers;
	$ protectedMemory;
	$ samplerYcbcrConversion;
	$ shaderDrawParameters;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceVulkan11Properties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint8_t deviceUUID[16U];
	uint8_t driverUUID[16U];
	uint8_t deviceLUID[8U];
	uint32_t deviceNodeMask;
	$ deviceLUIDValid;
	uint32_t subgroupSize;
	$ subgroupSupportedStages;
	$ subgroupSupportedOperations;
	$ subgroupQuadOperationsInAllStages;
	$ pointClippingBehavior;
	uint32_t maxMultiviewViewCount;
	uint32_t maxMultiviewInstanceIndex;
	$ protectedNoFault;
	uint32_t maxPerSetDescriptors;
	$ maxMemoryAllocationSize;
}]], mod.VkStructureType, mod.VkBool32, mod.VkShaderStageFlags, mod.VkSubgroupFeatureFlags, mod.VkBool32, mod.VkPointClippingBehavior, mod.VkBool32, mod.VkDeviceSize)
mod.VkPhysicalDeviceVulkan12Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ samplerMirrorClampToEdge;
	$ drawIndirectCount;
	$ storageBuffer8BitAccess;
	$ uniformAndStorageBuffer8BitAccess;
	$ storagePushConstant8;
	$ shaderBufferInt64Atomics;
	$ shaderSharedInt64Atomics;
	$ shaderFloat16;
	$ shaderInt8;
	$ descriptorIndexing;
	$ shaderInputAttachmentArrayDynamicIndexing;
	$ shaderUniformTexelBufferArrayDynamicIndexing;
	$ shaderStorageTexelBufferArrayDynamicIndexing;
	$ shaderUniformBufferArrayNonUniformIndexing;
	$ shaderSampledImageArrayNonUniformIndexing;
	$ shaderStorageBufferArrayNonUniformIndexing;
	$ shaderStorageImageArrayNonUniformIndexing;
	$ shaderInputAttachmentArrayNonUniformIndexing;
	$ shaderUniformTexelBufferArrayNonUniformIndexing;
	$ shaderStorageTexelBufferArrayNonUniformIndexing;
	$ descriptorBindingUniformBufferUpdateAfterBind;
	$ descriptorBindingSampledImageUpdateAfterBind;
	$ descriptorBindingStorageImageUpdateAfterBind;
	$ descriptorBindingStorageBufferUpdateAfterBind;
	$ descriptorBindingUniformTexelBufferUpdateAfterBind;
	$ descriptorBindingStorageTexelBufferUpdateAfterBind;
	$ descriptorBindingUpdateUnusedWhilePending;
	$ descriptorBindingPartiallyBound;
	$ descriptorBindingVariableDescriptorCount;
	$ runtimeDescriptorArray;
	$ samplerFilterMinmax;
	$ scalarBlockLayout;
	$ imagelessFramebuffer;
	$ uniformBufferStandardLayout;
	$ shaderSubgroupExtendedTypes;
	$ separateDepthStencilLayouts;
	$ hostQueryReset;
	$ timelineSemaphore;
	$ bufferDeviceAddress;
	$ bufferDeviceAddressCaptureReplay;
	$ bufferDeviceAddressMultiDevice;
	$ vulkanMemoryModel;
	$ vulkanMemoryModelDeviceScope;
	$ vulkanMemoryModelAvailabilityVisibilityChains;
	$ shaderOutputViewportIndex;
	$ shaderOutputLayer;
	$ subgroupBroadcastDynamicId;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkConformanceVersion = ffi.typeof([[struct {
	uint8_t major;
	uint8_t minor;
	uint8_t subminor;
	uint8_t patch;
}]])
mod.VkPhysicalDeviceVulkan12Properties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ driverID;
	char driverName[256U];
	char driverInfo[256U];
	$ conformanceVersion;
	$ denormBehaviorIndependence;
	$ roundingModeIndependence;
	$ shaderSignedZeroInfNanPreserveFloat16;
	$ shaderSignedZeroInfNanPreserveFloat32;
	$ shaderSignedZeroInfNanPreserveFloat64;
	$ shaderDenormPreserveFloat16;
	$ shaderDenormPreserveFloat32;
	$ shaderDenormPreserveFloat64;
	$ shaderDenormFlushToZeroFloat16;
	$ shaderDenormFlushToZeroFloat32;
	$ shaderDenormFlushToZeroFloat64;
	$ shaderRoundingModeRTEFloat16;
	$ shaderRoundingModeRTEFloat32;
	$ shaderRoundingModeRTEFloat64;
	$ shaderRoundingModeRTZFloat16;
	$ shaderRoundingModeRTZFloat32;
	$ shaderRoundingModeRTZFloat64;
	uint32_t maxUpdateAfterBindDescriptorsInAllPools;
	$ shaderUniformBufferArrayNonUniformIndexingNative;
	$ shaderSampledImageArrayNonUniformIndexingNative;
	$ shaderStorageBufferArrayNonUniformIndexingNative;
	$ shaderStorageImageArrayNonUniformIndexingNative;
	$ shaderInputAttachmentArrayNonUniformIndexingNative;
	$ robustBufferAccessUpdateAfterBind;
	$ quadDivergentImplicitLod;
	uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
	uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
	uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
	uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
	uint32_t maxPerStageUpdateAfterBindResources;
	uint32_t maxDescriptorSetUpdateAfterBindSamplers;
	uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
	uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
	uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
	uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
	uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
	$ supportedDepthResolveModes;
	$ supportedStencilResolveModes;
	$ independentResolveNone;
	$ independentResolve;
	$ filterMinmaxSingleComponentFormats;
	$ filterMinmaxImageComponentMapping;
	uint64_t maxTimelineSemaphoreValueDifference;
	$ framebufferIntegerColorSampleCounts;
}]], mod.VkStructureType, mod.VkDriverId, mod.VkConformanceVersion, mod.VkShaderFloatControlsIndependence, mod.VkShaderFloatControlsIndependence, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkResolveModeFlags, mod.VkResolveModeFlags, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkSampleCountFlags)
mod.VkImageFormatListCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t viewFormatCount;
	const $* pViewFormats;
}]], mod.VkStructureType, mod.VkFormat)
mod.VkPhysicalDeviceDriverProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ driverID;
	char driverName[256U];
	char driverInfo[256U];
	$ conformanceVersion;
}]], mod.VkStructureType, mod.VkDriverId, mod.VkConformanceVersion)
mod.VkPhysicalDeviceVulkanMemoryModelFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ vulkanMemoryModel;
	$ vulkanMemoryModelDeviceScope;
	$ vulkanMemoryModelAvailabilityVisibilityChains;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceHostQueryResetFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ hostQueryReset;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceTimelineSemaphoreFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ timelineSemaphore;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceTimelineSemaphoreProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint64_t maxTimelineSemaphoreValueDifference;
}]], mod.VkStructureType)
mod.VkSemaphoreTypeCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ semaphoreType;
	uint64_t initialValue;
}]], mod.VkStructureType, mod.VkSemaphoreType)
mod.VkTimelineSemaphoreSubmitInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreValueCount;
	const uint64_t* pWaitSemaphoreValues;
	uint32_t signalSemaphoreValueCount;
	const uint64_t* pSignalSemaphoreValues;
}]], mod.VkStructureType)
mod.VkSemaphoreWaitInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t semaphoreCount;
	const $* pSemaphores;
	const uint64_t* pValues;
}]], mod.VkStructureType, mod.VkSemaphoreWaitFlags, mod.VkSemaphore)
mod.VkSemaphoreSignalInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	uint64_t value;
}]], mod.VkStructureType, mod.VkSemaphore)
mod.VkPhysicalDeviceBufferDeviceAddressFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ bufferDeviceAddress;
	$ bufferDeviceAddressCaptureReplay;
	$ bufferDeviceAddressMultiDevice;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkBufferDeviceAddressInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ buffer;
}]], mod.VkStructureType, mod.VkBuffer)
mod.VkBufferOpaqueCaptureAddressCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t opaqueCaptureAddress;
}]], mod.VkStructureType)
mod.VkMemoryOpaqueCaptureAddressAllocateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t opaqueCaptureAddress;
}]], mod.VkStructureType)
mod.VkDeviceMemoryOpaqueCaptureAddressInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ memory;
}]], mod.VkStructureType, mod.VkDeviceMemory)
mod.VkPhysicalDevice8BitStorageFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ storageBuffer8BitAccess;
	$ uniformAndStorageBuffer8BitAccess;
	$ storagePushConstant8;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceShaderAtomicInt64Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderBufferInt64Atomics;
	$ shaderSharedInt64Atomics;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceShaderFloat16Int8Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderFloat16;
	$ shaderInt8;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceFloatControlsProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ denormBehaviorIndependence;
	$ roundingModeIndependence;
	$ shaderSignedZeroInfNanPreserveFloat16;
	$ shaderSignedZeroInfNanPreserveFloat32;
	$ shaderSignedZeroInfNanPreserveFloat64;
	$ shaderDenormPreserveFloat16;
	$ shaderDenormPreserveFloat32;
	$ shaderDenormPreserveFloat64;
	$ shaderDenormFlushToZeroFloat16;
	$ shaderDenormFlushToZeroFloat32;
	$ shaderDenormFlushToZeroFloat64;
	$ shaderRoundingModeRTEFloat16;
	$ shaderRoundingModeRTEFloat32;
	$ shaderRoundingModeRTEFloat64;
	$ shaderRoundingModeRTZFloat16;
	$ shaderRoundingModeRTZFloat32;
	$ shaderRoundingModeRTZFloat64;
}]], mod.VkStructureType, mod.VkShaderFloatControlsIndependence, mod.VkShaderFloatControlsIndependence, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDescriptorSetLayoutBindingFlagsCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t bindingCount;
	const $* pBindingFlags;
}]], mod.VkStructureType, mod.VkDescriptorBindingFlags)
mod.VkPhysicalDeviceDescriptorIndexingFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderInputAttachmentArrayDynamicIndexing;
	$ shaderUniformTexelBufferArrayDynamicIndexing;
	$ shaderStorageTexelBufferArrayDynamicIndexing;
	$ shaderUniformBufferArrayNonUniformIndexing;
	$ shaderSampledImageArrayNonUniformIndexing;
	$ shaderStorageBufferArrayNonUniformIndexing;
	$ shaderStorageImageArrayNonUniformIndexing;
	$ shaderInputAttachmentArrayNonUniformIndexing;
	$ shaderUniformTexelBufferArrayNonUniformIndexing;
	$ shaderStorageTexelBufferArrayNonUniformIndexing;
	$ descriptorBindingUniformBufferUpdateAfterBind;
	$ descriptorBindingSampledImageUpdateAfterBind;
	$ descriptorBindingStorageImageUpdateAfterBind;
	$ descriptorBindingStorageBufferUpdateAfterBind;
	$ descriptorBindingUniformTexelBufferUpdateAfterBind;
	$ descriptorBindingStorageTexelBufferUpdateAfterBind;
	$ descriptorBindingUpdateUnusedWhilePending;
	$ descriptorBindingPartiallyBound;
	$ descriptorBindingVariableDescriptorCount;
	$ runtimeDescriptorArray;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceDescriptorIndexingProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxUpdateAfterBindDescriptorsInAllPools;
	$ shaderUniformBufferArrayNonUniformIndexingNative;
	$ shaderSampledImageArrayNonUniformIndexingNative;
	$ shaderStorageBufferArrayNonUniformIndexingNative;
	$ shaderStorageImageArrayNonUniformIndexingNative;
	$ shaderInputAttachmentArrayNonUniformIndexingNative;
	$ robustBufferAccessUpdateAfterBind;
	$ quadDivergentImplicitLod;
	uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
	uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
	uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
	uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
	uint32_t maxPerStageUpdateAfterBindResources;
	uint32_t maxDescriptorSetUpdateAfterBindSamplers;
	uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
	uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
	uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
	uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
	uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDescriptorSetVariableDescriptorCountAllocateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t descriptorSetCount;
	const uint32_t* pDescriptorCounts;
}]], mod.VkStructureType)
mod.VkDescriptorSetVariableDescriptorCountLayoutSupport = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxVariableDescriptorCount;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceScalarBlockLayoutFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ scalarBlockLayout;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSamplerReductionModeCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ reductionMode;
}]], mod.VkStructureType, mod.VkSamplerReductionMode)
mod.VkPhysicalDeviceSamplerFilterMinmaxProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ filterMinmaxSingleComponentFormats;
	$ filterMinmaxImageComponentMapping;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceUniformBufferStandardLayoutFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ uniformBufferStandardLayout;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderSubgroupExtendedTypes;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkAttachmentDescription2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ format;
	$ samples;
	$ loadOp;
	$ storeOp;
	$ stencilLoadOp;
	$ stencilStoreOp;
	$ initialLayout;
	$ finalLayout;
}]], mod.VkStructureType, mod.VkAttachmentDescriptionFlags, mod.VkFormat, mod.VkSampleCountFlagBits, mod.VkAttachmentLoadOp, mod.VkAttachmentStoreOp, mod.VkAttachmentLoadOp, mod.VkAttachmentStoreOp, mod.VkImageLayout, mod.VkImageLayout)
mod.VkAttachmentReference2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t attachment;
	$ layout;
	$ aspectMask;
}]], mod.VkStructureType, mod.VkImageLayout, mod.VkImageAspectFlags)
mod.VkSubpassDescription2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ pipelineBindPoint;
	uint32_t viewMask;
	uint32_t inputAttachmentCount;
	const $* pInputAttachments;
	uint32_t colorAttachmentCount;
	const $* pColorAttachments;
	const $* pResolveAttachments;
	const $* pDepthStencilAttachment;
	uint32_t preserveAttachmentCount;
	const uint32_t* pPreserveAttachments;
}]], mod.VkStructureType, mod.VkSubpassDescriptionFlags, mod.VkPipelineBindPoint, mod.VkAttachmentReference2, mod.VkAttachmentReference2, mod.VkAttachmentReference2, mod.VkAttachmentReference2)
mod.VkSubpassDependency2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t srcSubpass;
	uint32_t dstSubpass;
	$ srcStageMask;
	$ dstStageMask;
	$ srcAccessMask;
	$ dstAccessMask;
	$ dependencyFlags;
	int32_t viewOffset;
}]], mod.VkStructureType, mod.VkPipelineStageFlags, mod.VkPipelineStageFlags, mod.VkAccessFlags, mod.VkAccessFlags, mod.VkDependencyFlags)
mod.VkRenderPassCreateInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t attachmentCount;
	const $* pAttachments;
	uint32_t subpassCount;
	const $* pSubpasses;
	uint32_t dependencyCount;
	const $* pDependencies;
	uint32_t correlatedViewMaskCount;
	const uint32_t* pCorrelatedViewMasks;
}]], mod.VkStructureType, mod.VkRenderPassCreateFlags, mod.VkAttachmentDescription2, mod.VkSubpassDescription2, mod.VkSubpassDependency2)
mod.VkSubpassBeginInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ contents;
}]], mod.VkStructureType, mod.VkSubpassContents)
mod.VkSubpassEndInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
mod.VkSubpassDescriptionDepthStencilResolve = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ depthResolveMode;
	$ stencilResolveMode;
	const $* pDepthStencilResolveAttachment;
}]], mod.VkStructureType, mod.VkResolveModeFlagBits, mod.VkResolveModeFlagBits, mod.VkAttachmentReference2)
mod.VkPhysicalDeviceDepthStencilResolveProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ supportedDepthResolveModes;
	$ supportedStencilResolveModes;
	$ independentResolveNone;
	$ independentResolve;
}]], mod.VkStructureType, mod.VkResolveModeFlags, mod.VkResolveModeFlags, mod.VkBool32, mod.VkBool32)
mod.VkImageStencilUsageCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stencilUsage;
}]], mod.VkStructureType, mod.VkImageUsageFlags)
mod.VkPhysicalDeviceImagelessFramebufferFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imagelessFramebuffer;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkFramebufferAttachmentImageInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ usage;
	uint32_t width;
	uint32_t height;
	uint32_t layerCount;
	uint32_t viewFormatCount;
	const $* pViewFormats;
}]], mod.VkStructureType, mod.VkImageCreateFlags, mod.VkImageUsageFlags, mod.VkFormat)
mod.VkFramebufferAttachmentsCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t attachmentImageInfoCount;
	const $* pAttachmentImageInfos;
}]], mod.VkStructureType, mod.VkFramebufferAttachmentImageInfo)
mod.VkRenderPassAttachmentBeginInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t attachmentCount;
	const $* pAttachments;
}]], mod.VkStructureType, mod.VkImageView)
mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ separateDepthStencilLayouts;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkAttachmentReferenceStencilLayout = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ stencilLayout;
}]], mod.VkStructureType, mod.VkImageLayout)
mod.VkAttachmentDescriptionStencilLayout = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ stencilInitialLayout;
	$ stencilFinalLayout;
}]], mod.VkStructureType, mod.VkImageLayout, mod.VkImageLayout)
mod.PFN_vkResetQueryPool = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkDevice, mod.VkQueryPool)
mod.PFN_vkGetSemaphoreCounterValue = ffi.typeof([[$ (*)($ , $ , uint64_t*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphore)
mod.PFN_vkWaitSemaphores = ffi.typeof([[$ (*)($ , const $*, uint64_t )]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreWaitInfo)
mod.PFN_vkSignalSemaphore = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreSignalInfo)
mod.PFN_vkGetBufferDeviceAddress = ffi.typeof([[$ (*)($ , const $*)]], mod.VkDeviceAddress, mod.VkDevice, mod.VkBufferDeviceAddressInfo)
mod.PFN_vkGetBufferOpaqueCaptureAddress = ffi.typeof([[uint64_t (*)($ , const $*)]], mod.VkDevice, mod.VkBufferDeviceAddressInfo)
mod.PFN_vkGetDeviceMemoryOpaqueCaptureAddress = ffi.typeof([[uint64_t (*)($ , const $*)]], mod.VkDevice, mod.VkDeviceMemoryOpaqueCaptureAddressInfo)
mod.PFN_vkCmdDrawIndirectCount = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdDrawIndexedIndirectCount = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCreateRenderPass2 = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkRenderPassCreateInfo2, mod.VkAllocationCallbacks, mod.VkRenderPass)
mod.PFN_vkCmdBeginRenderPass2 = ffi.typeof([[void (*)($ , const $*, const $*)]], mod.VkCommandBuffer, mod.VkRenderPassBeginInfo, mod.VkSubpassBeginInfo)
mod.PFN_vkCmdNextSubpass2 = ffi.typeof([[void (*)($ , const $*, const $*)]], mod.VkCommandBuffer, mod.VkSubpassBeginInfo, mod.VkSubpassEndInfo)
mod.PFN_vkCmdEndRenderPass2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkSubpassEndInfo)
ffi.cdef([[void  vkResetQueryPool($ , $ , uint32_t , uint32_t );]], mod.VkDevice, mod.VkQueryPool)
ffi.cdef([[$  vkGetSemaphoreCounterValue($ , $ , uint64_t*);]], mod.VkResult, mod.VkDevice, mod.VkSemaphore)
ffi.cdef([[$  vkWaitSemaphores($ , const $*, uint64_t );]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreWaitInfo)
ffi.cdef([[$  vkSignalSemaphore($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreSignalInfo)
ffi.cdef([[$  vkGetBufferDeviceAddress($ , const $*);]], mod.VkDeviceAddress, mod.VkDevice, mod.VkBufferDeviceAddressInfo)
ffi.cdef([[uint64_t  vkGetBufferOpaqueCaptureAddress($ , const $*);]], mod.VkDevice, mod.VkBufferDeviceAddressInfo)
ffi.cdef([[uint64_t  vkGetDeviceMemoryOpaqueCaptureAddress($ , const $*);]], mod.VkDevice, mod.VkDeviceMemoryOpaqueCaptureAddressInfo)
ffi.cdef([[void  vkCmdDrawIndirectCount($ , $ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawIndexedIndirectCount($ , $ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[$  vkCreateRenderPass2($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkRenderPassCreateInfo2, mod.VkAllocationCallbacks, mod.VkRenderPass)
ffi.cdef([[void  vkCmdBeginRenderPass2($ , const $*, const $*);]], mod.VkCommandBuffer, mod.VkRenderPassBeginInfo, mod.VkSubpassBeginInfo)
ffi.cdef([[void  vkCmdNextSubpass2($ , const $*, const $*);]], mod.VkCommandBuffer, mod.VkSubpassBeginInfo, mod.VkSubpassEndInfo)
ffi.cdef([[void  vkCmdEndRenderPass2($ , const $*);]], mod.VkCommandBuffer, mod.VkSubpassEndInfo)
mod.VkFlags64 = ffi.typeof([[uint64_t ]])
mod.VkPrivateDataSlot = ffi.typeof([[void*]])
mod.VkToolPurposeFlagBits = ffi.typeof([[enum {
	VK_TOOL_PURPOSE_VALIDATION_BIT = 0x00000001,
	VK_TOOL_PURPOSE_PROFILING_BIT = 0x00000002,
	VK_TOOL_PURPOSE_TRACING_BIT = 0x00000004,
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x00000008,
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x00000010,
	VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020,
	VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040,
	VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = VK_TOOL_PURPOSE_VALIDATION_BIT,
	VK_TOOL_PURPOSE_PROFILING_BIT_EXT = VK_TOOL_PURPOSE_PROFILING_BIT,
	VK_TOOL_PURPOSE_TRACING_BIT_EXT = VK_TOOL_PURPOSE_TRACING_BIT,
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
	VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkToolPurposeFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPrivateDataSlotCreateFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineStageFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkPipelineStageFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_PIPELINE_STAGE_2_NONE = 0ULL
mod.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001ULL
mod.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008ULL
mod.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010ULL
mod.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020ULL
mod.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040ULL
mod.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080ULL
mod.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 0x00000100ULL
mod.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 0x00000200ULL
mod.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400ULL
mod.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800ULL
mod.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000ULL
mod.VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000ULL
mod.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000ULL
mod.VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000ULL
mod.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000ULL
mod.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000ULL
mod.VK_PIPELINE_STAGE_2_COPY_BIT = 0x100000000ULL
mod.VK_PIPELINE_STAGE_2_RESOLVE_BIT = 0x200000000ULL
mod.VK_PIPELINE_STAGE_2_BLIT_BIT = 0x400000000ULL
mod.VK_PIPELINE_STAGE_2_CLEAR_BIT = 0x800000000ULL
mod.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 0x1000000000ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 0x2000000000ULL
mod.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 0x4000000000ULL
mod.VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000ULL
mod.VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000ULL
mod.VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL
mod.VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL
mod.VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL
mod.VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010ULL
mod.VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020ULL
mod.VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040ULL
mod.VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080ULL
mod.VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100ULL
mod.VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200ULL
mod.VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400ULL
mod.VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800ULL
mod.VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL
mod.VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL
mod.VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000ULL
mod.VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL
mod.VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL
mod.VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL
mod.VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL
mod.VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL
mod.VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL
mod.VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL
mod.VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL
mod.VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 0x2000000000ULL
mod.VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000ULL
mod.VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000ULL
mod.VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000ULL
mod.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 0x00020000ULL
mod.VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT = 0x00020000ULL
mod.VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000ULL
mod.VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 0x00400000ULL
mod.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000ULL
mod.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 0x00200000ULL
mod.VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 0x00200000ULL
mod.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000ULL
mod.VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000ULL
mod.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000ULL
mod.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000ULL
mod.VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 0x00080000ULL
mod.VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 0x00100000ULL
mod.VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI = 0x8000000000ULL
mod.VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 0x8000000000ULL
mod.VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 0x10000000000ULL
mod.VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 0x10000000ULL
mod.VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 0x40000000ULL
mod.VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = 0x20000000000ULL
mod.VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 0x20000000ULL
mod.VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV = 0x100000000000ULL
mod.VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM = 0x40000000000ULL
mod.VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR = 0x400000000000ULL
mod.VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT = 0x200000000000ULL
mod.VkAccessFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkAccessFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_ACCESS_2_NONE = 0ULL
mod.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001ULL
mod.VK_ACCESS_2_INDEX_READ_BIT = 0x00000002ULL
mod.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004ULL
mod.VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008ULL
mod.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010ULL
mod.VK_ACCESS_2_SHADER_READ_BIT = 0x00000020ULL
mod.VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100ULL
mod.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200ULL
mod.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400ULL
mod.VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800ULL
mod.VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000ULL
mod.VK_ACCESS_2_HOST_READ_BIT = 0x00002000ULL
mod.VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000ULL
mod.VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000ULL
mod.VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000ULL
mod.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 0x100000000ULL
mod.VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 0x200000000ULL
mod.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 0x400000000ULL
mod.VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000ULL
mod.VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000ULL
mod.VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000ULL
mod.VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000ULL
mod.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM = 0x8000000000000ULL
mod.VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM = 0x10000000000000ULL
mod.VK_ACCESS_2_NONE_KHR = 0ULL
mod.VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL
mod.VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL
mod.VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL
mod.VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL
mod.VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL
mod.VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL
mod.VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL
mod.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200ULL
mod.VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400ULL
mod.VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL
mod.VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL
mod.VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL
mod.VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL
mod.VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL
mod.VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL
mod.VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL
mod.VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL
mod.VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL
mod.VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000ULL
mod.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000ULL
mod.VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000ULL
mod.VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000ULL
mod.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000ULL
mod.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000ULL
mod.VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT = 0x00020000ULL
mod.VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT = 0x00040000ULL
mod.VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000ULL
mod.VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000ULL
mod.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000ULL
mod.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000ULL
mod.VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000ULL
mod.VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000ULL
mod.VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000ULL
mod.VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000ULL
mod.VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = 0x20000000000ULL
mod.VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 0x8000000000ULL
mod.VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = 0x10000000000ULL
mod.VK_ACCESS_2_MICROMAP_READ_BIT_EXT = 0x100000000000ULL
mod.VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = 0x200000000000ULL
mod.VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = 0x40000000000ULL
mod.VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = 0x80000000000ULL
mod.VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM = 0x800000000000ULL
mod.VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM = 0x1000000000000ULL
mod.VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT = 0x80000000000000ULL
mod.VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT = 0x100000000000000ULL
mod.VkSubmitFlagBits = ffi.typeof([[enum {
	VK_SUBMIT_PROTECTED_BIT = 0x00000001,
	VK_SUBMIT_PROTECTED_BIT_KHR = VK_SUBMIT_PROTECTED_BIT,
	VK_SUBMIT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkSubmitFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkFormatFeatureFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkFormatFeatureFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 0x00000001ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 0x00000002ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004ULL
mod.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = 0x00000010ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020ULL
mod.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 0x00000040ULL
mod.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 0x00000080ULL
mod.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100ULL
mod.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200ULL
mod.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = 0x00000400ULL
mod.VK_FORMAT_FEATURE_2_BLIT_DST_BIT = 0x00000800ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000ULL
mod.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 0x00004000ULL
mod.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = 0x00008000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000ULL
mod.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000ULL
mod.VK_FORMAT_FEATURE_2_DISJOINT_BIT = 0x00400000ULL
mod.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = 0x00800000ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = 0x80000000ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = 0x100000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = 0x200000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = 0x00002000ULL
mod.VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT = 0x400000000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000ULL
mod.VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000ULL
mod.VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000ULL
mod.VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000ULL
mod.VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT = 0x400000000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 0x00000001ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 0x00000002ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 0x00000004ULL
mod.VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000008ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000010ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 0x00000020ULL
mod.VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 0x00000040ULL
mod.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 0x00000080ULL
mod.VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 0x00000100ULL
mod.VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 0x00000200ULL
mod.VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 0x00000400ULL
mod.VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 0x00000800ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 0x00001000ULL
mod.VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 0x00004000ULL
mod.VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 0x00008000ULL
mod.VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 0x00020000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 0x00080000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 0x00100000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 0x00200000ULL
mod.VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 0x00400000ULL
mod.VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 0x00800000ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 0x80000000ULL
mod.VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = 0x100000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = 0x200000000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 0x00010000ULL
mod.VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000ULL
mod.VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV = 0x8000000000000ULL
mod.VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = 0x4000000000ULL
mod.VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = 0x400000000ULL
mod.VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = 0x800000000ULL
mod.VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM = 0x1000000000ULL
mod.VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM = 0x2000000000ULL
mod.VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM = 0x8000000000ULL
mod.VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM = 0x80000000000ULL
mod.VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = 0x10000000000ULL
mod.VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = 0x20000000000ULL
mod.VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = 0x40000000000ULL
mod.VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM = 0x1000000000000ULL
mod.VK_FORMAT_FEATURE_2_COPY_IMAGE_INDIRECT_DST_BIT_KHR = 0x800000000000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x2000000000000ULL
mod.VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x4000000000000ULL
mod.VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_COMPUTE_QUEUE_BIT_KHR = 0x10000000000000ULL
mod.VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_TRANSFER_QUEUE_BIT_KHR = 0x20000000000000ULL
mod.VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_COMPUTE_QUEUE_BIT_KHR = 0x40000000000000ULL
mod.VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_TRANSFER_QUEUE_BIT_KHR = 0x80000000000000ULL
mod.VkPipelineCreationFeedbackFlagBits = ffi.typeof([[enum {
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x00000001,
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x00000002,
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x00000004,
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
	VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineCreationFeedbackFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkRenderingFlagBits = ffi.typeof([[enum {
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x00000001,
	VK_RENDERING_SUSPENDING_BIT = 0x00000002,
	VK_RENDERING_RESUMING_BIT = 0x00000004,
	VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000008,
	VK_RENDERING_CONTENTS_INLINE_BIT_KHR = 0x00000010,
	VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x00000020,
	VK_RENDERING_LOCAL_READ_CONCURRENT_ACCESS_CONTROL_BIT_KHR = 0x00000100,
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
	VK_RENDERING_SUSPENDING_BIT_KHR = VK_RENDERING_SUSPENDING_BIT,
	VK_RENDERING_RESUMING_BIT_KHR = VK_RENDERING_RESUMING_BIT,
	VK_RENDERING_CONTENTS_INLINE_BIT_EXT = VK_RENDERING_CONTENTS_INLINE_BIT_KHR,
	VK_RENDERING_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkRenderingFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceVulkan13Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ robustImageAccess;
	$ inlineUniformBlock;
	$ descriptorBindingInlineUniformBlockUpdateAfterBind;
	$ pipelineCreationCacheControl;
	$ privateData;
	$ shaderDemoteToHelperInvocation;
	$ shaderTerminateInvocation;
	$ subgroupSizeControl;
	$ computeFullSubgroups;
	$ synchronization2;
	$ textureCompressionASTC_HDR;
	$ shaderZeroInitializeWorkgroupMemory;
	$ dynamicRendering;
	$ shaderIntegerDotProduct;
	$ maintenance4;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceVulkan13Properties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t minSubgroupSize;
	uint32_t maxSubgroupSize;
	uint32_t maxComputeWorkgroupSubgroups;
	$ requiredSubgroupSizeStages;
	uint32_t maxInlineUniformBlockSize;
	uint32_t maxPerStageDescriptorInlineUniformBlocks;
	uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	uint32_t maxDescriptorSetInlineUniformBlocks;
	uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
	uint32_t maxInlineUniformTotalSize;
	$ integerDotProduct8BitUnsignedAccelerated;
	$ integerDotProduct8BitSignedAccelerated;
	$ integerDotProduct8BitMixedSignednessAccelerated;
	$ integerDotProduct4x8BitPackedUnsignedAccelerated;
	$ integerDotProduct4x8BitPackedSignedAccelerated;
	$ integerDotProduct4x8BitPackedMixedSignednessAccelerated;
	$ integerDotProduct16BitUnsignedAccelerated;
	$ integerDotProduct16BitSignedAccelerated;
	$ integerDotProduct16BitMixedSignednessAccelerated;
	$ integerDotProduct32BitUnsignedAccelerated;
	$ integerDotProduct32BitSignedAccelerated;
	$ integerDotProduct32BitMixedSignednessAccelerated;
	$ integerDotProduct64BitUnsignedAccelerated;
	$ integerDotProduct64BitSignedAccelerated;
	$ integerDotProduct64BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating8BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating16BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating32BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating64BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
	$ storageTexelBufferOffsetAlignmentBytes;
	$ storageTexelBufferOffsetSingleTexelAlignment;
	$ uniformTexelBufferOffsetAlignmentBytes;
	$ uniformTexelBufferOffsetSingleTexelAlignment;
	$ maxBufferSize;
}]], mod.VkStructureType, mod.VkShaderStageFlags, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkDeviceSize, mod.VkBool32, mod.VkDeviceSize, mod.VkBool32, mod.VkDeviceSize)
mod.VkPhysicalDeviceToolProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	char name[256U];
	char version[256U];
	$ purposes;
	char description[256U];
	char layer[256U];
}]], mod.VkStructureType, mod.VkToolPurposeFlags)
mod.VkPhysicalDevicePrivateDataFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ privateData;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDevicePrivateDataCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t privateDataSlotRequestCount;
}]], mod.VkStructureType)
mod.VkPrivateDataSlotCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkPrivateDataSlotCreateFlags)
mod.VkMemoryBarrier2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcStageMask;
	$ srcAccessMask;
	$ dstStageMask;
	$ dstAccessMask;
}]], mod.VkStructureType, mod.VkPipelineStageFlags2, mod.VkAccessFlags2, mod.VkPipelineStageFlags2, mod.VkAccessFlags2)
mod.VkBufferMemoryBarrier2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcStageMask;
	$ srcAccessMask;
	$ dstStageMask;
	$ dstAccessMask;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ buffer;
	$ offset;
	$ size;
}]], mod.VkStructureType, mod.VkPipelineStageFlags2, mod.VkAccessFlags2, mod.VkPipelineStageFlags2, mod.VkAccessFlags2, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkImageMemoryBarrier2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcStageMask;
	$ srcAccessMask;
	$ dstStageMask;
	$ dstAccessMask;
	$ oldLayout;
	$ newLayout;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ image;
	$ subresourceRange;
}]], mod.VkStructureType, mod.VkPipelineStageFlags2, mod.VkAccessFlags2, mod.VkPipelineStageFlags2, mod.VkAccessFlags2, mod.VkImageLayout, mod.VkImageLayout, mod.VkImage, mod.VkImageSubresourceRange)
mod.VkDependencyInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ dependencyFlags;
	uint32_t memoryBarrierCount;
	const $* pMemoryBarriers;
	uint32_t bufferMemoryBarrierCount;
	const $* pBufferMemoryBarriers;
	uint32_t imageMemoryBarrierCount;
	const $* pImageMemoryBarriers;
}]], mod.VkStructureType, mod.VkDependencyFlags, mod.VkMemoryBarrier2, mod.VkBufferMemoryBarrier2, mod.VkImageMemoryBarrier2)
mod.VkSemaphoreSubmitInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	uint64_t value;
	$ stageMask;
	uint32_t deviceIndex;
}]], mod.VkStructureType, mod.VkSemaphore, mod.VkPipelineStageFlags2)
mod.VkCommandBufferSubmitInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ commandBuffer;
	uint32_t deviceMask;
}]], mod.VkStructureType, mod.VkCommandBuffer)
mod.VkSubmitInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t waitSemaphoreInfoCount;
	const $* pWaitSemaphoreInfos;
	uint32_t commandBufferInfoCount;
	const $* pCommandBufferInfos;
	uint32_t signalSemaphoreInfoCount;
	const $* pSignalSemaphoreInfos;
}]], mod.VkStructureType, mod.VkSubmitFlags, mod.VkSemaphoreSubmitInfo, mod.VkCommandBufferSubmitInfo, mod.VkSemaphoreSubmitInfo)
mod.VkPhysicalDeviceSynchronization2Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ synchronization2;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkBufferCopy2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcOffset;
	$ dstOffset;
	$ size;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkCopyBufferInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcBuffer;
	$ dstBuffer;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkBuffer, mod.VkBuffer, mod.VkBufferCopy2)
mod.VkImageCopy2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcSubresource;
	$ srcOffset;
	$ dstSubresource;
	$ dstOffset;
	$ extent;
}]], mod.VkStructureType, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkCopyImageInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcImage;
	$ srcImageLayout;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageCopy2)
mod.VkBufferImageCopy2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ bufferOffset;
	uint32_t bufferRowLength;
	uint32_t bufferImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkCopyBufferToImageInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcBuffer;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkBuffer, mod.VkImage, mod.VkImageLayout, mod.VkBufferImageCopy2)
mod.VkCopyImageToBufferInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcImage;
	$ srcImageLayout;
	$ dstBuffer;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkImage, mod.VkImageLayout, mod.VkBuffer, mod.VkBufferImageCopy2)
mod.VkPhysicalDeviceTextureCompressionASTCHDRFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ textureCompressionASTC_HDR;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkFormatProperties3 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ linearTilingFeatures;
	$ optimalTilingFeatures;
	$ bufferFeatures;
}]], mod.VkStructureType, mod.VkFormatFeatureFlags2, mod.VkFormatFeatureFlags2, mod.VkFormatFeatureFlags2)
mod.VkPhysicalDeviceMaintenance4Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maintenance4;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMaintenance4Properties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxBufferSize;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkDeviceBufferMemoryRequirements = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pCreateInfo;
}]], mod.VkStructureType, mod.VkBufferCreateInfo)
mod.VkDeviceImageMemoryRequirements = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pCreateInfo;
	$ planeAspect;
}]], mod.VkStructureType, mod.VkImageCreateInfo, mod.VkImageAspectFlagBits)
mod.VkPipelineCreationFeedback = ffi.typeof([[struct {
	$ flags;
	uint64_t duration;
}]], mod.VkPipelineCreationFeedbackFlags)
mod.VkPipelineCreationFeedbackCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$* pPipelineCreationFeedback;
	uint32_t pipelineStageCreationFeedbackCount;
	$* pPipelineStageCreationFeedbacks;
}]], mod.VkStructureType, mod.VkPipelineCreationFeedback, mod.VkPipelineCreationFeedback)
mod.VkPhysicalDeviceShaderTerminateInvocationFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderTerminateInvocation;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderDemoteToHelperInvocation;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePipelineCreationCacheControlFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineCreationCacheControl;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderZeroInitializeWorkgroupMemory;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceImageRobustnessFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ robustImageAccess;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceSubgroupSizeControlFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ subgroupSizeControl;
	$ computeFullSubgroups;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceSubgroupSizeControlProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t minSubgroupSize;
	uint32_t maxSubgroupSize;
	uint32_t maxComputeWorkgroupSubgroups;
	$ requiredSubgroupSizeStages;
}]], mod.VkStructureType, mod.VkShaderStageFlags)
mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t requiredSubgroupSize;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceInlineUniformBlockFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ inlineUniformBlock;
	$ descriptorBindingInlineUniformBlockUpdateAfterBind;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceInlineUniformBlockProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxInlineUniformBlockSize;
	uint32_t maxPerStageDescriptorInlineUniformBlocks;
	uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	uint32_t maxDescriptorSetInlineUniformBlocks;
	uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
}]], mod.VkStructureType)
mod.VkWriteDescriptorSetInlineUniformBlock = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t dataSize;
	const void* pData;
}]], mod.VkStructureType)
mod.VkDescriptorPoolInlineUniformBlockCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maxInlineUniformBlockBindings;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceShaderIntegerDotProductFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderIntegerDotProduct;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderIntegerDotProductProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ integerDotProduct8BitUnsignedAccelerated;
	$ integerDotProduct8BitSignedAccelerated;
	$ integerDotProduct8BitMixedSignednessAccelerated;
	$ integerDotProduct4x8BitPackedUnsignedAccelerated;
	$ integerDotProduct4x8BitPackedSignedAccelerated;
	$ integerDotProduct4x8BitPackedMixedSignednessAccelerated;
	$ integerDotProduct16BitUnsignedAccelerated;
	$ integerDotProduct16BitSignedAccelerated;
	$ integerDotProduct16BitMixedSignednessAccelerated;
	$ integerDotProduct32BitUnsignedAccelerated;
	$ integerDotProduct32BitSignedAccelerated;
	$ integerDotProduct32BitMixedSignednessAccelerated;
	$ integerDotProduct64BitUnsignedAccelerated;
	$ integerDotProduct64BitSignedAccelerated;
	$ integerDotProduct64BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating8BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
	$ integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating16BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating32BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
	$ integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
	$ integerDotProductAccumulatingSaturating64BitSignedAccelerated;
	$ integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceTexelBufferAlignmentProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ storageTexelBufferOffsetAlignmentBytes;
	$ storageTexelBufferOffsetSingleTexelAlignment;
	$ uniformTexelBufferOffsetAlignmentBytes;
	$ uniformTexelBufferOffsetSingleTexelAlignment;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkBool32, mod.VkDeviceSize, mod.VkBool32)
mod.VkImageBlit2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcSubresource;
	$ srcOffsets[2];
	$ dstSubresource;
	$ dstOffsets[2];
}]], mod.VkStructureType, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkImageSubresourceLayers, mod.VkOffset3D)
mod.VkBlitImageInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcImage;
	$ srcImageLayout;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
	$ filter;
}]], mod.VkStructureType, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageBlit2, mod.VkFilter)
mod.VkImageResolve2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcSubresource;
	$ srcOffset;
	$ dstSubresource;
	$ dstOffset;
	$ extent;
}]], mod.VkStructureType, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkResolveImageInfo2 = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcImage;
	$ srcImageLayout;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageResolve2)
mod.VkRenderingAttachmentInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ imageView;
	$ imageLayout;
	$ resolveMode;
	$ resolveImageView;
	$ resolveImageLayout;
	$ loadOp;
	$ storeOp;
	$ clearValue;
}]], mod.VkStructureType, mod.VkImageView, mod.VkImageLayout, mod.VkResolveModeFlagBits, mod.VkImageView, mod.VkImageLayout, mod.VkAttachmentLoadOp, mod.VkAttachmentStoreOp, mod.VkClearValue)
mod.VkRenderingInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ renderArea;
	uint32_t layerCount;
	uint32_t viewMask;
	uint32_t colorAttachmentCount;
	const $* pColorAttachments;
	const $* pDepthAttachment;
	const $* pStencilAttachment;
}]], mod.VkStructureType, mod.VkRenderingFlags, mod.VkRect2D, mod.VkRenderingAttachmentInfo, mod.VkRenderingAttachmentInfo, mod.VkRenderingAttachmentInfo)
mod.VkPipelineRenderingCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t viewMask;
	uint32_t colorAttachmentCount;
	const $* pColorAttachmentFormats;
	$ depthAttachmentFormat;
	$ stencilAttachmentFormat;
}]], mod.VkStructureType, mod.VkFormat, mod.VkFormat, mod.VkFormat)
mod.VkPhysicalDeviceDynamicRenderingFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ dynamicRendering;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkCommandBufferInheritanceRenderingInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t viewMask;
	uint32_t colorAttachmentCount;
	const $* pColorAttachmentFormats;
	$ depthAttachmentFormat;
	$ stencilAttachmentFormat;
	$ rasterizationSamples;
}]], mod.VkStructureType, mod.VkRenderingFlags, mod.VkFormat, mod.VkFormat, mod.VkFormat, mod.VkSampleCountFlagBits)
mod.PFN_vkGetPhysicalDeviceToolProperties = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceToolProperties)
mod.PFN_vkCreatePrivateDataSlot = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPrivateDataSlotCreateInfo, mod.VkAllocationCallbacks, mod.VkPrivateDataSlot)
mod.PFN_vkDestroyPrivateDataSlot = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkPrivateDataSlot, mod.VkAllocationCallbacks)
mod.PFN_vkSetPrivateData = ffi.typeof([[$ (*)($ , $ , uint64_t , $ , uint64_t )]], mod.VkResult, mod.VkDevice, mod.VkObjectType, mod.VkPrivateDataSlot)
mod.PFN_vkGetPrivateData = ffi.typeof([[void (*)($ , $ , uint64_t , $ , uint64_t*)]], mod.VkDevice, mod.VkObjectType, mod.VkPrivateDataSlot)
mod.PFN_vkCmdPipelineBarrier2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDependencyInfo)
mod.PFN_vkCmdWriteTimestamp2 = ffi.typeof([[void (*)($ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkPipelineStageFlags2, mod.VkQueryPool)
mod.PFN_vkQueueSubmit2 = ffi.typeof([[$ (*)($ , uint32_t , const $*, $ )]], mod.VkResult, mod.VkQueue, mod.VkSubmitInfo2, mod.VkFence)
mod.PFN_vkCmdCopyBuffer2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyBufferInfo2)
mod.PFN_vkCmdCopyImage2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyImageInfo2)
mod.PFN_vkCmdCopyBufferToImage2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyBufferToImageInfo2)
mod.PFN_vkCmdCopyImageToBuffer2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyImageToBufferInfo2)
mod.PFN_vkGetDeviceBufferMemoryRequirements = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceBufferMemoryRequirements, mod.VkMemoryRequirements2)
mod.PFN_vkGetDeviceImageMemoryRequirements = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceImageMemoryRequirements, mod.VkMemoryRequirements2)
mod.PFN_vkGetDeviceImageSparseMemoryRequirements = ffi.typeof([[void (*)($ , const $*, uint32_t*, $*)]], mod.VkDevice, mod.VkDeviceImageMemoryRequirements, mod.VkSparseImageMemoryRequirements2)
mod.PFN_vkCmdSetEvent2 = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkCommandBuffer, mod.VkEvent, mod.VkDependencyInfo)
mod.PFN_vkCmdResetEvent2 = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags2)
mod.PFN_vkCmdWaitEvents2 = ffi.typeof([[void (*)($ , uint32_t , const $*, const $*)]], mod.VkCommandBuffer, mod.VkEvent, mod.VkDependencyInfo)
mod.PFN_vkCmdBlitImage2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBlitImageInfo2)
mod.PFN_vkCmdResolveImage2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkResolveImageInfo2)
mod.PFN_vkCmdBeginRendering = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingInfo)
mod.PFN_vkCmdEndRendering = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetCullMode = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCullModeFlags)
mod.PFN_vkCmdSetFrontFace = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkFrontFace)
mod.PFN_vkCmdSetPrimitiveTopology = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkPrimitiveTopology)
mod.PFN_vkCmdSetViewportWithCount = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkViewport)
mod.PFN_vkCmdSetScissorWithCount = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkRect2D)
mod.PFN_vkCmdBindVertexBuffers2 = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*, const $*, const $*, const $*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.PFN_vkCmdSetDepthTestEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthWriteEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthCompareOp = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCompareOp)
mod.PFN_vkCmdSetDepthBoundsTestEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetStencilTestEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetStencilOp = ffi.typeof([[void (*)($ , $ , $ , $ , $ , $ )]], mod.VkCommandBuffer, mod.VkStencilFaceFlags, mod.VkStencilOp, mod.VkStencilOp, mod.VkStencilOp, mod.VkCompareOp)
mod.PFN_vkCmdSetRasterizerDiscardEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthBiasEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetPrimitiveRestartEnable = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[$  vkGetPhysicalDeviceToolProperties($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceToolProperties)
ffi.cdef([[$  vkCreatePrivateDataSlot($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPrivateDataSlotCreateInfo, mod.VkAllocationCallbacks, mod.VkPrivateDataSlot)
ffi.cdef([[void  vkDestroyPrivateDataSlot($ , $ , const $*);]], mod.VkDevice, mod.VkPrivateDataSlot, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkSetPrivateData($ , $ , uint64_t , $ , uint64_t );]], mod.VkResult, mod.VkDevice, mod.VkObjectType, mod.VkPrivateDataSlot)
ffi.cdef([[void  vkGetPrivateData($ , $ , uint64_t , $ , uint64_t*);]], mod.VkDevice, mod.VkObjectType, mod.VkPrivateDataSlot)
ffi.cdef([[void  vkCmdPipelineBarrier2($ , const $*);]], mod.VkCommandBuffer, mod.VkDependencyInfo)
ffi.cdef([[void  vkCmdWriteTimestamp2($ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkPipelineStageFlags2, mod.VkQueryPool)
ffi.cdef([[$  vkQueueSubmit2($ , uint32_t , const $*, $ );]], mod.VkResult, mod.VkQueue, mod.VkSubmitInfo2, mod.VkFence)
ffi.cdef([[void  vkCmdCopyBuffer2($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyBufferInfo2)
ffi.cdef([[void  vkCmdCopyImage2($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyImageInfo2)
ffi.cdef([[void  vkCmdCopyBufferToImage2($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyBufferToImageInfo2)
ffi.cdef([[void  vkCmdCopyImageToBuffer2($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyImageToBufferInfo2)
ffi.cdef([[void  vkGetDeviceBufferMemoryRequirements($ , const $*, $*);]], mod.VkDevice, mod.VkDeviceBufferMemoryRequirements, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkGetDeviceImageMemoryRequirements($ , const $*, $*);]], mod.VkDevice, mod.VkDeviceImageMemoryRequirements, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkGetDeviceImageSparseMemoryRequirements($ , const $*, uint32_t*, $*);]], mod.VkDevice, mod.VkDeviceImageMemoryRequirements, mod.VkSparseImageMemoryRequirements2)
ffi.cdef([[void  vkCmdSetEvent2($ , $ , const $*);]], mod.VkCommandBuffer, mod.VkEvent, mod.VkDependencyInfo)
ffi.cdef([[void  vkCmdResetEvent2($ , $ , $ );]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags2)
ffi.cdef([[void  vkCmdWaitEvents2($ , uint32_t , const $*, const $*);]], mod.VkCommandBuffer, mod.VkEvent, mod.VkDependencyInfo)
ffi.cdef([[void  vkCmdBlitImage2($ , const $*);]], mod.VkCommandBuffer, mod.VkBlitImageInfo2)
ffi.cdef([[void  vkCmdResolveImage2($ , const $*);]], mod.VkCommandBuffer, mod.VkResolveImageInfo2)
ffi.cdef([[void  vkCmdBeginRendering($ , const $*);]], mod.VkCommandBuffer, mod.VkRenderingInfo)
ffi.cdef([[void  vkCmdEndRendering($ );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetCullMode($ , $ );]], mod.VkCommandBuffer, mod.VkCullModeFlags)
ffi.cdef([[void  vkCmdSetFrontFace($ , $ );]], mod.VkCommandBuffer, mod.VkFrontFace)
ffi.cdef([[void  vkCmdSetPrimitiveTopology($ , $ );]], mod.VkCommandBuffer, mod.VkPrimitiveTopology)
ffi.cdef([[void  vkCmdSetViewportWithCount($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkViewport)
ffi.cdef([[void  vkCmdSetScissorWithCount($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkRect2D)
ffi.cdef([[void  vkCmdBindVertexBuffers2($ , uint32_t , uint32_t , const $*, const $*, const $*, const $*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdSetDepthTestEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthWriteEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthCompareOp($ , $ );]], mod.VkCommandBuffer, mod.VkCompareOp)
ffi.cdef([[void  vkCmdSetDepthBoundsTestEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetStencilTestEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetStencilOp($ , $ , $ , $ , $ , $ );]], mod.VkCommandBuffer, mod.VkStencilFaceFlags, mod.VkStencilOp, mod.VkStencilOp, mod.VkStencilOp, mod.VkCompareOp)
ffi.cdef([[void  vkCmdSetRasterizerDiscardEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthBiasEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetPrimitiveRestartEnable($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
mod.VkPipelineRobustnessBufferBehavior = ffi.typeof([[enum {
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT = 0,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED = 1,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS = 2,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 = 3,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkPipelineRobustnessImageBehavior = ffi.typeof([[enum {
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT = 0,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED = 1,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS = 2,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2 = 3,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkQueueGlobalPriority = ffi.typeof([[enum {
	VK_QUEUE_GLOBAL_PRIORITY_LOW = 128,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024,
	VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
	VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = VK_QUEUE_GLOBAL_PRIORITY_LOW,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = VK_QUEUE_GLOBAL_PRIORITY_HIGH,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
	VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkLineRasterizationMode = ffi.typeof([[enum {
	VK_LINE_RASTERIZATION_MODE_DEFAULT = 0,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR = 1,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM = 2,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH = 3,
	VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = VK_LINE_RASTERIZATION_MODE_DEFAULT,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = VK_LINE_RASTERIZATION_MODE_BRESENHAM,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
	VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR = VK_LINE_RASTERIZATION_MODE_DEFAULT,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR = VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR = VK_LINE_RASTERIZATION_MODE_BRESENHAM,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
	VK_LINE_RASTERIZATION_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryUnmapFlagBits = ffi.typeof([[enum {
	VK_MEMORY_UNMAP_RESERVE_BIT_EXT = 0x00000001,
	VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkMemoryUnmapFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBufferUsageFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkBufferUsageFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT = 0x00000001ULL
mod.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT = 0x00000002ULL
mod.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004ULL
mod.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT = 0x00000008ULL
mod.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT = 0x00000010ULL
mod.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT = 0x00000020ULL
mod.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT = 0x00000040ULL
mod.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT = 0x00000080ULL
mod.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT = 0x00000100ULL
mod.VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT = 0x00020000ULL
mod.VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR = 0x00000001ULL
mod.VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR = 0x00000002ULL
mod.VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000004ULL
mod.VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000008ULL
mod.VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR = 0x00000010ULL
mod.VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR = 0x00000020ULL
mod.VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR = 0x00000040ULL
mod.VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR = 0x00000080ULL
mod.VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR = 0x00000100ULL
mod.VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200ULL
mod.VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400ULL
mod.VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV = 0x00000400ULL
mod.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800ULL
mod.VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000ULL
mod.VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000ULL
mod.VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR = 0x00004000ULL
mod.VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000ULL
mod.VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000ULL
mod.VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR = 0x00020000ULL
mod.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000ULL
mod.VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000ULL
mod.VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000ULL
mod.VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000ULL
mod.VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000ULL
mod.VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000ULL
mod.VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT = 0x01000000ULL
mod.VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM = 0x20000000ULL
mod.VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM = 0x08000000ULL
mod.VK_BUFFER_USAGE_2_MEMORY_DECOMPRESSION_BIT_EXT = 0x100000000ULL
mod.VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT = 0x80000000ULL
mod.VkHostImageCopyFlagBits = ffi.typeof([[enum {
	VK_HOST_IMAGE_COPY_MEMCPY_BIT = 0x00000001,
	VK_HOST_IMAGE_COPY_MEMCPY = VK_HOST_IMAGE_COPY_MEMCPY_BIT,
	VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT = VK_HOST_IMAGE_COPY_MEMCPY_BIT,
	VK_HOST_IMAGE_COPY_MEMCPY_EXT = VK_HOST_IMAGE_COPY_MEMCPY_BIT,
	VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.VkHostImageCopyFlags = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCreateFlags2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkPipelineCreateFlagBits2 = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT = 0x00000001ULL
mod.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT = 0x00000002ULL
mod.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT = 0x00000004ULL
mod.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008ULL
mod.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT = 0x00000010ULL
mod.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100ULL
mod.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200ULL
mod.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT = 0x08000000ULL
mod.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT = 0x40000000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR = 0x00001000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV = 0x200000000ULL
mod.VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x400000000ULL
mod.VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR = 0x00000001ULL
mod.VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR = 0x00000002ULL
mod.VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR = 0x00000004ULL
mod.VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 0x00000008ULL
mod.VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR = 0x00000010ULL
mod.VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV = 0x00000020ULL
mod.VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR = 0x00000040ULL
mod.VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080ULL
mod.VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR = 0x00000100ULL
mod.VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR = 0x00000200ULL
mod.VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400ULL
mod.VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000ULL
mod.VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR = 0x00000800ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000ULL
mod.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV = 0x00040000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000ULL
mod.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000ULL
mod.VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000ULL
mod.VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000ULL
mod.VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000ULL
mod.VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT = 0x08000000ULL
mod.VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000ULL
mod.VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000ULL
mod.VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000ULL
mod.VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM = 0x2000000000ULL
mod.VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR = 0x80000000ULL
mod.VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT = 0x4000000000ULL
mod.VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x10000000000ULL
mod.VK_PIPELINE_CREATE_2_64_BIT_INDEXING_BIT_EXT = 0x80000000000ULL
mod.VkPhysicalDeviceVulkan14Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ globalPriorityQuery;
	$ shaderSubgroupRotate;
	$ shaderSubgroupRotateClustered;
	$ shaderFloatControls2;
	$ shaderExpectAssume;
	$ rectangularLines;
	$ bresenhamLines;
	$ smoothLines;
	$ stippledRectangularLines;
	$ stippledBresenhamLines;
	$ stippledSmoothLines;
	$ vertexAttributeInstanceRateDivisor;
	$ vertexAttributeInstanceRateZeroDivisor;
	$ indexTypeUint8;
	$ dynamicRenderingLocalRead;
	$ maintenance5;
	$ maintenance6;
	$ pipelineProtectedAccess;
	$ pipelineRobustness;
	$ hostImageCopy;
	$ pushDescriptor;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceVulkan14Properties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t lineSubPixelPrecisionBits;
	uint32_t maxVertexAttribDivisor;
	$ supportsNonZeroFirstInstance;
	uint32_t maxPushDescriptors;
	$ dynamicRenderingLocalReadDepthStencilAttachments;
	$ dynamicRenderingLocalReadMultisampledAttachments;
	$ earlyFragmentMultisampleCoverageAfterSampleCounting;
	$ earlyFragmentSampleMaskTestBeforeSampleCounting;
	$ depthStencilSwizzleOneSupport;
	$ polygonModePointSize;
	$ nonStrictSinglePixelWideLinesUseParallelogram;
	$ nonStrictWideLinesUseParallelogram;
	$ blockTexelViewCompatibleMultipleLayers;
	uint32_t maxCombinedImageSamplerDescriptorCount;
	$ fragmentShadingRateClampCombinerInputs;
	$ defaultRobustnessStorageBuffers;
	$ defaultRobustnessUniformBuffers;
	$ defaultRobustnessVertexInputs;
	$ defaultRobustnessImages;
	uint32_t copySrcLayoutCount;
	$* pCopySrcLayouts;
	uint32_t copyDstLayoutCount;
	$* pCopyDstLayouts;
	uint8_t optimalTilingLayoutUUID[16U];
	$ identicalMemoryTypeRequirements;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessImageBehavior, mod.VkImageLayout, mod.VkImageLayout, mod.VkBool32)
mod.VkDeviceQueueGlobalPriorityCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ globalPriority;
}]], mod.VkStructureType, mod.VkQueueGlobalPriority)
mod.VkPhysicalDeviceGlobalPriorityQueryFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ globalPriorityQuery;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkQueueFamilyGlobalPriorityProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t priorityCount;
	$ priorities[16U];
}]], mod.VkStructureType, mod.VkQueueGlobalPriority)
mod.VkPhysicalDeviceIndexTypeUint8Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ indexTypeUint8;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkMemoryMapInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ memory;
	$ offset;
	$ size;
}]], mod.VkStructureType, mod.VkMemoryMapFlags, mod.VkDeviceMemory, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkMemoryUnmapInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ memory;
}]], mod.VkStructureType, mod.VkMemoryUnmapFlags, mod.VkDeviceMemory)
mod.VkPhysicalDeviceMaintenance5Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maintenance5;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMaintenance5Properties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ earlyFragmentMultisampleCoverageAfterSampleCounting;
	$ earlyFragmentSampleMaskTestBeforeSampleCounting;
	$ depthStencilSwizzleOneSupport;
	$ polygonModePointSize;
	$ nonStrictSinglePixelWideLinesUseParallelogram;
	$ nonStrictWideLinesUseParallelogram;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkImageSubresource2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageSubresource;
}]], mod.VkStructureType, mod.VkImageSubresource)
mod.VkDeviceImageSubresourceInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pCreateInfo;
	const $* pSubresource;
}]], mod.VkStructureType, mod.VkImageCreateInfo, mod.VkImageSubresource2)
mod.VkSubresourceLayout2 = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ subresourceLayout;
}]], mod.VkStructureType, mod.VkSubresourceLayout)
mod.VkBufferUsageFlags2CreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ usage;
}]], mod.VkStructureType, mod.VkBufferUsageFlags2)
mod.VkPhysicalDeviceMaintenance6Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maintenance6;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMaintenance6Properties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ blockTexelViewCompatibleMultipleLayers;
	uint32_t maxCombinedImageSamplerDescriptorCount;
	$ fragmentShadingRateClampCombinerInputs;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkBindMemoryStatus = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$* pResult;
}]], mod.VkStructureType, mod.VkResult)
mod.VkPhysicalDeviceHostImageCopyFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ hostImageCopy;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceHostImageCopyProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t copySrcLayoutCount;
	$* pCopySrcLayouts;
	uint32_t copyDstLayoutCount;
	$* pCopyDstLayouts;
	uint8_t optimalTilingLayoutUUID[16U];
	$ identicalMemoryTypeRequirements;
}]], mod.VkStructureType, mod.VkImageLayout, mod.VkImageLayout, mod.VkBool32)
mod.VkMemoryToImageCopy = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const void* pHostPointer;
	uint32_t memoryRowLength;
	uint32_t memoryImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]], mod.VkStructureType, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkImageToMemoryCopy = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	void* pHostPointer;
	uint32_t memoryRowLength;
	uint32_t memoryImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]], mod.VkStructureType, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkCopyMemoryToImageInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkHostImageCopyFlags, mod.VkImage, mod.VkImageLayout, mod.VkMemoryToImageCopy)
mod.VkCopyImageToMemoryInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ srcImage;
	$ srcImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkHostImageCopyFlags, mod.VkImage, mod.VkImageLayout, mod.VkImageToMemoryCopy)
mod.VkCopyImageToImageInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ srcImage;
	$ srcImageLayout;
	$ dstImage;
	$ dstImageLayout;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkHostImageCopyFlags, mod.VkImage, mod.VkImageLayout, mod.VkImage, mod.VkImageLayout, mod.VkImageCopy2)
mod.VkHostImageLayoutTransitionInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ oldLayout;
	$ newLayout;
	$ subresourceRange;
}]], mod.VkStructureType, mod.VkImage, mod.VkImageLayout, mod.VkImageLayout, mod.VkImageSubresourceRange)
mod.VkSubresourceHostMemcpySize = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ size;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkHostImageCopyDevicePerformanceQuery = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ optimalDeviceAccess;
	$ identicalMemoryLayout;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceShaderSubgroupRotateFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderSubgroupRotate;
	$ shaderSubgroupRotateClustered;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceShaderFloatControls2Features = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderFloatControls2;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderExpectAssumeFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderExpectAssume;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineCreateFlags2CreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkPipelineCreateFlags2)
mod.VkPhysicalDevicePushDescriptorProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxPushDescriptors;
}]], mod.VkStructureType)
mod.VkBindDescriptorSetsInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stageFlags;
	$ layout;
	uint32_t firstSet;
	uint32_t descriptorSetCount;
	const $* pDescriptorSets;
	uint32_t dynamicOffsetCount;
	const uint32_t* pDynamicOffsets;
}]], mod.VkStructureType, mod.VkShaderStageFlags, mod.VkPipelineLayout, mod.VkDescriptorSet)
mod.VkPushConstantsInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ layout;
	$ stageFlags;
	uint32_t offset;
	uint32_t size;
	const void* pValues;
}]], mod.VkStructureType, mod.VkPipelineLayout, mod.VkShaderStageFlags)
mod.VkPushDescriptorSetInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stageFlags;
	$ layout;
	uint32_t set;
	uint32_t descriptorWriteCount;
	const $* pDescriptorWrites;
}]], mod.VkStructureType, mod.VkShaderStageFlags, mod.VkPipelineLayout, mod.VkWriteDescriptorSet)
mod.VkPushDescriptorSetWithTemplateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ descriptorUpdateTemplate;
	$ layout;
	uint32_t set;
	const void* pData;
}]], mod.VkStructureType, mod.VkDescriptorUpdateTemplate, mod.VkPipelineLayout)
mod.VkPhysicalDevicePipelineProtectedAccessFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineProtectedAccess;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePipelineRobustnessFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineRobustness;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePipelineRobustnessProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ defaultRobustnessStorageBuffers;
	$ defaultRobustnessUniformBuffers;
	$ defaultRobustnessVertexInputs;
	$ defaultRobustnessImages;
}]], mod.VkStructureType, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessImageBehavior)
mod.VkPipelineRobustnessCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ storageBuffers;
	$ uniformBuffers;
	$ vertexInputs;
	$ images;
}]], mod.VkStructureType, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessBufferBehavior, mod.VkPipelineRobustnessImageBehavior)
mod.VkPhysicalDeviceLineRasterizationFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rectangularLines;
	$ bresenhamLines;
	$ smoothLines;
	$ stippledRectangularLines;
	$ stippledBresenhamLines;
	$ stippledSmoothLines;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceLineRasterizationProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t lineSubPixelPrecisionBits;
}]], mod.VkStructureType)
mod.VkPipelineRasterizationLineStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ lineRasterizationMode;
	$ stippledLineEnable;
	uint32_t lineStippleFactor;
	uint16_t lineStipplePattern;
}]], mod.VkStructureType, mod.VkLineRasterizationMode, mod.VkBool32)
mod.VkPhysicalDeviceVertexAttributeDivisorProperties = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxVertexAttribDivisor;
	$ supportsNonZeroFirstInstance;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVertexInputBindingDivisorDescription = ffi.typeof([[struct {
	uint32_t binding;
	uint32_t divisor;
}]])
mod.VkPipelineVertexInputDivisorStateCreateInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t vertexBindingDivisorCount;
	const $* pVertexBindingDivisors;
}]], mod.VkStructureType, mod.VkVertexInputBindingDivisorDescription)
mod.VkPhysicalDeviceVertexAttributeDivisorFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ vertexAttributeInstanceRateDivisor;
	$ vertexAttributeInstanceRateZeroDivisor;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkRenderingAreaInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t viewMask;
	uint32_t colorAttachmentCount;
	const $* pColorAttachmentFormats;
	$ depthAttachmentFormat;
	$ stencilAttachmentFormat;
}]], mod.VkStructureType, mod.VkFormat, mod.VkFormat, mod.VkFormat)
mod.VkPhysicalDeviceDynamicRenderingLocalReadFeatures = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ dynamicRenderingLocalRead;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkRenderingAttachmentLocationInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t colorAttachmentCount;
	const uint32_t* pColorAttachmentLocations;
}]], mod.VkStructureType)
mod.VkRenderingInputAttachmentIndexInfo = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t colorAttachmentCount;
	const uint32_t* pColorAttachmentInputIndices;
	const uint32_t* pDepthInputAttachmentIndex;
	const uint32_t* pStencilInputAttachmentIndex;
}]], mod.VkStructureType)
mod.PFN_vkMapMemory2 = ffi.typeof([[$ (*)($ , const $*, void**)]], mod.VkResult, mod.VkDevice, mod.VkMemoryMapInfo)
mod.PFN_vkUnmapMemory2 = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkMemoryUnmapInfo)
mod.PFN_vkGetDeviceImageSubresourceLayout = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceImageSubresourceInfo, mod.VkSubresourceLayout2)
mod.PFN_vkGetImageSubresourceLayout2 = ffi.typeof([[void (*)($ , $ , const $*, $*)]], mod.VkDevice, mod.VkImage, mod.VkImageSubresource2, mod.VkSubresourceLayout2)
mod.PFN_vkCopyMemoryToImage = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyMemoryToImageInfo)
mod.PFN_vkCopyImageToMemory = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToMemoryInfo)
mod.PFN_vkCopyImageToImage = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToImageInfo)
mod.PFN_vkTransitionImageLayout = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkHostImageLayoutTransitionInfo)
mod.PFN_vkCmdPushDescriptorSet = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout, mod.VkWriteDescriptorSet)
mod.PFN_vkCmdPushDescriptorSetWithTemplate = ffi.typeof([[void (*)($ , $ , $ , uint32_t , const void*)]], mod.VkCommandBuffer, mod.VkDescriptorUpdateTemplate, mod.VkPipelineLayout)
mod.PFN_vkCmdBindDescriptorSets2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBindDescriptorSetsInfo)
mod.PFN_vkCmdPushConstants2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushConstantsInfo)
mod.PFN_vkCmdPushDescriptorSet2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushDescriptorSetInfo)
mod.PFN_vkCmdPushDescriptorSetWithTemplate2 = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushDescriptorSetWithTemplateInfo)
mod.PFN_vkCmdSetLineStipple = ffi.typeof([[void (*)($ , uint32_t , uint16_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdBindIndexBuffer2 = ffi.typeof([[void (*)($ , $ , $ , $ , $ )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkIndexType)
mod.PFN_vkGetRenderingAreaGranularity = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkRenderingAreaInfo, mod.VkExtent2D)
mod.PFN_vkCmdSetRenderingAttachmentLocations = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingAttachmentLocationInfo)
mod.PFN_vkCmdSetRenderingInputAttachmentIndices = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingInputAttachmentIndexInfo)
ffi.cdef([[$  vkMapMemory2($ , const $*, void**);]], mod.VkResult, mod.VkDevice, mod.VkMemoryMapInfo)
ffi.cdef([[$  vkUnmapMemory2($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkMemoryUnmapInfo)
ffi.cdef([[void  vkGetDeviceImageSubresourceLayout($ , const $*, $*);]], mod.VkDevice, mod.VkDeviceImageSubresourceInfo, mod.VkSubresourceLayout2)
ffi.cdef([[void  vkGetImageSubresourceLayout2($ , $ , const $*, $*);]], mod.VkDevice, mod.VkImage, mod.VkImageSubresource2, mod.VkSubresourceLayout2)
ffi.cdef([[$  vkCopyMemoryToImage($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkCopyMemoryToImageInfo)
ffi.cdef([[$  vkCopyImageToMemory($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToMemoryInfo)
ffi.cdef([[$  vkCopyImageToImage($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToImageInfo)
ffi.cdef([[$  vkTransitionImageLayout($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkHostImageLayoutTransitionInfo)
ffi.cdef([[void  vkCmdPushDescriptorSet($ , $ , $ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout, mod.VkWriteDescriptorSet)
ffi.cdef([[void  vkCmdPushDescriptorSetWithTemplate($ , $ , $ , uint32_t , const void*);]], mod.VkCommandBuffer, mod.VkDescriptorUpdateTemplate, mod.VkPipelineLayout)
ffi.cdef([[void  vkCmdBindDescriptorSets2($ , const $*);]], mod.VkCommandBuffer, mod.VkBindDescriptorSetsInfo)
ffi.cdef([[void  vkCmdPushConstants2($ , const $*);]], mod.VkCommandBuffer, mod.VkPushConstantsInfo)
ffi.cdef([[void  vkCmdPushDescriptorSet2($ , const $*);]], mod.VkCommandBuffer, mod.VkPushDescriptorSetInfo)
ffi.cdef([[void  vkCmdPushDescriptorSetWithTemplate2($ , const $*);]], mod.VkCommandBuffer, mod.VkPushDescriptorSetWithTemplateInfo)
ffi.cdef([[void  vkCmdSetLineStipple($ , uint32_t , uint16_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdBindIndexBuffer2($ , $ , $ , $ , $ );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkIndexType)
ffi.cdef([[void  vkGetRenderingAreaGranularity($ , const $*, $*);]], mod.VkDevice, mod.VkRenderingAreaInfo, mod.VkExtent2D)
ffi.cdef([[void  vkCmdSetRenderingAttachmentLocations($ , const $*);]], mod.VkCommandBuffer, mod.VkRenderingAttachmentLocationInfo)
ffi.cdef([[void  vkCmdSetRenderingInputAttachmentIndices($ , const $*);]], mod.VkCommandBuffer, mod.VkRenderingInputAttachmentIndexInfo)
mod.VkSurfaceKHR = ffi.typeof([[void*]])
mod.VkPresentModeKHR = ffi.typeof([[enum {
	VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
	VK_PRESENT_MODE_MAILBOX_KHR = 1,
	VK_PRESENT_MODE_FIFO_KHR = 2,
	VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
	VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
	VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
	VK_PRESENT_MODE_FIFO_LATEST_READY_KHR = 1000361000,
	VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = VK_PRESENT_MODE_FIFO_LATEST_READY_KHR,
	VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkColorSpaceKHR = ffi.typeof([[enum {
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
	VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
	VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
	VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
	VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
	VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
	VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
	VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
	VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
	VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
	VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
	VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
	VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
	VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
	VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
	VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
	VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
	VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
	VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkSurfaceTransformFlagBitsKHR = ffi.typeof([[enum {
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
	VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCompositeAlphaFlagBitsKHR = ffi.typeof([[enum {
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
	VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCompositeAlphaFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSurfaceTransformFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSurfaceCapabilitiesKHR = ffi.typeof([[struct {
	uint32_t minImageCount;
	uint32_t maxImageCount;
	$ currentExtent;
	$ minImageExtent;
	$ maxImageExtent;
	uint32_t maxImageArrayLayers;
	$ supportedTransforms;
	$ currentTransform;
	$ supportedCompositeAlpha;
	$ supportedUsageFlags;
}]], mod.VkExtent2D, mod.VkExtent2D, mod.VkExtent2D, mod.VkSurfaceTransformFlagsKHR, mod.VkSurfaceTransformFlagBitsKHR, mod.VkCompositeAlphaFlagsKHR, mod.VkImageUsageFlags)
mod.VkSurfaceFormatKHR = ffi.typeof([[struct {
	$ format;
	$ colorSpace;
}]], mod.VkFormat, mod.VkColorSpaceKHR)
mod.PFN_vkDestroySurfaceKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkInstance, mod.VkSurfaceKHR, mod.VkAllocationCallbacks)
mod.PFN_vkGetPhysicalDeviceSurfaceSupportKHR = ffi.typeof([[$ (*)($ , uint32_t , $ , $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkBool32)
mod.PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = ffi.typeof([[$ (*)($ , $ , $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkSurfaceCapabilitiesKHR)
mod.PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkSurfaceFormatKHR)
mod.PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkPresentModeKHR)
ffi.cdef([[void  vkDestroySurfaceKHR($ , $ , const $*);]], mod.VkInstance, mod.VkSurfaceKHR, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkGetPhysicalDeviceSurfaceSupportKHR($ , uint32_t , $ , $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkBool32)
ffi.cdef([[$  vkGetPhysicalDeviceSurfaceCapabilitiesKHR($ , $ , $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkSurfaceCapabilitiesKHR)
ffi.cdef([[$  vkGetPhysicalDeviceSurfaceFormatsKHR($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkSurfaceFormatKHR)
ffi.cdef([[$  vkGetPhysicalDeviceSurfacePresentModesKHR($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkPresentModeKHR)
mod.VkSwapchainKHR = ffi.typeof([[void*]])
mod.VkSwapchainCreateFlagBitsKHR = ffi.typeof([[enum {
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001,
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002,
	VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004,
	VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR = 0x00000040,
	VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR = 0x00000080,
	VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR = 0x00000008,
	VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR,
	VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkSwapchainCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDeviceGroupPresentModeFlagBitsKHR = ffi.typeof([[enum {
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001,
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002,
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004,
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008,
	VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkDeviceGroupPresentModeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSwapchainCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ surface;
	uint32_t minImageCount;
	$ imageFormat;
	$ imageColorSpace;
	$ imageExtent;
	uint32_t imageArrayLayers;
	$ imageUsage;
	$ imageSharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
	$ preTransform;
	$ compositeAlpha;
	$ presentMode;
	$ clipped;
	$ oldSwapchain;
}]], mod.VkStructureType, mod.VkSwapchainCreateFlagsKHR, mod.VkSurfaceKHR, mod.VkFormat, mod.VkColorSpaceKHR, mod.VkExtent2D, mod.VkImageUsageFlags, mod.VkSharingMode, mod.VkSurfaceTransformFlagBitsKHR, mod.VkCompositeAlphaFlagBitsKHR, mod.VkPresentModeKHR, mod.VkBool32, mod.VkSwapchainKHR)
mod.VkPresentInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t waitSemaphoreCount;
	const $* pWaitSemaphores;
	uint32_t swapchainCount;
	const $* pSwapchains;
	const uint32_t* pImageIndices;
	$* pResults;
}]], mod.VkStructureType, mod.VkSemaphore, mod.VkSwapchainKHR, mod.VkResult)
mod.VkImageSwapchainCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ swapchain;
}]], mod.VkStructureType, mod.VkSwapchainKHR)
mod.VkBindImageMemorySwapchainInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ swapchain;
	uint32_t imageIndex;
}]], mod.VkStructureType, mod.VkSwapchainKHR)
mod.VkAcquireNextImageInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ swapchain;
	uint64_t timeout;
	$ semaphore;
	$ fence;
	uint32_t deviceMask;
}]], mod.VkStructureType, mod.VkSwapchainKHR, mod.VkSemaphore, mod.VkFence)
mod.VkDeviceGroupPresentCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t presentMask[32U];
	$ modes;
}]], mod.VkStructureType, mod.VkDeviceGroupPresentModeFlagsKHR)
mod.VkDeviceGroupPresentInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const uint32_t* pDeviceMasks;
	$ mode;
}]], mod.VkStructureType, mod.VkDeviceGroupPresentModeFlagBitsKHR)
mod.VkDeviceGroupSwapchainCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ modes;
}]], mod.VkStructureType, mod.VkDeviceGroupPresentModeFlagsKHR)
mod.PFN_vkCreateSwapchainKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSwapchainKHR)
mod.PFN_vkDestroySwapchainKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkAllocationCallbacks)
mod.PFN_vkGetSwapchainImagesKHR = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkImage)
mod.PFN_vkAcquireNextImageKHR = ffi.typeof([[$ (*)($ , $ , uint64_t , $ , $ , uint32_t*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkSemaphore, mod.VkFence)
mod.PFN_vkQueuePresentKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkQueue, mod.VkPresentInfoKHR)
mod.PFN_vkGetDeviceGroupPresentCapabilitiesKHR = ffi.typeof([[$ (*)($ , $*)]], mod.VkResult, mod.VkDevice, mod.VkDeviceGroupPresentCapabilitiesKHR)
mod.PFN_vkGetDeviceGroupSurfacePresentModesKHR = ffi.typeof([[$ (*)($ , $ , $*)]], mod.VkResult, mod.VkDevice, mod.VkSurfaceKHR, mod.VkDeviceGroupPresentModeFlagsKHR)
mod.PFN_vkGetPhysicalDevicePresentRectanglesKHR = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkRect2D)
mod.PFN_vkAcquireNextImage2KHR = ffi.typeof([[$ (*)($ , const $*, uint32_t*)]], mod.VkResult, mod.VkDevice, mod.VkAcquireNextImageInfoKHR)
ffi.cdef([[$  vkCreateSwapchainKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSwapchainKHR)
ffi.cdef([[void  vkDestroySwapchainKHR($ , $ , const $*);]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkGetSwapchainImagesKHR($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkImage)
ffi.cdef([[$  vkAcquireNextImageKHR($ , $ , uint64_t , $ , $ , uint32_t*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkSemaphore, mod.VkFence)
ffi.cdef([[$  vkQueuePresentKHR($ , const $*);]], mod.VkResult, mod.VkQueue, mod.VkPresentInfoKHR)
ffi.cdef([[$  vkGetDeviceGroupPresentCapabilitiesKHR($ , $*);]], mod.VkResult, mod.VkDevice, mod.VkDeviceGroupPresentCapabilitiesKHR)
ffi.cdef([[$  vkGetDeviceGroupSurfacePresentModesKHR($ , $ , $*);]], mod.VkResult, mod.VkDevice, mod.VkSurfaceKHR, mod.VkDeviceGroupPresentModeFlagsKHR)
ffi.cdef([[$  vkGetPhysicalDevicePresentRectanglesKHR($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkRect2D)
ffi.cdef([[$  vkAcquireNextImage2KHR($ , const $*, uint32_t*);]], mod.VkResult, mod.VkDevice, mod.VkAcquireNextImageInfoKHR)
mod.VkDisplayKHR = ffi.typeof([[void*]])
mod.VkDisplayModeKHR = ffi.typeof([[void*]])
mod.VkDisplayModeCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDisplayPlaneAlphaFlagBitsKHR = ffi.typeof([[enum {
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
	VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkDisplayPlaneAlphaFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDisplaySurfaceCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDisplayModeParametersKHR = ffi.typeof([[struct {
	$ visibleRegion;
	uint32_t refreshRate;
}]], mod.VkExtent2D)
mod.VkDisplayModeCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ parameters;
}]], mod.VkStructureType, mod.VkDisplayModeCreateFlagsKHR, mod.VkDisplayModeParametersKHR)
mod.VkDisplayModePropertiesKHR = ffi.typeof([[struct {
	$ displayMode;
	$ parameters;
}]], mod.VkDisplayModeKHR, mod.VkDisplayModeParametersKHR)
mod.VkDisplayPlaneCapabilitiesKHR = ffi.typeof([[struct {
	$ supportedAlpha;
	$ minSrcPosition;
	$ maxSrcPosition;
	$ minSrcExtent;
	$ maxSrcExtent;
	$ minDstPosition;
	$ maxDstPosition;
	$ minDstExtent;
	$ maxDstExtent;
}]], mod.VkDisplayPlaneAlphaFlagsKHR, mod.VkOffset2D, mod.VkOffset2D, mod.VkExtent2D, mod.VkExtent2D, mod.VkOffset2D, mod.VkOffset2D, mod.VkExtent2D, mod.VkExtent2D)
mod.VkDisplayPlanePropertiesKHR = ffi.typeof([[struct {
	$ currentDisplay;
	uint32_t currentStackIndex;
}]], mod.VkDisplayKHR)
mod.VkDisplayPropertiesKHR = ffi.typeof([[struct {
	$ display;
	const char* displayName;
	$ physicalDimensions;
	$ physicalResolution;
	$ supportedTransforms;
	$ planeReorderPossible;
	$ persistentContent;
}]], mod.VkDisplayKHR, mod.VkExtent2D, mod.VkExtent2D, mod.VkSurfaceTransformFlagsKHR, mod.VkBool32, mod.VkBool32)
mod.VkDisplaySurfaceCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ displayMode;
	uint32_t planeIndex;
	uint32_t planeStackIndex;
	$ transform;
	float globalAlpha;
	$ alphaMode;
	$ imageExtent;
}]], mod.VkStructureType, mod.VkDisplaySurfaceCreateFlagsKHR, mod.VkDisplayModeKHR, mod.VkSurfaceTransformFlagBitsKHR, mod.VkDisplayPlaneAlphaFlagBitsKHR, mod.VkExtent2D)
mod.PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayPropertiesKHR)
mod.PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayPlanePropertiesKHR)
mod.PFN_vkGetDisplayPlaneSupportedDisplaysKHR = ffi.typeof([[$ (*)($ , uint32_t , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
mod.PFN_vkGetDisplayModePropertiesKHR = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR, mod.VkDisplayModePropertiesKHR)
mod.PFN_vkCreateDisplayModeKHR = ffi.typeof([[$ (*)($ , $ , const $*, const $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR, mod.VkDisplayModeCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkDisplayModeKHR)
mod.PFN_vkGetDisplayPlaneCapabilitiesKHR = ffi.typeof([[$ (*)($ , $ , uint32_t , $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayModeKHR, mod.VkDisplayPlaneCapabilitiesKHR)
mod.PFN_vkCreateDisplayPlaneSurfaceKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkDisplaySurfaceCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkGetPhysicalDeviceDisplayPropertiesKHR($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayPropertiesKHR)
ffi.cdef([[$  vkGetPhysicalDeviceDisplayPlanePropertiesKHR($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayPlanePropertiesKHR)
ffi.cdef([[$  vkGetDisplayPlaneSupportedDisplaysKHR($ , uint32_t , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
ffi.cdef([[$  vkGetDisplayModePropertiesKHR($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR, mod.VkDisplayModePropertiesKHR)
ffi.cdef([[$  vkCreateDisplayModeKHR($ , $ , const $*, const $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR, mod.VkDisplayModeCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkDisplayModeKHR)
ffi.cdef([[$  vkGetDisplayPlaneCapabilitiesKHR($ , $ , uint32_t , $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayModeKHR, mod.VkDisplayPlaneCapabilitiesKHR)
ffi.cdef([[$  vkCreateDisplayPlaneSurfaceKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkDisplaySurfaceCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.VkDisplayPresentInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcRect;
	$ dstRect;
	$ persistent;
}]], mod.VkStructureType, mod.VkRect2D, mod.VkRect2D, mod.VkBool32)
mod.PFN_vkCreateSharedSwapchainsKHR = ffi.typeof([[$ (*)($ , uint32_t , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSwapchainKHR)
ffi.cdef([[$  vkCreateSharedSwapchainsKHR($ , uint32_t , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSwapchainKHR)
mod.VkVideoSessionKHR = ffi.typeof([[void*]])
mod.VkVideoSessionParametersKHR = ffi.typeof([[void*]])
mod.VkQueryResultStatusKHR = ffi.typeof([[enum {
	VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
	VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
	VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
	VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR = -1000299000,
	VK_QUERY_RESULT_STATUS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoCodecOperationFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_CODEC_OPERATION_NONE_KHR = 0,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR = 0x00010000,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR = 0x00020000,
	VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = 0x00000001,
	VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = 0x00000002,
	VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR = 0x00000004,
	VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR = 0x00040000,
	VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR = 0x00000008,
	VK_VIDEO_CODEC_OPERATION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoCodecOperationFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoChromaSubsamplingFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0,
	VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 0x00000001,
	VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 0x00000002,
	VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 0x00000004,
	VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 0x00000008,
	VK_VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoChromaSubsamplingFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoComponentBitDepthFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
	VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 0x00000001,
	VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 0x00000004,
	VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 0x00000010,
	VK_VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoComponentBitDepthFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoCapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
	VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 0x00000002,
	VK_VIDEO_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoCapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoSessionCreateFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = 0x00000002,
	VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR = 0x00000004,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000008,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x00000010,
	VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR = 0x00000020,
	VK_VIDEO_SESSION_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoSessionCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoSessionParametersCreateFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR = 0x00000001,
	VK_VIDEO_SESSION_PARAMETERS_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoSessionParametersCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoBeginCodingFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEndCodingFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoCodingControlFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 0x00000001,
	VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 0x00000002,
	VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR = 0x00000004,
	VK_VIDEO_CODING_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoCodingControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkQueueFamilyQueryResultStatusPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ queryResultStatusSupport;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkQueueFamilyVideoPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ videoCodecOperations;
}]], mod.VkStructureType, mod.VkVideoCodecOperationFlagsKHR)
mod.VkVideoProfileInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ videoCodecOperation;
	$ chromaSubsampling;
	$ lumaBitDepth;
	$ chromaBitDepth;
}]], mod.VkStructureType, mod.VkVideoCodecOperationFlagBitsKHR, mod.VkVideoChromaSubsamplingFlagsKHR, mod.VkVideoComponentBitDepthFlagsKHR, mod.VkVideoComponentBitDepthFlagsKHR)
mod.VkVideoProfileListInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t profileCount;
	const $* pProfiles;
}]], mod.VkStructureType, mod.VkVideoProfileInfoKHR)
mod.VkVideoCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ minBitstreamBufferOffsetAlignment;
	$ minBitstreamBufferSizeAlignment;
	$ pictureAccessGranularity;
	$ minCodedExtent;
	$ maxCodedExtent;
	uint32_t maxDpbSlots;
	uint32_t maxActiveReferencePictures;
	$ stdHeaderVersion;
}]], mod.VkStructureType, mod.VkVideoCapabilityFlagsKHR, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkExtent2D, mod.VkExtent2D, mod.VkExtent2D, mod.VkExtensionProperties)
mod.VkPhysicalDeviceVideoFormatInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ imageUsage;
}]], mod.VkStructureType, mod.VkImageUsageFlags)
mod.VkVideoFormatPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ format;
	$ componentMapping;
	$ imageCreateFlags;
	$ imageType;
	$ imageTiling;
	$ imageUsageFlags;
}]], mod.VkStructureType, mod.VkFormat, mod.VkComponentMapping, mod.VkImageCreateFlags, mod.VkImageType, mod.VkImageTiling, mod.VkImageUsageFlags)
mod.VkVideoPictureResourceInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ codedOffset;
	$ codedExtent;
	uint32_t baseArrayLayer;
	$ imageViewBinding;
}]], mod.VkStructureType, mod.VkOffset2D, mod.VkExtent2D, mod.VkImageView)
mod.VkVideoReferenceSlotInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	int32_t slotIndex;
	const $* pPictureResource;
}]], mod.VkStructureType, mod.VkVideoPictureResourceInfoKHR)
mod.VkVideoSessionMemoryRequirementsKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t memoryBindIndex;
	$ memoryRequirements;
}]], mod.VkStructureType, mod.VkMemoryRequirements)
mod.VkBindVideoSessionMemoryInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t memoryBindIndex;
	$ memory;
	$ memoryOffset;
	$ memorySize;
}]], mod.VkStructureType, mod.VkDeviceMemory, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkVideoSessionCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t queueFamilyIndex;
	$ flags;
	const $* pVideoProfile;
	$ pictureFormat;
	$ maxCodedExtent;
	$ referencePictureFormat;
	uint32_t maxDpbSlots;
	uint32_t maxActiveReferencePictures;
	const $* pStdHeaderVersion;
}]], mod.VkStructureType, mod.VkVideoSessionCreateFlagsKHR, mod.VkVideoProfileInfoKHR, mod.VkFormat, mod.VkExtent2D, mod.VkFormat, mod.VkExtensionProperties)
mod.VkVideoSessionParametersCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ videoSessionParametersTemplate;
	$ videoSession;
}]], mod.VkStructureType, mod.VkVideoSessionParametersCreateFlagsKHR, mod.VkVideoSessionParametersKHR, mod.VkVideoSessionKHR)
mod.VkVideoSessionParametersUpdateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t updateSequenceCount;
}]], mod.VkStructureType)
mod.VkVideoBeginCodingInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ videoSession;
	$ videoSessionParameters;
	uint32_t referenceSlotCount;
	const $* pReferenceSlots;
}]], mod.VkStructureType, mod.VkVideoBeginCodingFlagsKHR, mod.VkVideoSessionKHR, mod.VkVideoSessionParametersKHR, mod.VkVideoReferenceSlotInfoKHR)
mod.VkVideoEndCodingInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkVideoEndCodingFlagsKHR)
mod.VkVideoCodingControlInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkVideoCodingControlFlagsKHR)
mod.PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkVideoProfileInfoKHR, mod.VkVideoCapabilitiesKHR)
mod.PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR = ffi.typeof([[$ (*)($ , const $*, uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceVideoFormatInfoKHR, mod.VkVideoFormatPropertiesKHR)
mod.PFN_vkCreateVideoSessionKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkVideoSessionKHR)
mod.PFN_vkDestroyVideoSessionKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkVideoSessionKHR, mod.VkAllocationCallbacks)
mod.PFN_vkGetVideoSessionMemoryRequirementsKHR = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionKHR, mod.VkVideoSessionMemoryRequirementsKHR)
mod.PFN_vkBindVideoSessionMemoryKHR = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionKHR, mod.VkBindVideoSessionMemoryInfoKHR)
mod.PFN_vkCreateVideoSessionParametersKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionParametersCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkVideoSessionParametersKHR)
mod.PFN_vkUpdateVideoSessionParametersKHR = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionParametersKHR, mod.VkVideoSessionParametersUpdateInfoKHR)
mod.PFN_vkDestroyVideoSessionParametersKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkVideoSessionParametersKHR, mod.VkAllocationCallbacks)
mod.PFN_vkCmdBeginVideoCodingKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoBeginCodingInfoKHR)
mod.PFN_vkCmdEndVideoCodingKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoEndCodingInfoKHR)
mod.PFN_vkCmdControlVideoCodingKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoCodingControlInfoKHR)
ffi.cdef([[$  vkGetPhysicalDeviceVideoCapabilitiesKHR($ , const $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkVideoProfileInfoKHR, mod.VkVideoCapabilitiesKHR)
ffi.cdef([[$  vkGetPhysicalDeviceVideoFormatPropertiesKHR($ , const $*, uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceVideoFormatInfoKHR, mod.VkVideoFormatPropertiesKHR)
ffi.cdef([[$  vkCreateVideoSessionKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkVideoSessionKHR)
ffi.cdef([[void  vkDestroyVideoSessionKHR($ , $ , const $*);]], mod.VkDevice, mod.VkVideoSessionKHR, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkGetVideoSessionMemoryRequirementsKHR($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionKHR, mod.VkVideoSessionMemoryRequirementsKHR)
ffi.cdef([[$  vkBindVideoSessionMemoryKHR($ , $ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionKHR, mod.VkBindVideoSessionMemoryInfoKHR)
ffi.cdef([[$  vkCreateVideoSessionParametersKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionParametersCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkVideoSessionParametersKHR)
ffi.cdef([[$  vkUpdateVideoSessionParametersKHR($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkVideoSessionParametersKHR, mod.VkVideoSessionParametersUpdateInfoKHR)
ffi.cdef([[void  vkDestroyVideoSessionParametersKHR($ , $ , const $*);]], mod.VkDevice, mod.VkVideoSessionParametersKHR, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkCmdBeginVideoCodingKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkVideoBeginCodingInfoKHR)
ffi.cdef([[void  vkCmdEndVideoCodingKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkVideoEndCodingInfoKHR)
ffi.cdef([[void  vkCmdControlVideoCodingKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkVideoCodingControlInfoKHR)
mod.VkVideoDecodeCapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoDecodeCapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoDecodeUsageFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_DECODE_USAGE_DEFAULT_KHR = 0,
	VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 0x00000004,
	VK_VIDEO_DECODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoDecodeUsageFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoDecodeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoDecodeCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkVideoDecodeCapabilityFlagsKHR)
mod.VkVideoDecodeUsageInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ videoUsageHints;
}]], mod.VkStructureType, mod.VkVideoDecodeUsageFlagsKHR)
mod.VkVideoDecodeInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ srcBuffer;
	$ srcBufferOffset;
	$ srcBufferRange;
	$ dstPictureResource;
	const $* pSetupReferenceSlot;
	uint32_t referenceSlotCount;
	const $* pReferenceSlots;
}]], mod.VkStructureType, mod.VkVideoDecodeFlagsKHR, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkVideoPictureResourceInfoKHR, mod.VkVideoReferenceSlotInfoKHR, mod.VkVideoReferenceSlotInfoKHR)
mod.PFN_vkCmdDecodeVideoKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoDecodeInfoKHR)
ffi.cdef([[void  vkCmdDecodeVideoKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkVideoDecodeInfoKHR)
mod.StdVideoH264ChromaFormatIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME = 0,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_420 = 1,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_422 = 2,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_444 = 3,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264ProfileIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_PROFILE_IDC_BASELINE = 66,
	STD_VIDEO_H264_PROFILE_IDC_MAIN = 77,
	STD_VIDEO_H264_PROFILE_IDC_HIGH = 100,
	STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE = 244,
	STD_VIDEO_H264_PROFILE_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_PROFILE_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264LevelIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_LEVEL_IDC_1_0 = 0,
	STD_VIDEO_H264_LEVEL_IDC_1_1 = 1,
	STD_VIDEO_H264_LEVEL_IDC_1_2 = 2,
	STD_VIDEO_H264_LEVEL_IDC_1_3 = 3,
	STD_VIDEO_H264_LEVEL_IDC_2_0 = 4,
	STD_VIDEO_H264_LEVEL_IDC_2_1 = 5,
	STD_VIDEO_H264_LEVEL_IDC_2_2 = 6,
	STD_VIDEO_H264_LEVEL_IDC_3_0 = 7,
	STD_VIDEO_H264_LEVEL_IDC_3_1 = 8,
	STD_VIDEO_H264_LEVEL_IDC_3_2 = 9,
	STD_VIDEO_H264_LEVEL_IDC_4_0 = 10,
	STD_VIDEO_H264_LEVEL_IDC_4_1 = 11,
	STD_VIDEO_H264_LEVEL_IDC_4_2 = 12,
	STD_VIDEO_H264_LEVEL_IDC_5_0 = 13,
	STD_VIDEO_H264_LEVEL_IDC_5_1 = 14,
	STD_VIDEO_H264_LEVEL_IDC_5_2 = 15,
	STD_VIDEO_H264_LEVEL_IDC_6_0 = 16,
	STD_VIDEO_H264_LEVEL_IDC_6_1 = 17,
	STD_VIDEO_H264_LEVEL_IDC_6_2 = 18,
	STD_VIDEO_H264_LEVEL_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_LEVEL_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264PocType = ffi.typeof([[enum {
	STD_VIDEO_H264_POC_TYPE_0 = 0,
	STD_VIDEO_H264_POC_TYPE_1 = 1,
	STD_VIDEO_H264_POC_TYPE_2 = 2,
	STD_VIDEO_H264_POC_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_POC_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264AspectRatioIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE = 1,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11 = 2,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11 = 3,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11 = 4,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33 = 5,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11 = 6,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11 = 7,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11 = 8,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33 = 9,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11 = 10,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11 = 11,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33 = 12,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99 = 13,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3 = 14,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2 = 15,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1 = 16,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264WeightedBipredIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT = 0,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT = 1,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT = 2,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264ModificationOfPicNumsIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT = 0,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD = 1,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM = 2,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END = 3,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264MemMgmtControlOp = ffi.typeof([[enum {
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END = 0,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM = 1,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM = 2,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM = 3,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX = 4,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL = 5,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM = 6,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264CabacInitIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_CABAC_INIT_IDC_0 = 0,
	STD_VIDEO_H264_CABAC_INIT_IDC_1 = 1,
	STD_VIDEO_H264_CABAC_INIT_IDC_2 = 2,
	STD_VIDEO_H264_CABAC_INIT_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_CABAC_INIT_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264DisableDeblockingFilterIdc = ffi.typeof([[enum {
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED = 0,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED = 1,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL = 2,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264SliceType = ffi.typeof([[enum {
	STD_VIDEO_H264_SLICE_TYPE_P = 0,
	STD_VIDEO_H264_SLICE_TYPE_B = 1,
	STD_VIDEO_H264_SLICE_TYPE_I = 2,
	STD_VIDEO_H264_SLICE_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_SLICE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264PictureType = ffi.typeof([[enum {
	STD_VIDEO_H264_PICTURE_TYPE_P = 0,
	STD_VIDEO_H264_PICTURE_TYPE_B = 1,
	STD_VIDEO_H264_PICTURE_TYPE_I = 2,
	STD_VIDEO_H264_PICTURE_TYPE_IDR = 5,
	STD_VIDEO_H264_PICTURE_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_PICTURE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264NonVclNaluType = ffi.typeof([[enum {
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS = 0,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS = 1,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD = 2,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX = 3,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE = 4,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM = 5,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED = 6,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH264SpsVuiFlags = ffi.typeof([[struct {
	uint32_t aspect_ratio_info_present_flag;
	uint32_t overscan_info_present_flag;
	uint32_t overscan_appropriate_flag;
	uint32_t video_signal_type_present_flag;
	uint32_t video_full_range_flag;
	uint32_t color_description_present_flag;
	uint32_t chroma_loc_info_present_flag;
	uint32_t timing_info_present_flag;
	uint32_t fixed_frame_rate_flag;
	uint32_t bitstream_restriction_flag;
	uint32_t nal_hrd_parameters_present_flag;
	uint32_t vcl_hrd_parameters_present_flag;
}]])
mod.StdVideoH264HrdParameters = ffi.typeof([[struct {
	uint8_t cpb_cnt_minus1;
	uint8_t bit_rate_scale;
	uint8_t cpb_size_scale;
	uint8_t reserved1;
	uint32_t bit_rate_value_minus1[32U];
	uint32_t cpb_size_value_minus1[32U];
	uint8_t cbr_flag[32U];
	uint32_t initial_cpb_removal_delay_length_minus1;
	uint32_t cpb_removal_delay_length_minus1;
	uint32_t dpb_output_delay_length_minus1;
	uint32_t time_offset_length;
}]])
mod.StdVideoH264SequenceParameterSetVui = ffi.typeof([[struct {
	$ flags;
	$ aspect_ratio_idc;
	uint16_t sar_width;
	uint16_t sar_height;
	uint8_t video_format;
	uint8_t colour_primaries;
	uint8_t transfer_characteristics;
	uint8_t matrix_coefficients;
	uint32_t num_units_in_tick;
	uint32_t time_scale;
	uint8_t max_num_reorder_frames;
	uint8_t max_dec_frame_buffering;
	uint8_t chroma_sample_loc_type_top_field;
	uint8_t chroma_sample_loc_type_bottom_field;
	uint32_t reserved1;
	const $* pHrdParameters;
}]], mod.StdVideoH264SpsVuiFlags, mod.StdVideoH264AspectRatioIdc, mod.StdVideoH264HrdParameters)
mod.StdVideoH264SpsFlags = ffi.typeof([[struct {
	uint32_t constraint_set0_flag;
	uint32_t constraint_set1_flag;
	uint32_t constraint_set2_flag;
	uint32_t constraint_set3_flag;
	uint32_t constraint_set4_flag;
	uint32_t constraint_set5_flag;
	uint32_t direct_8x8_inference_flag;
	uint32_t mb_adaptive_frame_field_flag;
	uint32_t frame_mbs_only_flag;
	uint32_t delta_pic_order_always_zero_flag;
	uint32_t separate_colour_plane_flag;
	uint32_t gaps_in_frame_num_value_allowed_flag;
	uint32_t qpprime_y_zero_transform_bypass_flag;
	uint32_t frame_cropping_flag;
	uint32_t seq_scaling_matrix_present_flag;
	uint32_t vui_parameters_present_flag;
}]])
mod.StdVideoH264ScalingLists = ffi.typeof([[struct {
	uint16_t scaling_list_present_mask;
	uint16_t use_default_scaling_matrix_mask;
	uint8_t ScalingList4x4[16U][6U];
	uint8_t ScalingList8x8[64U][6U];
}]])
mod.StdVideoH264SequenceParameterSet = ffi.typeof([[struct {
	$ flags;
	$ profile_idc;
	$ level_idc;
	$ chroma_format_idc;
	uint8_t seq_parameter_set_id;
	uint8_t bit_depth_luma_minus8;
	uint8_t bit_depth_chroma_minus8;
	uint8_t log2_max_frame_num_minus4;
	$ pic_order_cnt_type;
	int32_t offset_for_non_ref_pic;
	int32_t offset_for_top_to_bottom_field;
	uint8_t log2_max_pic_order_cnt_lsb_minus4;
	uint8_t num_ref_frames_in_pic_order_cnt_cycle;
	uint8_t max_num_ref_frames;
	uint8_t reserved1;
	uint32_t pic_width_in_mbs_minus1;
	uint32_t pic_height_in_map_units_minus1;
	uint32_t frame_crop_left_offset;
	uint32_t frame_crop_right_offset;
	uint32_t frame_crop_top_offset;
	uint32_t frame_crop_bottom_offset;
	uint32_t reserved2;
	const int32_t* pOffsetForRefFrame;
	const $* pScalingLists;
	const $* pSequenceParameterSetVui;
}]], mod.StdVideoH264SpsFlags, mod.StdVideoH264ProfileIdc, mod.StdVideoH264LevelIdc, mod.StdVideoH264ChromaFormatIdc, mod.StdVideoH264PocType, mod.StdVideoH264ScalingLists, mod.StdVideoH264SequenceParameterSetVui)
mod.StdVideoH264PpsFlags = ffi.typeof([[struct {
	uint32_t transform_8x8_mode_flag;
	uint32_t redundant_pic_cnt_present_flag;
	uint32_t constrained_intra_pred_flag;
	uint32_t deblocking_filter_control_present_flag;
	uint32_t weighted_pred_flag;
	uint32_t bottom_field_pic_order_in_frame_present_flag;
	uint32_t entropy_coding_mode_flag;
	uint32_t pic_scaling_matrix_present_flag;
}]])
mod.StdVideoH264PictureParameterSet = ffi.typeof([[struct {
	$ flags;
	uint8_t seq_parameter_set_id;
	uint8_t pic_parameter_set_id;
	uint8_t num_ref_idx_l0_default_active_minus1;
	uint8_t num_ref_idx_l1_default_active_minus1;
	$ weighted_bipred_idc;
	int8_t pic_init_qp_minus26;
	int8_t pic_init_qs_minus26;
	int8_t chroma_qp_index_offset;
	int8_t second_chroma_qp_index_offset;
	const $* pScalingLists;
}]], mod.StdVideoH264PpsFlags, mod.StdVideoH264WeightedBipredIdc, mod.StdVideoH264ScalingLists)
mod.StdVideoEncodeH264WeightTableFlags = ffi.typeof([[struct {
	uint32_t luma_weight_l0_flag;
	uint32_t chroma_weight_l0_flag;
	uint32_t luma_weight_l1_flag;
	uint32_t chroma_weight_l1_flag;
}]])
mod.StdVideoEncodeH264WeightTable = ffi.typeof([[struct {
	$ flags;
	uint8_t luma_log2_weight_denom;
	uint8_t chroma_log2_weight_denom;
	int8_t luma_weight_l0[32U];
	int8_t luma_offset_l0[32U];
	int8_t chroma_weight_l0[2U][32U];
	int8_t chroma_offset_l0[2U][32U];
	int8_t luma_weight_l1[32U];
	int8_t luma_offset_l1[32U];
	int8_t chroma_weight_l1[2U][32U];
	int8_t chroma_offset_l1[2U][32U];
}]], mod.StdVideoEncodeH264WeightTableFlags)
mod.StdVideoEncodeH264SliceHeaderFlags = ffi.typeof([[struct {
	uint32_t direct_spatial_mv_pred_flag;
	uint32_t num_ref_idx_active_override_flag;
	uint32_t reserved;
}]])
mod.StdVideoEncodeH264PictureInfoFlags = ffi.typeof([[struct {
	uint32_t IdrPicFlag;
	uint32_t is_reference;
	uint32_t no_output_of_prior_pics_flag;
	uint32_t long_term_reference_flag;
	uint32_t adaptive_ref_pic_marking_mode_flag;
	uint32_t reserved;
}]])
mod.StdVideoEncodeH264ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t used_for_long_term_reference;
	uint32_t reserved;
}]])
mod.StdVideoEncodeH264ReferenceListsInfoFlags = ffi.typeof([[struct {
	uint32_t ref_pic_list_modification_flag_l0;
	uint32_t ref_pic_list_modification_flag_l1;
	uint32_t reserved;
}]])
mod.StdVideoEncodeH264RefListModEntry = ffi.typeof([[struct {
	$ modification_of_pic_nums_idc;
	uint16_t abs_diff_pic_num_minus1;
	uint16_t long_term_pic_num;
}]], mod.StdVideoH264ModificationOfPicNumsIdc)
mod.StdVideoEncodeH264RefPicMarkingEntry = ffi.typeof([[struct {
	$ memory_management_control_operation;
	uint16_t difference_of_pic_nums_minus1;
	uint16_t long_term_pic_num;
	uint16_t long_term_frame_idx;
	uint16_t max_long_term_frame_idx_plus1;
}]], mod.StdVideoH264MemMgmtControlOp)
mod.StdVideoEncodeH264ReferenceListsInfo = ffi.typeof([[struct {
	$ flags;
	uint8_t num_ref_idx_l0_active_minus1;
	uint8_t num_ref_idx_l1_active_minus1;
	uint8_t RefPicList0[32U];
	uint8_t RefPicList1[32U];
	uint8_t refList0ModOpCount;
	uint8_t refList1ModOpCount;
	uint8_t refPicMarkingOpCount;
	uint8_t reserved1[7];
	const $* pRefList0ModOperations;
	const $* pRefList1ModOperations;
	const $* pRefPicMarkingOperations;
}]], mod.StdVideoEncodeH264ReferenceListsInfoFlags, mod.StdVideoEncodeH264RefListModEntry, mod.StdVideoEncodeH264RefListModEntry, mod.StdVideoEncodeH264RefPicMarkingEntry)
mod.StdVideoEncodeH264PictureInfo = ffi.typeof([[struct {
	$ flags;
	uint8_t seq_parameter_set_id;
	uint8_t pic_parameter_set_id;
	uint16_t idr_pic_id;
	$ primary_pic_type;
	uint32_t frame_num;
	int32_t PicOrderCnt;
	uint8_t temporal_id;
	uint8_t reserved1[3];
	const $* pRefLists;
}]], mod.StdVideoEncodeH264PictureInfoFlags, mod.StdVideoH264PictureType, mod.StdVideoEncodeH264ReferenceListsInfo)
mod.StdVideoEncodeH264ReferenceInfo = ffi.typeof([[struct {
	$ flags;
	$ primary_pic_type;
	uint32_t FrameNum;
	int32_t PicOrderCnt;
	uint16_t long_term_pic_num;
	uint16_t long_term_frame_idx;
	uint8_t temporal_id;
}]], mod.StdVideoEncodeH264ReferenceInfoFlags, mod.StdVideoH264PictureType)
mod.StdVideoEncodeH264SliceHeader = ffi.typeof([[struct {
	$ flags;
	uint32_t first_mb_in_slice;
	$ slice_type;
	int8_t slice_alpha_c0_offset_div2;
	int8_t slice_beta_offset_div2;
	int8_t slice_qp_delta;
	uint8_t reserved1;
	$ cabac_init_idc;
	$ disable_deblocking_filter_idc;
	const $* pWeightTable;
}]], mod.StdVideoEncodeH264SliceHeaderFlags, mod.StdVideoH264SliceType, mod.StdVideoH264CabacInitIdc, mod.StdVideoH264DisableDeblockingFilterIdc, mod.StdVideoEncodeH264WeightTable)
mod.VkVideoEncodeH264CapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH264CapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH264StdFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR = 0x00001000,
	VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR = 0x00002000,
	VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR = 0x00008000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR = 0x00010000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR = 0x00020000,
	VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
	VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
	VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH264StdFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH264RateControlFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH264RateControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH264CapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ maxLevelIdc;
	uint32_t maxSliceCount;
	uint32_t maxPPictureL0ReferenceCount;
	uint32_t maxBPictureL0ReferenceCount;
	uint32_t maxL1ReferenceCount;
	uint32_t maxTemporalLayerCount;
	$ expectDyadicTemporalLayerPattern;
	int32_t minQp;
	int32_t maxQp;
	$ prefersGopRemainingFrames;
	$ requiresGopRemainingFrames;
	$ stdSyntaxFlags;
}]], mod.VkStructureType, mod.VkVideoEncodeH264CapabilityFlagsKHR, mod.StdVideoH264LevelIdc, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkVideoEncodeH264StdFlagsKHR)
mod.VkVideoEncodeH264QpKHR = ffi.typeof([[struct {
	int32_t qpI;
	int32_t qpP;
	int32_t qpB;
}]])
mod.VkVideoEncodeH264QualityLevelPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ preferredRateControlFlags;
	uint32_t preferredGopFrameCount;
	uint32_t preferredIdrPeriod;
	uint32_t preferredConsecutiveBFrameCount;
	uint32_t preferredTemporalLayerCount;
	$ preferredConstantQp;
	uint32_t preferredMaxL0ReferenceCount;
	uint32_t preferredMaxL1ReferenceCount;
	$ preferredStdEntropyCodingModeFlag;
}]], mod.VkStructureType, mod.VkVideoEncodeH264RateControlFlagsKHR, mod.VkVideoEncodeH264QpKHR, mod.VkBool32)
mod.VkVideoEncodeH264SessionCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useMaxLevelIdc;
	$ maxLevelIdc;
}]], mod.VkStructureType, mod.VkBool32, mod.StdVideoH264LevelIdc)
mod.VkVideoEncodeH264SessionParametersAddInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t stdSPSCount;
	const $* pStdSPSs;
	uint32_t stdPPSCount;
	const $* pStdPPSs;
}]], mod.VkStructureType, mod.StdVideoH264SequenceParameterSet, mod.StdVideoH264PictureParameterSet)
mod.VkVideoEncodeH264SessionParametersCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maxStdSPSCount;
	uint32_t maxStdPPSCount;
	const $* pParametersAddInfo;
}]], mod.VkStructureType, mod.VkVideoEncodeH264SessionParametersAddInfoKHR)
mod.VkVideoEncodeH264SessionParametersGetInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ writeStdSPS;
	$ writeStdPPS;
	uint32_t stdSPSId;
	uint32_t stdPPSId;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkVideoEncodeH264SessionParametersFeedbackInfoKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ hasStdSPSOverrides;
	$ hasStdPPSOverrides;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkVideoEncodeH264NaluSliceInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	int32_t constantQp;
	const $* pStdSliceHeader;
}]], mod.VkStructureType, mod.StdVideoEncodeH264SliceHeader)
mod.VkVideoEncodeH264PictureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t naluSliceEntryCount;
	const $* pNaluSliceEntries;
	const $* pStdPictureInfo;
	$ generatePrefixNalu;
}]], mod.VkStructureType, mod.VkVideoEncodeH264NaluSliceInfoKHR, mod.StdVideoEncodeH264PictureInfo, mod.VkBool32)
mod.VkVideoEncodeH264DpbSlotInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]], mod.VkStructureType, mod.StdVideoEncodeH264ReferenceInfo)
mod.VkVideoEncodeH264ProfileInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stdProfileIdc;
}]], mod.VkStructureType, mod.StdVideoH264ProfileIdc)
mod.VkVideoEncodeH264RateControlInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t gopFrameCount;
	uint32_t idrPeriod;
	uint32_t consecutiveBFrameCount;
	uint32_t temporalLayerCount;
}]], mod.VkStructureType, mod.VkVideoEncodeH264RateControlFlagsKHR)
mod.VkVideoEncodeH264FrameSizeKHR = ffi.typeof([[struct {
	uint32_t frameISize;
	uint32_t framePSize;
	uint32_t frameBSize;
}]])
mod.VkVideoEncodeH264RateControlLayerInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useMinQp;
	$ minQp;
	$ useMaxQp;
	$ maxQp;
	$ useMaxFrameSize;
	$ maxFrameSize;
}]], mod.VkStructureType, mod.VkBool32, mod.VkVideoEncodeH264QpKHR, mod.VkBool32, mod.VkVideoEncodeH264QpKHR, mod.VkBool32, mod.VkVideoEncodeH264FrameSizeKHR)
mod.VkVideoEncodeH264GopRemainingFrameInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useGopRemainingFrames;
	uint32_t gopRemainingI;
	uint32_t gopRemainingP;
	uint32_t gopRemainingB;
}]], mod.VkStructureType, mod.VkBool32)
mod.StdVideoH265ChromaFormatIdc = ffi.typeof([[enum {
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME = 0,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_420 = 1,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_422 = 2,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_444 = 3,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265ProfileIdc = ffi.typeof([[enum {
	STD_VIDEO_H265_PROFILE_IDC_MAIN = 1,
	STD_VIDEO_H265_PROFILE_IDC_MAIN_10 = 2,
	STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE = 3,
	STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS = 4,
	STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS = 9,
	STD_VIDEO_H265_PROFILE_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_PROFILE_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265LevelIdc = ffi.typeof([[enum {
	STD_VIDEO_H265_LEVEL_IDC_1_0 = 0,
	STD_VIDEO_H265_LEVEL_IDC_2_0 = 1,
	STD_VIDEO_H265_LEVEL_IDC_2_1 = 2,
	STD_VIDEO_H265_LEVEL_IDC_3_0 = 3,
	STD_VIDEO_H265_LEVEL_IDC_3_1 = 4,
	STD_VIDEO_H265_LEVEL_IDC_4_0 = 5,
	STD_VIDEO_H265_LEVEL_IDC_4_1 = 6,
	STD_VIDEO_H265_LEVEL_IDC_5_0 = 7,
	STD_VIDEO_H265_LEVEL_IDC_5_1 = 8,
	STD_VIDEO_H265_LEVEL_IDC_5_2 = 9,
	STD_VIDEO_H265_LEVEL_IDC_6_0 = 10,
	STD_VIDEO_H265_LEVEL_IDC_6_1 = 11,
	STD_VIDEO_H265_LEVEL_IDC_6_2 = 12,
	STD_VIDEO_H265_LEVEL_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_LEVEL_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265SliceType = ffi.typeof([[enum {
	STD_VIDEO_H265_SLICE_TYPE_B = 0,
	STD_VIDEO_H265_SLICE_TYPE_P = 1,
	STD_VIDEO_H265_SLICE_TYPE_I = 2,
	STD_VIDEO_H265_SLICE_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_SLICE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265PictureType = ffi.typeof([[enum {
	STD_VIDEO_H265_PICTURE_TYPE_P = 0,
	STD_VIDEO_H265_PICTURE_TYPE_B = 1,
	STD_VIDEO_H265_PICTURE_TYPE_I = 2,
	STD_VIDEO_H265_PICTURE_TYPE_IDR = 3,
	STD_VIDEO_H265_PICTURE_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_PICTURE_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265AspectRatioIdc = ffi.typeof([[enum {
	STD_VIDEO_H265_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_SQUARE = 1,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_12_11 = 2,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_10_11 = 3,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_16_11 = 4,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_40_33 = 5,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_24_11 = 6,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_20_11 = 7,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_32_11 = 8,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_80_33 = 9,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_18_11 = 10,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_15_11 = 11,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_64_33 = 12,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_160_99 = 13,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_4_3 = 14,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_3_2 = 15,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_2_1 = 16,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID = 0x7FFFFFFF,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoH265DecPicBufMgr = ffi.typeof([[struct {
	uint32_t max_latency_increase_plus1[7U];
	uint8_t max_dec_pic_buffering_minus1[7U];
	uint8_t max_num_reorder_pics[7U];
}]])
mod.StdVideoH265SubLayerHrdParameters = ffi.typeof([[struct {
	uint32_t bit_rate_value_minus1[32U];
	uint32_t cpb_size_value_minus1[32U];
	uint32_t cpb_size_du_value_minus1[32U];
	uint32_t bit_rate_du_value_minus1[32U];
	uint32_t cbr_flag;
}]])
mod.StdVideoH265HrdFlags = ffi.typeof([[struct {
	uint32_t nal_hrd_parameters_present_flag;
	uint32_t vcl_hrd_parameters_present_flag;
	uint32_t sub_pic_hrd_params_present_flag;
	uint32_t sub_pic_cpb_params_in_pic_timing_sei_flag;
	uint32_t fixed_pic_rate_general_flag;
	uint32_t fixed_pic_rate_within_cvs_flag;
	uint32_t low_delay_hrd_flag;
}]])
mod.StdVideoH265HrdParameters = ffi.typeof([[struct {
	$ flags;
	uint8_t tick_divisor_minus2;
	uint8_t du_cpb_removal_delay_increment_length_minus1;
	uint8_t dpb_output_delay_du_length_minus1;
	uint8_t bit_rate_scale;
	uint8_t cpb_size_scale;
	uint8_t cpb_size_du_scale;
	uint8_t initial_cpb_removal_delay_length_minus1;
	uint8_t au_cpb_removal_delay_length_minus1;
	uint8_t dpb_output_delay_length_minus1;
	uint8_t cpb_cnt_minus1[7U];
	uint16_t elemental_duration_in_tc_minus1[7U];
	uint16_t reserved[3];
	const $* pSubLayerHrdParametersNal;
	const $* pSubLayerHrdParametersVcl;
}]], mod.StdVideoH265HrdFlags, mod.StdVideoH265SubLayerHrdParameters, mod.StdVideoH265SubLayerHrdParameters)
mod.StdVideoH265VpsFlags = ffi.typeof([[struct {
	uint32_t vps_temporal_id_nesting_flag;
	uint32_t vps_sub_layer_ordering_info_present_flag;
	uint32_t vps_timing_info_present_flag;
	uint32_t vps_poc_proportional_to_timing_flag;
}]])
mod.StdVideoH265ProfileTierLevelFlags = ffi.typeof([[struct {
	uint32_t general_tier_flag;
	uint32_t general_progressive_source_flag;
	uint32_t general_interlaced_source_flag;
	uint32_t general_non_packed_constraint_flag;
	uint32_t general_frame_only_constraint_flag;
}]])
mod.StdVideoH265ProfileTierLevel = ffi.typeof([[struct {
	$ flags;
	$ general_profile_idc;
	$ general_level_idc;
}]], mod.StdVideoH265ProfileTierLevelFlags, mod.StdVideoH265ProfileIdc, mod.StdVideoH265LevelIdc)
mod.StdVideoH265VideoParameterSet = ffi.typeof([[struct {
	$ flags;
	uint8_t vps_video_parameter_set_id;
	uint8_t vps_max_sub_layers_minus1;
	uint8_t reserved1;
	uint8_t reserved2;
	uint32_t vps_num_units_in_tick;
	uint32_t vps_time_scale;
	uint32_t vps_num_ticks_poc_diff_one_minus1;
	uint32_t reserved3;
	const $* pDecPicBufMgr;
	const $* pHrdParameters;
	const $* pProfileTierLevel;
}]], mod.StdVideoH265VpsFlags, mod.StdVideoH265DecPicBufMgr, mod.StdVideoH265HrdParameters, mod.StdVideoH265ProfileTierLevel)
mod.StdVideoH265ScalingLists = ffi.typeof([[struct {
	uint8_t ScalingList4x4[16U][6U];
	uint8_t ScalingList8x8[64U][6U];
	uint8_t ScalingList16x16[64U][6U];
	uint8_t ScalingList32x32[64U][2U];
	uint8_t ScalingListDCCoef16x16[6U];
	uint8_t ScalingListDCCoef32x32[2U];
}]])
mod.StdVideoH265SpsVuiFlags = ffi.typeof([[struct {
	uint32_t aspect_ratio_info_present_flag;
	uint32_t overscan_info_present_flag;
	uint32_t overscan_appropriate_flag;
	uint32_t video_signal_type_present_flag;
	uint32_t video_full_range_flag;
	uint32_t colour_description_present_flag;
	uint32_t chroma_loc_info_present_flag;
	uint32_t neutral_chroma_indication_flag;
	uint32_t field_seq_flag;
	uint32_t frame_field_info_present_flag;
	uint32_t default_display_window_flag;
	uint32_t vui_timing_info_present_flag;
	uint32_t vui_poc_proportional_to_timing_flag;
	uint32_t vui_hrd_parameters_present_flag;
	uint32_t bitstream_restriction_flag;
	uint32_t tiles_fixed_structure_flag;
	uint32_t motion_vectors_over_pic_boundaries_flag;
	uint32_t restricted_ref_pic_lists_flag;
}]])
mod.StdVideoH265SequenceParameterSetVui = ffi.typeof([[struct {
	$ flags;
	$ aspect_ratio_idc;
	uint16_t sar_width;
	uint16_t sar_height;
	uint8_t video_format;
	uint8_t colour_primaries;
	uint8_t transfer_characteristics;
	uint8_t matrix_coeffs;
	uint8_t chroma_sample_loc_type_top_field;
	uint8_t chroma_sample_loc_type_bottom_field;
	uint8_t reserved1;
	uint8_t reserved2;
	uint16_t def_disp_win_left_offset;
	uint16_t def_disp_win_right_offset;
	uint16_t def_disp_win_top_offset;
	uint16_t def_disp_win_bottom_offset;
	uint32_t vui_num_units_in_tick;
	uint32_t vui_time_scale;
	uint32_t vui_num_ticks_poc_diff_one_minus1;
	uint16_t min_spatial_segmentation_idc;
	uint16_t reserved3;
	uint8_t max_bytes_per_pic_denom;
	uint8_t max_bits_per_min_cu_denom;
	uint8_t log2_max_mv_length_horizontal;
	uint8_t log2_max_mv_length_vertical;
	const $* pHrdParameters;
}]], mod.StdVideoH265SpsVuiFlags, mod.StdVideoH265AspectRatioIdc, mod.StdVideoH265HrdParameters)
mod.StdVideoH265PredictorPaletteEntries = ffi.typeof([[struct {
	uint16_t PredictorPaletteEntries[128U][3U];
}]])
mod.StdVideoH265SpsFlags = ffi.typeof([[struct {
	uint32_t sps_temporal_id_nesting_flag;
	uint32_t separate_colour_plane_flag;
	uint32_t conformance_window_flag;
	uint32_t sps_sub_layer_ordering_info_present_flag;
	uint32_t scaling_list_enabled_flag;
	uint32_t sps_scaling_list_data_present_flag;
	uint32_t amp_enabled_flag;
	uint32_t sample_adaptive_offset_enabled_flag;
	uint32_t pcm_enabled_flag;
	uint32_t pcm_loop_filter_disabled_flag;
	uint32_t long_term_ref_pics_present_flag;
	uint32_t sps_temporal_mvp_enabled_flag;
	uint32_t strong_intra_smoothing_enabled_flag;
	uint32_t vui_parameters_present_flag;
	uint32_t sps_extension_present_flag;
	uint32_t sps_range_extension_flag;
	uint32_t transform_skip_rotation_enabled_flag;
	uint32_t transform_skip_context_enabled_flag;
	uint32_t implicit_rdpcm_enabled_flag;
	uint32_t explicit_rdpcm_enabled_flag;
	uint32_t extended_precision_processing_flag;
	uint32_t intra_smoothing_disabled_flag;
	uint32_t high_precision_offsets_enabled_flag;
	uint32_t persistent_rice_adaptation_enabled_flag;
	uint32_t cabac_bypass_alignment_enabled_flag;
	uint32_t sps_scc_extension_flag;
	uint32_t sps_curr_pic_ref_enabled_flag;
	uint32_t palette_mode_enabled_flag;
	uint32_t sps_palette_predictor_initializers_present_flag;
	uint32_t intra_boundary_filtering_disabled_flag;
}]])
mod.StdVideoH265ShortTermRefPicSetFlags = ffi.typeof([[struct {
	uint32_t inter_ref_pic_set_prediction_flag;
	uint32_t delta_rps_sign;
}]])
mod.StdVideoH265ShortTermRefPicSet = ffi.typeof([[struct {
	$ flags;
	uint32_t delta_idx_minus1;
	uint16_t use_delta_flag;
	uint16_t abs_delta_rps_minus1;
	uint16_t used_by_curr_pic_flag;
	uint16_t used_by_curr_pic_s0_flag;
	uint16_t used_by_curr_pic_s1_flag;
	uint16_t reserved1;
	uint8_t reserved2;
	uint8_t reserved3;
	uint8_t num_negative_pics;
	uint8_t num_positive_pics;
	uint16_t delta_poc_s0_minus1[16U];
	uint16_t delta_poc_s1_minus1[16U];
}]], mod.StdVideoH265ShortTermRefPicSetFlags)
mod.StdVideoH265LongTermRefPicsSps = ffi.typeof([[struct {
	uint32_t used_by_curr_pic_lt_sps_flag;
	uint32_t lt_ref_pic_poc_lsb_sps[32U];
}]])
mod.StdVideoH265SequenceParameterSet = ffi.typeof([[struct {
	$ flags;
	$ chroma_format_idc;
	uint32_t pic_width_in_luma_samples;
	uint32_t pic_height_in_luma_samples;
	uint8_t sps_video_parameter_set_id;
	uint8_t sps_max_sub_layers_minus1;
	uint8_t sps_seq_parameter_set_id;
	uint8_t bit_depth_luma_minus8;
	uint8_t bit_depth_chroma_minus8;
	uint8_t log2_max_pic_order_cnt_lsb_minus4;
	uint8_t log2_min_luma_coding_block_size_minus3;
	uint8_t log2_diff_max_min_luma_coding_block_size;
	uint8_t log2_min_luma_transform_block_size_minus2;
	uint8_t log2_diff_max_min_luma_transform_block_size;
	uint8_t max_transform_hierarchy_depth_inter;
	uint8_t max_transform_hierarchy_depth_intra;
	uint8_t num_short_term_ref_pic_sets;
	uint8_t num_long_term_ref_pics_sps;
	uint8_t pcm_sample_bit_depth_luma_minus1;
	uint8_t pcm_sample_bit_depth_chroma_minus1;
	uint8_t log2_min_pcm_luma_coding_block_size_minus3;
	uint8_t log2_diff_max_min_pcm_luma_coding_block_size;
	uint8_t reserved1;
	uint8_t reserved2;
	uint8_t palette_max_size;
	uint8_t delta_palette_max_predictor_size;
	uint8_t motion_vector_resolution_control_idc;
	uint8_t sps_num_palette_predictor_initializers_minus1;
	uint32_t conf_win_left_offset;
	uint32_t conf_win_right_offset;
	uint32_t conf_win_top_offset;
	uint32_t conf_win_bottom_offset;
	const $* pProfileTierLevel;
	const $* pDecPicBufMgr;
	const $* pScalingLists;
	const $* pShortTermRefPicSet;
	const $* pLongTermRefPicsSps;
	const $* pSequenceParameterSetVui;
	const $* pPredictorPaletteEntries;
}]], mod.StdVideoH265SpsFlags, mod.StdVideoH265ChromaFormatIdc, mod.StdVideoH265ProfileTierLevel, mod.StdVideoH265DecPicBufMgr, mod.StdVideoH265ScalingLists, mod.StdVideoH265ShortTermRefPicSet, mod.StdVideoH265LongTermRefPicsSps, mod.StdVideoH265SequenceParameterSetVui, mod.StdVideoH265PredictorPaletteEntries)
mod.StdVideoH265PpsFlags = ffi.typeof([[struct {
	uint32_t dependent_slice_segments_enabled_flag;
	uint32_t output_flag_present_flag;
	uint32_t sign_data_hiding_enabled_flag;
	uint32_t cabac_init_present_flag;
	uint32_t constrained_intra_pred_flag;
	uint32_t transform_skip_enabled_flag;
	uint32_t cu_qp_delta_enabled_flag;
	uint32_t pps_slice_chroma_qp_offsets_present_flag;
	uint32_t weighted_pred_flag;
	uint32_t weighted_bipred_flag;
	uint32_t transquant_bypass_enabled_flag;
	uint32_t tiles_enabled_flag;
	uint32_t entropy_coding_sync_enabled_flag;
	uint32_t uniform_spacing_flag;
	uint32_t loop_filter_across_tiles_enabled_flag;
	uint32_t pps_loop_filter_across_slices_enabled_flag;
	uint32_t deblocking_filter_control_present_flag;
	uint32_t deblocking_filter_override_enabled_flag;
	uint32_t pps_deblocking_filter_disabled_flag;
	uint32_t pps_scaling_list_data_present_flag;
	uint32_t lists_modification_present_flag;
	uint32_t slice_segment_header_extension_present_flag;
	uint32_t pps_extension_present_flag;
	uint32_t cross_component_prediction_enabled_flag;
	uint32_t chroma_qp_offset_list_enabled_flag;
	uint32_t pps_curr_pic_ref_enabled_flag;
	uint32_t residual_adaptive_colour_transform_enabled_flag;
	uint32_t pps_slice_act_qp_offsets_present_flag;
	uint32_t pps_palette_predictor_initializers_present_flag;
	uint32_t monochrome_palette_flag;
	uint32_t pps_range_extension_flag;
}]])
mod.StdVideoH265PictureParameterSet = ffi.typeof([[struct {
	$ flags;
	uint8_t pps_pic_parameter_set_id;
	uint8_t pps_seq_parameter_set_id;
	uint8_t sps_video_parameter_set_id;
	uint8_t num_extra_slice_header_bits;
	uint8_t num_ref_idx_l0_default_active_minus1;
	uint8_t num_ref_idx_l1_default_active_minus1;
	int8_t init_qp_minus26;
	uint8_t diff_cu_qp_delta_depth;
	int8_t pps_cb_qp_offset;
	int8_t pps_cr_qp_offset;
	int8_t pps_beta_offset_div2;
	int8_t pps_tc_offset_div2;
	uint8_t log2_parallel_merge_level_minus2;
	uint8_t log2_max_transform_skip_block_size_minus2;
	uint8_t diff_cu_chroma_qp_offset_depth;
	uint8_t chroma_qp_offset_list_len_minus1;
	int8_t cb_qp_offset_list[6U];
	int8_t cr_qp_offset_list[6U];
	uint8_t log2_sao_offset_scale_luma;
	uint8_t log2_sao_offset_scale_chroma;
	int8_t pps_act_y_qp_offset_plus5;
	int8_t pps_act_cb_qp_offset_plus5;
	int8_t pps_act_cr_qp_offset_plus3;
	uint8_t pps_num_palette_predictor_initializers;
	uint8_t luma_bit_depth_entry_minus8;
	uint8_t chroma_bit_depth_entry_minus8;
	uint8_t num_tile_columns_minus1;
	uint8_t num_tile_rows_minus1;
	uint8_t reserved1;
	uint8_t reserved2;
	uint16_t column_width_minus1[19U];
	uint16_t row_height_minus1[21U];
	uint32_t reserved3;
	const $* pScalingLists;
	const $* pPredictorPaletteEntries;
}]], mod.StdVideoH265PpsFlags, mod.StdVideoH265ScalingLists, mod.StdVideoH265PredictorPaletteEntries)
mod.StdVideoEncodeH265WeightTableFlags = ffi.typeof([[struct {
	uint16_t luma_weight_l0_flag;
	uint16_t chroma_weight_l0_flag;
	uint16_t luma_weight_l1_flag;
	uint16_t chroma_weight_l1_flag;
}]])
mod.StdVideoEncodeH265WeightTable = ffi.typeof([[struct {
	$ flags;
	uint8_t luma_log2_weight_denom;
	int8_t delta_chroma_log2_weight_denom;
	int8_t delta_luma_weight_l0[15U];
	int8_t luma_offset_l0[15U];
	int8_t delta_chroma_weight_l0[2U][15U];
	int8_t delta_chroma_offset_l0[2U][15U];
	int8_t delta_luma_weight_l1[15U];
	int8_t luma_offset_l1[15U];
	int8_t delta_chroma_weight_l1[2U][15U];
	int8_t delta_chroma_offset_l1[2U][15U];
}]], mod.StdVideoEncodeH265WeightTableFlags)
mod.StdVideoEncodeH265SliceSegmentHeaderFlags = ffi.typeof([[struct {
	uint32_t first_slice_segment_in_pic_flag;
	uint32_t dependent_slice_segment_flag;
	uint32_t slice_sao_luma_flag;
	uint32_t slice_sao_chroma_flag;
	uint32_t num_ref_idx_active_override_flag;
	uint32_t mvd_l1_zero_flag;
	uint32_t cabac_init_flag;
	uint32_t cu_chroma_qp_offset_enabled_flag;
	uint32_t deblocking_filter_override_flag;
	uint32_t slice_deblocking_filter_disabled_flag;
	uint32_t collocated_from_l0_flag;
	uint32_t slice_loop_filter_across_slices_enabled_flag;
	uint32_t reserved;
}]])
mod.StdVideoEncodeH265SliceSegmentHeader = ffi.typeof([[struct {
	$ flags;
	$ slice_type;
	uint32_t slice_segment_address;
	uint8_t collocated_ref_idx;
	uint8_t MaxNumMergeCand;
	int8_t slice_cb_qp_offset;
	int8_t slice_cr_qp_offset;
	int8_t slice_beta_offset_div2;
	int8_t slice_tc_offset_div2;
	int8_t slice_act_y_qp_offset;
	int8_t slice_act_cb_qp_offset;
	int8_t slice_act_cr_qp_offset;
	int8_t slice_qp_delta;
	uint16_t reserved1;
	const $* pWeightTable;
}]], mod.StdVideoEncodeH265SliceSegmentHeaderFlags, mod.StdVideoH265SliceType, mod.StdVideoEncodeH265WeightTable)
mod.StdVideoEncodeH265ReferenceListsInfoFlags = ffi.typeof([[struct {
	uint32_t ref_pic_list_modification_flag_l0;
	uint32_t ref_pic_list_modification_flag_l1;
	uint32_t reserved;
}]])
mod.StdVideoEncodeH265ReferenceListsInfo = ffi.typeof([[struct {
	$ flags;
	uint8_t num_ref_idx_l0_active_minus1;
	uint8_t num_ref_idx_l1_active_minus1;
	uint8_t RefPicList0[15U];
	uint8_t RefPicList1[15U];
	uint8_t list_entry_l0[15U];
	uint8_t list_entry_l1[15U];
}]], mod.StdVideoEncodeH265ReferenceListsInfoFlags)
mod.StdVideoEncodeH265PictureInfoFlags = ffi.typeof([[struct {
	uint32_t is_reference;
	uint32_t IrapPicFlag;
	uint32_t used_for_long_term_reference;
	uint32_t discardable_flag;
	uint32_t cross_layer_bla_flag;
	uint32_t pic_output_flag;
	uint32_t no_output_of_prior_pics_flag;
	uint32_t short_term_ref_pic_set_sps_flag;
	uint32_t slice_temporal_mvp_enabled_flag;
	uint32_t reserved;
}]])
mod.StdVideoEncodeH265LongTermRefPics = ffi.typeof([[struct {
	uint8_t num_long_term_sps;
	uint8_t num_long_term_pics;
	uint8_t lt_idx_sps[32U];
	uint8_t poc_lsb_lt[16U];
	uint16_t used_by_curr_pic_lt_flag;
	uint8_t delta_poc_msb_present_flag[48U];
	uint8_t delta_poc_msb_cycle_lt[48U];
}]])
mod.StdVideoEncodeH265PictureInfo = ffi.typeof([[struct {
	$ flags;
	$ pic_type;
	uint8_t sps_video_parameter_set_id;
	uint8_t pps_seq_parameter_set_id;
	uint8_t pps_pic_parameter_set_id;
	uint8_t short_term_ref_pic_set_idx;
	int32_t PicOrderCntVal;
	uint8_t TemporalId;
	uint8_t reserved1[7];
	const $* pRefLists;
	const $* pShortTermRefPicSet;
	const $* pLongTermRefPics;
}]], mod.StdVideoEncodeH265PictureInfoFlags, mod.StdVideoH265PictureType, mod.StdVideoEncodeH265ReferenceListsInfo, mod.StdVideoH265ShortTermRefPicSet, mod.StdVideoEncodeH265LongTermRefPics)
mod.StdVideoEncodeH265ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t used_for_long_term_reference;
	uint32_t unused_for_reference;
	uint32_t reserved;
}]])
mod.StdVideoEncodeH265ReferenceInfo = ffi.typeof([[struct {
	$ flags;
	$ pic_type;
	int32_t PicOrderCntVal;
	uint8_t TemporalId;
}]], mod.StdVideoEncodeH265ReferenceInfoFlags, mod.StdVideoH265PictureType)
mod.VkVideoEncodeH265CapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265CapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265StdFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR = 0x00001000,
	VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR = 0x00002000,
	VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
	VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR = 0x00008000,
	VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR = 0x00010000,
	VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR = 0x00020000,
	VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR = 0x00040000,
	VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
	VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
	VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265StdFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265CtbSizeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265CtbSizeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265TransformBlockSizeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265TransformBlockSizeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265RateControlFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeH265RateControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeH265CapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ maxLevelIdc;
	uint32_t maxSliceSegmentCount;
	$ maxTiles;
	$ ctbSizes;
	$ transformBlockSizes;
	uint32_t maxPPictureL0ReferenceCount;
	uint32_t maxBPictureL0ReferenceCount;
	uint32_t maxL1ReferenceCount;
	uint32_t maxSubLayerCount;
	$ expectDyadicTemporalSubLayerPattern;
	int32_t minQp;
	int32_t maxQp;
	$ prefersGopRemainingFrames;
	$ requiresGopRemainingFrames;
	$ stdSyntaxFlags;
}]], mod.VkStructureType, mod.VkVideoEncodeH265CapabilityFlagsKHR, mod.StdVideoH265LevelIdc, mod.VkExtent2D, mod.VkVideoEncodeH265CtbSizeFlagsKHR, mod.VkVideoEncodeH265TransformBlockSizeFlagsKHR, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkVideoEncodeH265StdFlagsKHR)
mod.VkVideoEncodeH265SessionCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useMaxLevelIdc;
	$ maxLevelIdc;
}]], mod.VkStructureType, mod.VkBool32, mod.StdVideoH265LevelIdc)
mod.VkVideoEncodeH265QpKHR = ffi.typeof([[struct {
	int32_t qpI;
	int32_t qpP;
	int32_t qpB;
}]])
mod.VkVideoEncodeH265QualityLevelPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ preferredRateControlFlags;
	uint32_t preferredGopFrameCount;
	uint32_t preferredIdrPeriod;
	uint32_t preferredConsecutiveBFrameCount;
	uint32_t preferredSubLayerCount;
	$ preferredConstantQp;
	uint32_t preferredMaxL0ReferenceCount;
	uint32_t preferredMaxL1ReferenceCount;
}]], mod.VkStructureType, mod.VkVideoEncodeH265RateControlFlagsKHR, mod.VkVideoEncodeH265QpKHR)
mod.VkVideoEncodeH265SessionParametersAddInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t stdVPSCount;
	const $* pStdVPSs;
	uint32_t stdSPSCount;
	const $* pStdSPSs;
	uint32_t stdPPSCount;
	const $* pStdPPSs;
}]], mod.VkStructureType, mod.StdVideoH265VideoParameterSet, mod.StdVideoH265SequenceParameterSet, mod.StdVideoH265PictureParameterSet)
mod.VkVideoEncodeH265SessionParametersCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maxStdVPSCount;
	uint32_t maxStdSPSCount;
	uint32_t maxStdPPSCount;
	const $* pParametersAddInfo;
}]], mod.VkStructureType, mod.VkVideoEncodeH265SessionParametersAddInfoKHR)
mod.VkVideoEncodeH265SessionParametersGetInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ writeStdVPS;
	$ writeStdSPS;
	$ writeStdPPS;
	uint32_t stdVPSId;
	uint32_t stdSPSId;
	uint32_t stdPPSId;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkVideoEncodeH265SessionParametersFeedbackInfoKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ hasStdVPSOverrides;
	$ hasStdSPSOverrides;
	$ hasStdPPSOverrides;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkVideoEncodeH265NaluSliceSegmentInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	int32_t constantQp;
	const $* pStdSliceSegmentHeader;
}]], mod.VkStructureType, mod.StdVideoEncodeH265SliceSegmentHeader)
mod.VkVideoEncodeH265PictureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t naluSliceSegmentEntryCount;
	const $* pNaluSliceSegmentEntries;
	const $* pStdPictureInfo;
}]], mod.VkStructureType, mod.VkVideoEncodeH265NaluSliceSegmentInfoKHR, mod.StdVideoEncodeH265PictureInfo)
mod.VkVideoEncodeH265DpbSlotInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]], mod.VkStructureType, mod.StdVideoEncodeH265ReferenceInfo)
mod.VkVideoEncodeH265ProfileInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stdProfileIdc;
}]], mod.VkStructureType, mod.StdVideoH265ProfileIdc)
mod.VkVideoEncodeH265RateControlInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t gopFrameCount;
	uint32_t idrPeriod;
	uint32_t consecutiveBFrameCount;
	uint32_t subLayerCount;
}]], mod.VkStructureType, mod.VkVideoEncodeH265RateControlFlagsKHR)
mod.VkVideoEncodeH265FrameSizeKHR = ffi.typeof([[struct {
	uint32_t frameISize;
	uint32_t framePSize;
	uint32_t frameBSize;
}]])
mod.VkVideoEncodeH265RateControlLayerInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useMinQp;
	$ minQp;
	$ useMaxQp;
	$ maxQp;
	$ useMaxFrameSize;
	$ maxFrameSize;
}]], mod.VkStructureType, mod.VkBool32, mod.VkVideoEncodeH265QpKHR, mod.VkBool32, mod.VkVideoEncodeH265QpKHR, mod.VkBool32, mod.VkVideoEncodeH265FrameSizeKHR)
mod.VkVideoEncodeH265GopRemainingFrameInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useGopRemainingFrames;
	uint32_t gopRemainingI;
	uint32_t gopRemainingP;
	uint32_t gopRemainingB;
}]], mod.VkStructureType, mod.VkBool32)
mod.StdVideoDecodeH264FieldOrderCount = ffi.typeof([[enum {
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP = 0,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM = 1,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID = 0x7FFFFFFF,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoDecodeH264PictureInfoFlags = ffi.typeof([[struct {
	uint32_t field_pic_flag;
	uint32_t is_intra;
	uint32_t IdrPicFlag;
	uint32_t bottom_field_flag;
	uint32_t is_reference;
	uint32_t complementary_field_pair;
}]])
mod.StdVideoDecodeH264PictureInfo = ffi.typeof([[struct {
	$ flags;
	uint8_t seq_parameter_set_id;
	uint8_t pic_parameter_set_id;
	uint8_t reserved1;
	uint8_t reserved2;
	uint16_t frame_num;
	uint16_t idr_pic_id;
	int32_t PicOrderCnt[2U];
}]], mod.StdVideoDecodeH264PictureInfoFlags)
mod.StdVideoDecodeH264ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t top_field_flag;
	uint32_t bottom_field_flag;
	uint32_t used_for_long_term_reference;
	uint32_t is_non_existing;
}]])
mod.StdVideoDecodeH264ReferenceInfo = ffi.typeof([[struct {
	$ flags;
	uint16_t FrameNum;
	uint16_t reserved;
	int32_t PicOrderCnt[2U];
}]], mod.StdVideoDecodeH264ReferenceInfoFlags)
mod.VkVideoDecodeH264PictureLayoutFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR = 0,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoDecodeH264PictureLayoutFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoDecodeH264ProfileInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stdProfileIdc;
	$ pictureLayout;
}]], mod.VkStructureType, mod.StdVideoH264ProfileIdc, mod.VkVideoDecodeH264PictureLayoutFlagBitsKHR)
mod.VkVideoDecodeH264CapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxLevelIdc;
	$ fieldOffsetGranularity;
}]], mod.VkStructureType, mod.StdVideoH264LevelIdc, mod.VkOffset2D)
mod.VkVideoDecodeH264SessionParametersAddInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t stdSPSCount;
	const $* pStdSPSs;
	uint32_t stdPPSCount;
	const $* pStdPPSs;
}]], mod.VkStructureType, mod.StdVideoH264SequenceParameterSet, mod.StdVideoH264PictureParameterSet)
mod.VkVideoDecodeH264SessionParametersCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maxStdSPSCount;
	uint32_t maxStdPPSCount;
	const $* pParametersAddInfo;
}]], mod.VkStructureType, mod.VkVideoDecodeH264SessionParametersAddInfoKHR)
mod.VkVideoDecodeH264PictureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdPictureInfo;
	uint32_t sliceCount;
	const uint32_t* pSliceOffsets;
}]], mod.VkStructureType, mod.StdVideoDecodeH264PictureInfo)
mod.VkVideoDecodeH264DpbSlotInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]], mod.VkStructureType, mod.StdVideoDecodeH264ReferenceInfo)
mod.VkRenderingFlagsKHR = ffi.typeof([[$ ]], mod.VkRenderingFlags)
mod.VkRenderingFlagBitsKHR = ffi.typeof([[$ ]], mod.VkRenderingFlagBits)
mod.VkRenderingInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingInfo)
mod.VkRenderingAttachmentInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingAttachmentInfo)
mod.VkPipelineRenderingCreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineRenderingCreateInfo)
mod.VkPhysicalDeviceDynamicRenderingFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDynamicRenderingFeatures)
mod.VkCommandBufferInheritanceRenderingInfoKHR = ffi.typeof([[$ ]], mod.VkCommandBufferInheritanceRenderingInfo)
mod.PFN_vkCmdBeginRenderingKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingInfo)
mod.PFN_vkCmdEndRenderingKHR = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdBeginRenderingKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkRenderingInfo)
ffi.cdef([[void  vkCmdEndRenderingKHR($ );]], mod.VkCommandBuffer)
mod.VkRenderPassMultiviewCreateInfoKHR = ffi.typeof([[$ ]], mod.VkRenderPassMultiviewCreateInfo)
mod.VkPhysicalDeviceMultiviewFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMultiviewFeatures)
mod.VkPhysicalDeviceMultiviewPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMultiviewProperties)
mod.VkPhysicalDeviceFeatures2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFeatures2)
mod.VkPhysicalDeviceProperties2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceProperties2)
mod.VkFormatProperties2KHR = ffi.typeof([[$ ]], mod.VkFormatProperties2)
mod.VkImageFormatProperties2KHR = ffi.typeof([[$ ]], mod.VkImageFormatProperties2)
mod.VkPhysicalDeviceImageFormatInfo2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceImageFormatInfo2)
mod.VkQueueFamilyProperties2KHR = ffi.typeof([[$ ]], mod.VkQueueFamilyProperties2)
mod.VkPhysicalDeviceMemoryProperties2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMemoryProperties2)
mod.VkSparseImageFormatProperties2KHR = ffi.typeof([[$ ]], mod.VkSparseImageFormatProperties2)
mod.VkPhysicalDeviceSparseImageFormatInfo2KHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSparseImageFormatInfo2)
mod.PFN_vkGetPhysicalDeviceFeatures2KHR = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures2)
mod.PFN_vkGetPhysicalDeviceProperties2KHR = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties2)
mod.PFN_vkGetPhysicalDeviceFormatProperties2KHR = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkPhysicalDevice, mod.VkFormat, mod.VkFormatProperties2)
mod.PFN_vkGetPhysicalDeviceImageFormatProperties2KHR = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceImageFormatInfo2, mod.VkImageFormatProperties2)
mod.PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR = ffi.typeof([[void (*)($ , uint32_t*, $*)]], mod.VkPhysicalDevice, mod.VkQueueFamilyProperties2)
mod.PFN_vkGetPhysicalDeviceMemoryProperties2KHR = ffi.typeof([[void (*)($ , $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties2)
mod.PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = ffi.typeof([[void (*)($ , const $*, uint32_t*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceSparseImageFormatInfo2, mod.VkSparseImageFormatProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceFeatures2KHR($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceFeatures2)
ffi.cdef([[void  vkGetPhysicalDeviceProperties2KHR($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceFormatProperties2KHR($ , $ , $*);]], mod.VkPhysicalDevice, mod.VkFormat, mod.VkFormatProperties2)
ffi.cdef([[$  vkGetPhysicalDeviceImageFormatProperties2KHR($ , const $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceImageFormatInfo2, mod.VkImageFormatProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceQueueFamilyProperties2KHR($ , uint32_t*, $*);]], mod.VkPhysicalDevice, mod.VkQueueFamilyProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceMemoryProperties2KHR($ , $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceMemoryProperties2)
ffi.cdef([[void  vkGetPhysicalDeviceSparseImageFormatProperties2KHR($ , const $*, uint32_t*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceSparseImageFormatInfo2, mod.VkSparseImageFormatProperties2)
mod.VkPeerMemoryFeatureFlagsKHR = ffi.typeof([[$ ]], mod.VkPeerMemoryFeatureFlags)
mod.VkPeerMemoryFeatureFlagBitsKHR = ffi.typeof([[$ ]], mod.VkPeerMemoryFeatureFlagBits)
mod.VkMemoryAllocateFlagsKHR = ffi.typeof([[$ ]], mod.VkMemoryAllocateFlags)
mod.VkMemoryAllocateFlagBitsKHR = ffi.typeof([[$ ]], mod.VkMemoryAllocateFlagBits)
mod.VkMemoryAllocateFlagsInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryAllocateFlagsInfo)
mod.VkDeviceGroupRenderPassBeginInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupRenderPassBeginInfo)
mod.VkDeviceGroupCommandBufferBeginInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupCommandBufferBeginInfo)
mod.VkDeviceGroupSubmitInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupSubmitInfo)
mod.VkDeviceGroupBindSparseInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupBindSparseInfo)
mod.VkBindBufferMemoryDeviceGroupInfoKHR = ffi.typeof([[$ ]], mod.VkBindBufferMemoryDeviceGroupInfo)
mod.VkBindImageMemoryDeviceGroupInfoKHR = ffi.typeof([[$ ]], mod.VkBindImageMemoryDeviceGroupInfo)
mod.PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t , $*)]], mod.VkDevice, mod.VkPeerMemoryFeatureFlags)
mod.PFN_vkCmdSetDeviceMaskKHR = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDispatchBaseKHR = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
ffi.cdef([[void  vkGetDeviceGroupPeerMemoryFeaturesKHR($ , uint32_t , uint32_t , uint32_t , $*);]], mod.VkDevice, mod.VkPeerMemoryFeatureFlags)
ffi.cdef([[void  vkCmdSetDeviceMaskKHR($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdDispatchBaseKHR($ , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer)
mod.VkCommandPoolTrimFlagsKHR = ffi.typeof([[$ ]], mod.VkCommandPoolTrimFlags)
mod.PFN_vkTrimCommandPoolKHR = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkDevice, mod.VkCommandPool, mod.VkCommandPoolTrimFlags)
ffi.cdef([[void  vkTrimCommandPoolKHR($ , $ , $ );]], mod.VkDevice, mod.VkCommandPool, mod.VkCommandPoolTrimFlags)
mod.VkPhysicalDeviceGroupPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceGroupProperties)
mod.VkDeviceGroupDeviceCreateInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceGroupDeviceCreateInfo)
mod.PFN_vkEnumeratePhysicalDeviceGroupsKHR = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkInstance, mod.VkPhysicalDeviceGroupProperties)
ffi.cdef([[$  vkEnumeratePhysicalDeviceGroupsKHR($ , uint32_t*, $*);]], mod.VkResult, mod.VkInstance, mod.VkPhysicalDeviceGroupProperties)
mod.VkExternalMemoryHandleTypeFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryHandleTypeFlags)
mod.VkExternalMemoryHandleTypeFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkExternalMemoryFeatureFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryFeatureFlags)
mod.VkExternalMemoryFeatureFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryFeatureFlagBits)
mod.VkExternalMemoryPropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryProperties)
mod.VkPhysicalDeviceExternalImageFormatInfoKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceExternalImageFormatInfo)
mod.VkExternalImageFormatPropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalImageFormatProperties)
mod.VkPhysicalDeviceExternalBufferInfoKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceExternalBufferInfo)
mod.VkExternalBufferPropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalBufferProperties)
mod.VkPhysicalDeviceIDPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceIDProperties)
mod.PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalBufferInfo, mod.VkExternalBufferProperties)
ffi.cdef([[void  vkGetPhysicalDeviceExternalBufferPropertiesKHR($ , const $*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalBufferInfo, mod.VkExternalBufferProperties)
mod.VkExternalMemoryImageCreateInfoKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryImageCreateInfo)
mod.VkExternalMemoryBufferCreateInfoKHR = ffi.typeof([[$ ]], mod.VkExternalMemoryBufferCreateInfo)
mod.VkExportMemoryAllocateInfoKHR = ffi.typeof([[$ ]], mod.VkExportMemoryAllocateInfo)
mod.VkImportMemoryFdInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleType;
	int fd;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkMemoryFdPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t memoryTypeBits;
}]], mod.VkStructureType)
mod.VkMemoryGetFdInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ handleType;
}]], mod.VkStructureType, mod.VkDeviceMemory, mod.VkExternalMemoryHandleTypeFlagBits)
mod.PFN_vkGetMemoryFdKHR = ffi.typeof([[$ (*)($ , const $*, int*)]], mod.VkResult, mod.VkDevice, mod.VkMemoryGetFdInfoKHR)
mod.PFN_vkGetMemoryFdPropertiesKHR = ffi.typeof([[$ (*)($ , $ , int , $*)]], mod.VkResult, mod.VkDevice, mod.VkExternalMemoryHandleTypeFlagBits, mod.VkMemoryFdPropertiesKHR)
ffi.cdef([[$  vkGetMemoryFdKHR($ , const $*, int*);]], mod.VkResult, mod.VkDevice, mod.VkMemoryGetFdInfoKHR)
ffi.cdef([[$  vkGetMemoryFdPropertiesKHR($ , $ , int , $*);]], mod.VkResult, mod.VkDevice, mod.VkExternalMemoryHandleTypeFlagBits, mod.VkMemoryFdPropertiesKHR)
mod.VkExternalSemaphoreHandleTypeFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreHandleTypeFlags)
mod.VkExternalSemaphoreHandleTypeFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreHandleTypeFlagBits)
mod.VkExternalSemaphoreFeatureFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreFeatureFlags)
mod.VkExternalSemaphoreFeatureFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreFeatureFlagBits)
mod.VkPhysicalDeviceExternalSemaphoreInfoKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceExternalSemaphoreInfo)
mod.VkExternalSemaphorePropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalSemaphoreProperties)
mod.PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalSemaphoreInfo, mod.VkExternalSemaphoreProperties)
ffi.cdef([[void  vkGetPhysicalDeviceExternalSemaphorePropertiesKHR($ , const $*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalSemaphoreInfo, mod.VkExternalSemaphoreProperties)
mod.VkSemaphoreImportFlagsKHR = ffi.typeof([[$ ]], mod.VkSemaphoreImportFlags)
mod.VkSemaphoreImportFlagBitsKHR = ffi.typeof([[$ ]], mod.VkSemaphoreImportFlagBits)
mod.VkExportSemaphoreCreateInfoKHR = ffi.typeof([[$ ]], mod.VkExportSemaphoreCreateInfo)
mod.VkImportSemaphoreFdInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	$ flags;
	$ handleType;
	int fd;
}]], mod.VkStructureType, mod.VkSemaphore, mod.VkSemaphoreImportFlags, mod.VkExternalSemaphoreHandleTypeFlagBits)
mod.VkSemaphoreGetFdInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	$ handleType;
}]], mod.VkStructureType, mod.VkSemaphore, mod.VkExternalSemaphoreHandleTypeFlagBits)
mod.PFN_vkImportSemaphoreFdKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkImportSemaphoreFdInfoKHR)
mod.PFN_vkGetSemaphoreFdKHR = ffi.typeof([[$ (*)($ , const $*, int*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreGetFdInfoKHR)
ffi.cdef([[$  vkImportSemaphoreFdKHR($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkImportSemaphoreFdInfoKHR)
ffi.cdef([[$  vkGetSemaphoreFdKHR($ , const $*, int*);]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreGetFdInfoKHR)
mod.VkPhysicalDevicePushDescriptorPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDevicePushDescriptorProperties)
mod.PFN_vkCmdPushDescriptorSetKHR = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout, mod.VkWriteDescriptorSet)
mod.PFN_vkCmdPushDescriptorSetWithTemplateKHR = ffi.typeof([[void (*)($ , $ , $ , uint32_t , const void*)]], mod.VkCommandBuffer, mod.VkDescriptorUpdateTemplate, mod.VkPipelineLayout)
ffi.cdef([[void  vkCmdPushDescriptorSetKHR($ , $ , $ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout, mod.VkWriteDescriptorSet)
ffi.cdef([[void  vkCmdPushDescriptorSetWithTemplateKHR($ , $ , $ , uint32_t , const void*);]], mod.VkCommandBuffer, mod.VkDescriptorUpdateTemplate, mod.VkPipelineLayout)
mod.VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderFloat16Int8Features)
mod.VkPhysicalDeviceFloat16Int8FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderFloat16Int8Features)
mod.VkPhysicalDevice16BitStorageFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDevice16BitStorageFeatures)
mod.VkRectLayerKHR = ffi.typeof([[struct {
	$ offset;
	$ extent;
	uint32_t layer;
}]], mod.VkOffset2D, mod.VkExtent2D)
mod.VkPresentRegionKHR = ffi.typeof([[struct {
	uint32_t rectangleCount;
	const $* pRectangles;
}]], mod.VkRectLayerKHR)
mod.VkPresentRegionsKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkPresentRegionKHR)
mod.VkDescriptorUpdateTemplateKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplate)
mod.VkDescriptorUpdateTemplateTypeKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplateType)
mod.VkDescriptorUpdateTemplateCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplateCreateFlags)
mod.VkDescriptorUpdateTemplateEntryKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplateEntry)
mod.VkDescriptorUpdateTemplateCreateInfoKHR = ffi.typeof([[$ ]], mod.VkDescriptorUpdateTemplateCreateInfo)
mod.PFN_vkCreateDescriptorUpdateTemplateKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDescriptorUpdateTemplateCreateInfo, mod.VkAllocationCallbacks, mod.VkDescriptorUpdateTemplate)
mod.PFN_vkDestroyDescriptorUpdateTemplateKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkDescriptorUpdateTemplate, mod.VkAllocationCallbacks)
mod.PFN_vkUpdateDescriptorSetWithTemplateKHR = ffi.typeof([[void (*)($ , $ , $ , const void*)]], mod.VkDevice, mod.VkDescriptorSet, mod.VkDescriptorUpdateTemplate)
ffi.cdef([[$  vkCreateDescriptorUpdateTemplateKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDescriptorUpdateTemplateCreateInfo, mod.VkAllocationCallbacks, mod.VkDescriptorUpdateTemplate)
ffi.cdef([[void  vkDestroyDescriptorUpdateTemplateKHR($ , $ , const $*);]], mod.VkDevice, mod.VkDescriptorUpdateTemplate, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkUpdateDescriptorSetWithTemplateKHR($ , $ , $ , const void*);]], mod.VkDevice, mod.VkDescriptorSet, mod.VkDescriptorUpdateTemplate)
mod.VkPhysicalDeviceImagelessFramebufferFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceImagelessFramebufferFeatures)
mod.VkFramebufferAttachmentsCreateInfoKHR = ffi.typeof([[$ ]], mod.VkFramebufferAttachmentsCreateInfo)
mod.VkFramebufferAttachmentImageInfoKHR = ffi.typeof([[$ ]], mod.VkFramebufferAttachmentImageInfo)
mod.VkRenderPassAttachmentBeginInfoKHR = ffi.typeof([[$ ]], mod.VkRenderPassAttachmentBeginInfo)
mod.VkRenderPassCreateInfo2KHR = ffi.typeof([[$ ]], mod.VkRenderPassCreateInfo2)
mod.VkAttachmentDescription2KHR = ffi.typeof([[$ ]], mod.VkAttachmentDescription2)
mod.VkAttachmentReference2KHR = ffi.typeof([[$ ]], mod.VkAttachmentReference2)
mod.VkSubpassDescription2KHR = ffi.typeof([[$ ]], mod.VkSubpassDescription2)
mod.VkSubpassDependency2KHR = ffi.typeof([[$ ]], mod.VkSubpassDependency2)
mod.VkSubpassBeginInfoKHR = ffi.typeof([[$ ]], mod.VkSubpassBeginInfo)
mod.VkSubpassEndInfoKHR = ffi.typeof([[$ ]], mod.VkSubpassEndInfo)
mod.PFN_vkCreateRenderPass2KHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkRenderPassCreateInfo2, mod.VkAllocationCallbacks, mod.VkRenderPass)
mod.PFN_vkCmdBeginRenderPass2KHR = ffi.typeof([[void (*)($ , const $*, const $*)]], mod.VkCommandBuffer, mod.VkRenderPassBeginInfo, mod.VkSubpassBeginInfo)
mod.PFN_vkCmdNextSubpass2KHR = ffi.typeof([[void (*)($ , const $*, const $*)]], mod.VkCommandBuffer, mod.VkSubpassBeginInfo, mod.VkSubpassEndInfo)
mod.PFN_vkCmdEndRenderPass2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkSubpassEndInfo)
ffi.cdef([[$  vkCreateRenderPass2KHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkRenderPassCreateInfo2, mod.VkAllocationCallbacks, mod.VkRenderPass)
ffi.cdef([[void  vkCmdBeginRenderPass2KHR($ , const $*, const $*);]], mod.VkCommandBuffer, mod.VkRenderPassBeginInfo, mod.VkSubpassBeginInfo)
ffi.cdef([[void  vkCmdNextSubpass2KHR($ , const $*, const $*);]], mod.VkCommandBuffer, mod.VkSubpassBeginInfo, mod.VkSubpassEndInfo)
ffi.cdef([[void  vkCmdEndRenderPass2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkSubpassEndInfo)
mod.VkSharedPresentSurfaceCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ sharedPresentSupportedUsageFlags;
}]], mod.VkStructureType, mod.VkImageUsageFlags)
mod.PFN_vkGetSwapchainStatusKHR = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR)
ffi.cdef([[$  vkGetSwapchainStatusKHR($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR)
mod.VkExternalFenceHandleTypeFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalFenceHandleTypeFlags)
mod.VkExternalFenceHandleTypeFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalFenceHandleTypeFlagBits)
mod.VkExternalFenceFeatureFlagsKHR = ffi.typeof([[$ ]], mod.VkExternalFenceFeatureFlags)
mod.VkExternalFenceFeatureFlagBitsKHR = ffi.typeof([[$ ]], mod.VkExternalFenceFeatureFlagBits)
mod.VkPhysicalDeviceExternalFenceInfoKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceExternalFenceInfo)
mod.VkExternalFencePropertiesKHR = ffi.typeof([[$ ]], mod.VkExternalFenceProperties)
mod.PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalFenceInfo, mod.VkExternalFenceProperties)
ffi.cdef([[void  vkGetPhysicalDeviceExternalFencePropertiesKHR($ , const $*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalFenceInfo, mod.VkExternalFenceProperties)
mod.VkFenceImportFlagsKHR = ffi.typeof([[$ ]], mod.VkFenceImportFlags)
mod.VkFenceImportFlagBitsKHR = ffi.typeof([[$ ]], mod.VkFenceImportFlagBits)
mod.VkExportFenceCreateInfoKHR = ffi.typeof([[$ ]], mod.VkExportFenceCreateInfo)
mod.VkImportFenceFdInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ fence;
	$ flags;
	$ handleType;
	int fd;
}]], mod.VkStructureType, mod.VkFence, mod.VkFenceImportFlags, mod.VkExternalFenceHandleTypeFlagBits)
mod.VkFenceGetFdInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ fence;
	$ handleType;
}]], mod.VkStructureType, mod.VkFence, mod.VkExternalFenceHandleTypeFlagBits)
mod.PFN_vkImportFenceFdKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkImportFenceFdInfoKHR)
mod.PFN_vkGetFenceFdKHR = ffi.typeof([[$ (*)($ , const $*, int*)]], mod.VkResult, mod.VkDevice, mod.VkFenceGetFdInfoKHR)
ffi.cdef([[$  vkImportFenceFdKHR($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkImportFenceFdInfoKHR)
ffi.cdef([[$  vkGetFenceFdKHR($ , const $*, int*);]], mod.VkResult, mod.VkDevice, mod.VkFenceGetFdInfoKHR)
mod.VkPerformanceCounterUnitKHR = ffi.typeof([[enum {
	VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
	VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
	VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
	VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
	VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
	VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
	VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
	VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
	VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
	VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPerformanceCounterScopeKHR = ffi.typeof([[enum {
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
	VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
	VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
	VK_QUERY_SCOPE_RENDER_PASS_KHR = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
	VK_QUERY_SCOPE_COMMAND_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
	VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPerformanceCounterStorageKHR = ffi.typeof([[enum {
	VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
	VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
	VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPerformanceCounterDescriptionFlagBitsKHR = ffi.typeof([[enum {
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x00000001,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x00000002,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPerformanceCounterDescriptionFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAcquireProfilingLockFlagBitsKHR = ffi.typeof([[enum {
	VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAcquireProfilingLockFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDevicePerformanceQueryFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ performanceCounterQueryPools;
	$ performanceCounterMultipleQueryPools;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDevicePerformanceQueryPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ allowCommandBufferQueryCopies;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPerformanceCounterKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ unit;
	$ scope;
	$ storage;
	uint8_t uuid[16U];
}]], mod.VkStructureType, mod.VkPerformanceCounterUnitKHR, mod.VkPerformanceCounterScopeKHR, mod.VkPerformanceCounterStorageKHR)
mod.VkPerformanceCounterDescriptionKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	char name[256U];
	char category[256U];
	char description[256U];
}]], mod.VkStructureType, mod.VkPerformanceCounterDescriptionFlagsKHR)
mod.VkQueryPoolPerformanceCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t queueFamilyIndex;
	uint32_t counterIndexCount;
	const uint32_t* pCounterIndices;
}]], mod.VkStructureType)
mod.VkPerformanceCounterResultKHR = ffi.typeof([[union {
	int32_t int32;
	int64_t int64;
	uint32_t uint32;
	uint64_t uint64;
	float float32;
	double float64;
}]])
mod.VkAcquireProfilingLockInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint64_t timeout;
}]], mod.VkStructureType, mod.VkAcquireProfilingLockFlagsKHR)
mod.VkPerformanceQuerySubmitInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t counterPassIndex;
}]], mod.VkStructureType)
mod.PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = ffi.typeof([[$ (*)($ , uint32_t , uint32_t*, $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPerformanceCounterKHR, mod.VkPerformanceCounterDescriptionKHR)
mod.PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = ffi.typeof([[void (*)($ , const $*, uint32_t*)]], mod.VkPhysicalDevice, mod.VkQueryPoolPerformanceCreateInfoKHR)
mod.PFN_vkAcquireProfilingLockKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkAcquireProfilingLockInfoKHR)
mod.PFN_vkReleaseProfilingLockKHR = ffi.typeof([[void (*)($ )]], mod.VkDevice)
ffi.cdef([[$  vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR($ , uint32_t , uint32_t*, $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPerformanceCounterKHR, mod.VkPerformanceCounterDescriptionKHR)
ffi.cdef([[void  vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR($ , const $*, uint32_t*);]], mod.VkPhysicalDevice, mod.VkQueryPoolPerformanceCreateInfoKHR)
ffi.cdef([[$  vkAcquireProfilingLockKHR($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkAcquireProfilingLockInfoKHR)
ffi.cdef([[void  vkReleaseProfilingLockKHR($ );]], mod.VkDevice)
mod.VkPointClippingBehaviorKHR = ffi.typeof([[$ ]], mod.VkPointClippingBehavior)
mod.VkTessellationDomainOriginKHR = ffi.typeof([[$ ]], mod.VkTessellationDomainOrigin)
mod.VkPhysicalDevicePointClippingPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDevicePointClippingProperties)
mod.VkRenderPassInputAttachmentAspectCreateInfoKHR = ffi.typeof([[$ ]], mod.VkRenderPassInputAttachmentAspectCreateInfo)
mod.VkInputAttachmentAspectReferenceKHR = ffi.typeof([[$ ]], mod.VkInputAttachmentAspectReference)
mod.VkImageViewUsageCreateInfoKHR = ffi.typeof([[$ ]], mod.VkImageViewUsageCreateInfo)
mod.VkPipelineTessellationDomainOriginStateCreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineTessellationDomainOriginStateCreateInfo)
mod.VkPhysicalDeviceSurfaceInfo2KHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ surface;
}]], mod.VkStructureType, mod.VkSurfaceKHR)
mod.VkSurfaceCapabilities2KHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ surfaceCapabilities;
}]], mod.VkStructureType, mod.VkSurfaceCapabilitiesKHR)
mod.VkSurfaceFormat2KHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ surfaceFormat;
}]], mod.VkStructureType, mod.VkSurfaceFormatKHR)
mod.PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceSurfaceInfo2KHR, mod.VkSurfaceCapabilities2KHR)
mod.PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = ffi.typeof([[$ (*)($ , const $*, uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceSurfaceInfo2KHR, mod.VkSurfaceFormat2KHR)
ffi.cdef([[$  vkGetPhysicalDeviceSurfaceCapabilities2KHR($ , const $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceSurfaceInfo2KHR, mod.VkSurfaceCapabilities2KHR)
ffi.cdef([[$  vkGetPhysicalDeviceSurfaceFormats2KHR($ , const $*, uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceSurfaceInfo2KHR, mod.VkSurfaceFormat2KHR)
mod.VkPhysicalDeviceVariablePointerFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVariablePointersFeatures)
mod.VkPhysicalDeviceVariablePointersFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVariablePointersFeatures)
mod.VkDisplayProperties2KHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ displayProperties;
}]], mod.VkStructureType, mod.VkDisplayPropertiesKHR)
mod.VkDisplayPlaneProperties2KHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ displayPlaneProperties;
}]], mod.VkStructureType, mod.VkDisplayPlanePropertiesKHR)
mod.VkDisplayModeProperties2KHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ displayModeProperties;
}]], mod.VkStructureType, mod.VkDisplayModePropertiesKHR)
mod.VkDisplayPlaneInfo2KHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ mode;
	uint32_t planeIndex;
}]], mod.VkStructureType, mod.VkDisplayModeKHR)
mod.VkDisplayPlaneCapabilities2KHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ capabilities;
}]], mod.VkStructureType, mod.VkDisplayPlaneCapabilitiesKHR)
mod.PFN_vkGetPhysicalDeviceDisplayProperties2KHR = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayProperties2KHR)
mod.PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayPlaneProperties2KHR)
mod.PFN_vkGetDisplayModeProperties2KHR = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR, mod.VkDisplayModeProperties2KHR)
mod.PFN_vkGetDisplayPlaneCapabilities2KHR = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayPlaneInfo2KHR, mod.VkDisplayPlaneCapabilities2KHR)
ffi.cdef([[$  vkGetPhysicalDeviceDisplayProperties2KHR($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayProperties2KHR)
ffi.cdef([[$  vkGetPhysicalDeviceDisplayPlaneProperties2KHR($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayPlaneProperties2KHR)
ffi.cdef([[$  vkGetDisplayModeProperties2KHR($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR, mod.VkDisplayModeProperties2KHR)
ffi.cdef([[$  vkGetDisplayPlaneCapabilities2KHR($ , const $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayPlaneInfo2KHR, mod.VkDisplayPlaneCapabilities2KHR)
mod.VkMemoryDedicatedRequirementsKHR = ffi.typeof([[$ ]], mod.VkMemoryDedicatedRequirements)
mod.VkMemoryDedicatedAllocateInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryDedicatedAllocateInfo)
mod.VkPhysicalDeviceShaderBfloat16FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderBFloat16Type;
	$ shaderBFloat16DotProduct;
	$ shaderBFloat16CooperativeMatrix;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkBufferMemoryRequirementsInfo2KHR = ffi.typeof([[$ ]], mod.VkBufferMemoryRequirementsInfo2)
mod.VkImageMemoryRequirementsInfo2KHR = ffi.typeof([[$ ]], mod.VkImageMemoryRequirementsInfo2)
mod.VkImageSparseMemoryRequirementsInfo2KHR = ffi.typeof([[$ ]], mod.VkImageSparseMemoryRequirementsInfo2)
mod.VkMemoryRequirements2KHR = ffi.typeof([[$ ]], mod.VkMemoryRequirements2)
mod.VkSparseImageMemoryRequirements2KHR = ffi.typeof([[$ ]], mod.VkSparseImageMemoryRequirements2)
mod.PFN_vkGetImageMemoryRequirements2KHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkImageMemoryRequirementsInfo2, mod.VkMemoryRequirements2)
mod.PFN_vkGetBufferMemoryRequirements2KHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkBufferMemoryRequirementsInfo2, mod.VkMemoryRequirements2)
mod.PFN_vkGetImageSparseMemoryRequirements2KHR = ffi.typeof([[void (*)($ , const $*, uint32_t*, $*)]], mod.VkDevice, mod.VkImageSparseMemoryRequirementsInfo2, mod.VkSparseImageMemoryRequirements2)
ffi.cdef([[void  vkGetImageMemoryRequirements2KHR($ , const $*, $*);]], mod.VkDevice, mod.VkImageMemoryRequirementsInfo2, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkGetBufferMemoryRequirements2KHR($ , const $*, $*);]], mod.VkDevice, mod.VkBufferMemoryRequirementsInfo2, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkGetImageSparseMemoryRequirements2KHR($ , const $*, uint32_t*, $*);]], mod.VkDevice, mod.VkImageSparseMemoryRequirementsInfo2, mod.VkSparseImageMemoryRequirements2)
mod.VkImageFormatListCreateInfoKHR = ffi.typeof([[$ ]], mod.VkImageFormatListCreateInfo)
mod.VkSamplerYcbcrConversionKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrConversion)
mod.VkSamplerYcbcrModelConversionKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrModelConversion)
mod.VkSamplerYcbcrRangeKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrRange)
mod.VkChromaLocationKHR = ffi.typeof([[$ ]], mod.VkChromaLocation)
mod.VkSamplerYcbcrConversionCreateInfoKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrConversionCreateInfo)
mod.VkSamplerYcbcrConversionInfoKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrConversionInfo)
mod.VkBindImagePlaneMemoryInfoKHR = ffi.typeof([[$ ]], mod.VkBindImagePlaneMemoryInfo)
mod.VkImagePlaneMemoryRequirementsInfoKHR = ffi.typeof([[$ ]], mod.VkImagePlaneMemoryRequirementsInfo)
mod.VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSamplerYcbcrConversionFeatures)
mod.VkSamplerYcbcrConversionImageFormatPropertiesKHR = ffi.typeof([[$ ]], mod.VkSamplerYcbcrConversionImageFormatProperties)
mod.PFN_vkCreateSamplerYcbcrConversionKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkSamplerYcbcrConversionCreateInfo, mod.VkAllocationCallbacks, mod.VkSamplerYcbcrConversion)
mod.PFN_vkDestroySamplerYcbcrConversionKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkSamplerYcbcrConversion, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateSamplerYcbcrConversionKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkSamplerYcbcrConversionCreateInfo, mod.VkAllocationCallbacks, mod.VkSamplerYcbcrConversion)
ffi.cdef([[void  vkDestroySamplerYcbcrConversionKHR($ , $ , const $*);]], mod.VkDevice, mod.VkSamplerYcbcrConversion, mod.VkAllocationCallbacks)
mod.VkBindBufferMemoryInfoKHR = ffi.typeof([[$ ]], mod.VkBindBufferMemoryInfo)
mod.VkBindImageMemoryInfoKHR = ffi.typeof([[$ ]], mod.VkBindImageMemoryInfo)
mod.PFN_vkBindBufferMemory2KHR = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkBindBufferMemoryInfo)
mod.PFN_vkBindImageMemory2KHR = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkBindImageMemoryInfo)
ffi.cdef([[$  vkBindBufferMemory2KHR($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkBindBufferMemoryInfo)
ffi.cdef([[$  vkBindImageMemory2KHR($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkBindImageMemoryInfo)
mod.VkPhysicalDeviceMaintenance3PropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance3Properties)
mod.VkDescriptorSetLayoutSupportKHR = ffi.typeof([[$ ]], mod.VkDescriptorSetLayoutSupport)
mod.PFN_vkGetDescriptorSetLayoutSupportKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDescriptorSetLayoutCreateInfo, mod.VkDescriptorSetLayoutSupport)
ffi.cdef([[void  vkGetDescriptorSetLayoutSupportKHR($ , const $*, $*);]], mod.VkDevice, mod.VkDescriptorSetLayoutCreateInfo, mod.VkDescriptorSetLayoutSupport)
mod.PFN_vkCmdDrawIndirectCountKHR = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdDrawIndexedIndirectCountKHR = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawIndirectCountKHR($ , $ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawIndexedIndirectCountKHR($ , $ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
mod.VkPhysicalDevice8BitStorageFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDevice8BitStorageFeatures)
mod.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderAtomicInt64Features)
mod.VkPhysicalDeviceShaderClockFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderSubgroupClock;
	$ shaderDeviceClock;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.StdVideoDecodeH265PictureInfoFlags = ffi.typeof([[struct {
	uint32_t IrapPicFlag;
	uint32_t IdrPicFlag;
	uint32_t IsReference;
	uint32_t short_term_ref_pic_set_sps_flag;
}]])
mod.StdVideoDecodeH265PictureInfo = ffi.typeof([[struct {
	$ flags;
	uint8_t sps_video_parameter_set_id;
	uint8_t pps_seq_parameter_set_id;
	uint8_t pps_pic_parameter_set_id;
	uint8_t NumDeltaPocsOfRefRpsIdx;
	int32_t PicOrderCntVal;
	uint16_t NumBitsForSTRefPicSetInSlice;
	uint16_t reserved;
	uint8_t RefPicSetStCurrBefore[8U];
	uint8_t RefPicSetStCurrAfter[8U];
	uint8_t RefPicSetLtCurr[8U];
}]], mod.StdVideoDecodeH265PictureInfoFlags)
mod.StdVideoDecodeH265ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t used_for_long_term_reference;
	uint32_t unused_for_reference;
}]])
mod.StdVideoDecodeH265ReferenceInfo = ffi.typeof([[struct {
	$ flags;
	int32_t PicOrderCntVal;
}]], mod.StdVideoDecodeH265ReferenceInfoFlags)
mod.VkVideoDecodeH265ProfileInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stdProfileIdc;
}]], mod.VkStructureType, mod.StdVideoH265ProfileIdc)
mod.VkVideoDecodeH265CapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxLevelIdc;
}]], mod.VkStructureType, mod.StdVideoH265LevelIdc)
mod.VkVideoDecodeH265SessionParametersAddInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t stdVPSCount;
	const $* pStdVPSs;
	uint32_t stdSPSCount;
	const $* pStdSPSs;
	uint32_t stdPPSCount;
	const $* pStdPPSs;
}]], mod.VkStructureType, mod.StdVideoH265VideoParameterSet, mod.StdVideoH265SequenceParameterSet, mod.StdVideoH265PictureParameterSet)
mod.VkVideoDecodeH265SessionParametersCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maxStdVPSCount;
	uint32_t maxStdSPSCount;
	uint32_t maxStdPPSCount;
	const $* pParametersAddInfo;
}]], mod.VkStructureType, mod.VkVideoDecodeH265SessionParametersAddInfoKHR)
mod.VkVideoDecodeH265PictureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdPictureInfo;
	uint32_t sliceSegmentCount;
	const uint32_t* pSliceSegmentOffsets;
}]], mod.VkStructureType, mod.StdVideoDecodeH265PictureInfo)
mod.VkVideoDecodeH265DpbSlotInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]], mod.VkStructureType, mod.StdVideoDecodeH265ReferenceInfo)
mod.VkQueueGlobalPriorityKHR = ffi.typeof([[$ ]], mod.VkQueueGlobalPriority)
mod.VkDeviceQueueGlobalPriorityCreateInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceQueueGlobalPriorityCreateInfo)
mod.VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceGlobalPriorityQueryFeatures)
mod.VkQueueFamilyGlobalPriorityPropertiesKHR = ffi.typeof([[$ ]], mod.VkQueueFamilyGlobalPriorityProperties)
mod.VkDriverIdKHR = ffi.typeof([[$ ]], mod.VkDriverId)
mod.VkConformanceVersionKHR = ffi.typeof([[$ ]], mod.VkConformanceVersion)
mod.VkPhysicalDeviceDriverPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDriverProperties)
mod.VkShaderFloatControlsIndependenceKHR = ffi.typeof([[$ ]], mod.VkShaderFloatControlsIndependence)
mod.VkPhysicalDeviceFloatControlsPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFloatControlsProperties)
mod.VkResolveModeFlagBitsKHR = ffi.typeof([[$ ]], mod.VkResolveModeFlagBits)
mod.VkResolveModeFlagsKHR = ffi.typeof([[$ ]], mod.VkResolveModeFlags)
mod.VkSubpassDescriptionDepthStencilResolveKHR = ffi.typeof([[$ ]], mod.VkSubpassDescriptionDepthStencilResolve)
mod.VkPhysicalDeviceDepthStencilResolvePropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDepthStencilResolveProperties)
mod.VkSemaphoreTypeKHR = ffi.typeof([[$ ]], mod.VkSemaphoreType)
mod.VkSemaphoreWaitFlagBitsKHR = ffi.typeof([[$ ]], mod.VkSemaphoreWaitFlagBits)
mod.VkSemaphoreWaitFlagsKHR = ffi.typeof([[$ ]], mod.VkSemaphoreWaitFlags)
mod.VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceTimelineSemaphoreFeatures)
mod.VkPhysicalDeviceTimelineSemaphorePropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceTimelineSemaphoreProperties)
mod.VkSemaphoreTypeCreateInfoKHR = ffi.typeof([[$ ]], mod.VkSemaphoreTypeCreateInfo)
mod.VkTimelineSemaphoreSubmitInfoKHR = ffi.typeof([[$ ]], mod.VkTimelineSemaphoreSubmitInfo)
mod.VkSemaphoreWaitInfoKHR = ffi.typeof([[$ ]], mod.VkSemaphoreWaitInfo)
mod.VkSemaphoreSignalInfoKHR = ffi.typeof([[$ ]], mod.VkSemaphoreSignalInfo)
mod.PFN_vkGetSemaphoreCounterValueKHR = ffi.typeof([[$ (*)($ , $ , uint64_t*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphore)
mod.PFN_vkWaitSemaphoresKHR = ffi.typeof([[$ (*)($ , const $*, uint64_t )]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreWaitInfo)
mod.PFN_vkSignalSemaphoreKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreSignalInfo)
ffi.cdef([[$  vkGetSemaphoreCounterValueKHR($ , $ , uint64_t*);]], mod.VkResult, mod.VkDevice, mod.VkSemaphore)
ffi.cdef([[$  vkWaitSemaphoresKHR($ , const $*, uint64_t );]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreWaitInfo)
ffi.cdef([[$  vkSignalSemaphoreKHR($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkSemaphoreSignalInfo)
mod.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVulkanMemoryModelFeatures)
mod.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderTerminateInvocationFeatures)
mod.VkFragmentShadingRateCombinerOpKHR = ffi.typeof([[enum {
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkFragmentShadingRateAttachmentInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pFragmentShadingRateAttachment;
	$ shadingRateAttachmentTexelSize;
}]], mod.VkStructureType, mod.VkAttachmentReference2, mod.VkExtent2D)
mod.VkPipelineFragmentShadingRateStateCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ fragmentSize;
	$ combinerOps[2];
}]], mod.VkStructureType, mod.VkExtent2D, mod.VkFragmentShadingRateCombinerOpKHR)
mod.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineFragmentShadingRate;
	$ primitiveFragmentShadingRate;
	$ attachmentFragmentShadingRate;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceFragmentShadingRatePropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ minFragmentShadingRateAttachmentTexelSize;
	$ maxFragmentShadingRateAttachmentTexelSize;
	uint32_t maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
	$ primitiveFragmentShadingRateWithMultipleViewports;
	$ layeredShadingRateAttachments;
	$ fragmentShadingRateNonTrivialCombinerOps;
	$ maxFragmentSize;
	uint32_t maxFragmentSizeAspectRatio;
	uint32_t maxFragmentShadingRateCoverageSamples;
	$ maxFragmentShadingRateRasterizationSamples;
	$ fragmentShadingRateWithShaderDepthStencilWrites;
	$ fragmentShadingRateWithSampleMask;
	$ fragmentShadingRateWithShaderSampleMask;
	$ fragmentShadingRateWithConservativeRasterization;
	$ fragmentShadingRateWithFragmentShaderInterlock;
	$ fragmentShadingRateWithCustomSampleLocations;
	$ fragmentShadingRateStrictMultiplyCombiner;
}]], mod.VkStructureType, mod.VkExtent2D, mod.VkExtent2D, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkExtent2D, mod.VkSampleCountFlagBits, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceFragmentShadingRateKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ sampleCounts;
	$ fragmentSize;
}]], mod.VkStructureType, mod.VkSampleCountFlags, mod.VkExtent2D)
mod.VkRenderingFragmentShadingRateAttachmentInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ imageView;
	$ imageLayout;
	$ shadingRateAttachmentTexelSize;
}]], mod.VkStructureType, mod.VkImageView, mod.VkImageLayout, mod.VkExtent2D)
mod.PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceFragmentShadingRateKHR)
mod.PFN_vkCmdSetFragmentShadingRateKHR = ffi.typeof([[void (*)($ , const $*, const $[2])]], mod.VkCommandBuffer, mod.VkExtent2D, mod.VkFragmentShadingRateCombinerOpKHR)
ffi.cdef([[$  vkGetPhysicalDeviceFragmentShadingRatesKHR($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceFragmentShadingRateKHR)
ffi.cdef([[void  vkCmdSetFragmentShadingRateKHR($ , const $*, const $[2]);]], mod.VkCommandBuffer, mod.VkExtent2D, mod.VkFragmentShadingRateCombinerOpKHR)
mod.VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDynamicRenderingLocalReadFeatures)
mod.VkRenderingAttachmentLocationInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingAttachmentLocationInfo)
mod.VkRenderingInputAttachmentIndexInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingInputAttachmentIndexInfo)
mod.PFN_vkCmdSetRenderingAttachmentLocationsKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingAttachmentLocationInfo)
mod.PFN_vkCmdSetRenderingInputAttachmentIndicesKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingInputAttachmentIndexInfo)
ffi.cdef([[void  vkCmdSetRenderingAttachmentLocationsKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkRenderingAttachmentLocationInfo)
ffi.cdef([[void  vkCmdSetRenderingInputAttachmentIndicesKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkRenderingInputAttachmentIndexInfo)
mod.VkPhysicalDeviceShaderQuadControlFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderQuadControl;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSurfaceProtectedCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ supportsProtected;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
mod.VkAttachmentReferenceStencilLayoutKHR = ffi.typeof([[$ ]], mod.VkAttachmentReferenceStencilLayout)
mod.VkAttachmentDescriptionStencilLayoutKHR = ffi.typeof([[$ ]], mod.VkAttachmentDescriptionStencilLayout)
mod.VkPhysicalDevicePresentWaitFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentWait;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkWaitForPresentKHR = ffi.typeof([[$ (*)($ , $ , uint64_t , uint64_t )]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR)
ffi.cdef([[$  vkWaitForPresentKHR($ , $ , uint64_t , uint64_t );]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR)
mod.VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
mod.VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceBufferDeviceAddressFeatures)
mod.VkBufferDeviceAddressInfoKHR = ffi.typeof([[$ ]], mod.VkBufferDeviceAddressInfo)
mod.VkBufferOpaqueCaptureAddressCreateInfoKHR = ffi.typeof([[$ ]], mod.VkBufferOpaqueCaptureAddressCreateInfo)
mod.VkMemoryOpaqueCaptureAddressAllocateInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryOpaqueCaptureAddressAllocateInfo)
mod.VkDeviceMemoryOpaqueCaptureAddressInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceMemoryOpaqueCaptureAddressInfo)
mod.PFN_vkGetBufferDeviceAddressKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkDeviceAddress, mod.VkDevice, mod.VkBufferDeviceAddressInfo)
mod.PFN_vkGetBufferOpaqueCaptureAddressKHR = ffi.typeof([[uint64_t (*)($ , const $*)]], mod.VkDevice, mod.VkBufferDeviceAddressInfo)
mod.PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR = ffi.typeof([[uint64_t (*)($ , const $*)]], mod.VkDevice, mod.VkDeviceMemoryOpaqueCaptureAddressInfo)
ffi.cdef([[$  vkGetBufferDeviceAddressKHR($ , const $*);]], mod.VkDeviceAddress, mod.VkDevice, mod.VkBufferDeviceAddressInfo)
ffi.cdef([[uint64_t  vkGetBufferOpaqueCaptureAddressKHR($ , const $*);]], mod.VkDevice, mod.VkBufferDeviceAddressInfo)
ffi.cdef([[uint64_t  vkGetDeviceMemoryOpaqueCaptureAddressKHR($ , const $*);]], mod.VkDevice, mod.VkDeviceMemoryOpaqueCaptureAddressInfo)
mod.VkDeferredOperationKHR = ffi.typeof([[void*]])
mod.PFN_vkCreateDeferredOperationKHR = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkAllocationCallbacks, mod.VkDeferredOperationKHR)
mod.PFN_vkDestroyDeferredOperationKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkAllocationCallbacks)
mod.PFN_vkGetDeferredOperationMaxConcurrencyKHR = ffi.typeof([[uint32_t (*)($ , $ )]], mod.VkDevice, mod.VkDeferredOperationKHR)
mod.PFN_vkGetDeferredOperationResultKHR = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR)
mod.PFN_vkDeferredOperationJoinKHR = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR)
ffi.cdef([[$  vkCreateDeferredOperationKHR($ , const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkAllocationCallbacks, mod.VkDeferredOperationKHR)
ffi.cdef([[void  vkDestroyDeferredOperationKHR($ , $ , const $*);]], mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkAllocationCallbacks)
ffi.cdef([[uint32_t  vkGetDeferredOperationMaxConcurrencyKHR($ , $ );]], mod.VkDevice, mod.VkDeferredOperationKHR)
ffi.cdef([[$  vkGetDeferredOperationResultKHR($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR)
ffi.cdef([[$  vkDeferredOperationJoinKHR($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR)
mod.VkPipelineExecutableStatisticFormatKHR = ffi.typeof([[enum {
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineExecutableInfo;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ pipeline;
}]], mod.VkStructureType, mod.VkPipeline)
mod.VkPipelineExecutablePropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ stages;
	char name[256U];
	char description[256U];
	uint32_t subgroupSize;
}]], mod.VkStructureType, mod.VkShaderStageFlags)
mod.VkPipelineExecutableInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ pipeline;
	uint32_t executableIndex;
}]], mod.VkStructureType, mod.VkPipeline)
mod.VkPipelineExecutableStatisticValueKHR = ffi.typeof([[union {
	$ b32;
	int64_t i64;
	uint64_t u64;
	double f64;
}]], mod.VkBool32)
mod.VkPipelineExecutableStatisticKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	char name[256U];
	char description[256U];
	$ format;
	$ value;
}]], mod.VkStructureType, mod.VkPipelineExecutableStatisticFormatKHR, mod.VkPipelineExecutableStatisticValueKHR)
mod.VkPipelineExecutableInternalRepresentationKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	char name[256U];
	char description[256U];
	$ isText;
	size_t dataSize;
	void* pData;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkGetPipelineExecutablePropertiesKHR = ffi.typeof([[$ (*)($ , const $*, uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineInfoKHR, mod.VkPipelineExecutablePropertiesKHR)
mod.PFN_vkGetPipelineExecutableStatisticsKHR = ffi.typeof([[$ (*)($ , const $*, uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineExecutableInfoKHR, mod.VkPipelineExecutableStatisticKHR)
mod.PFN_vkGetPipelineExecutableInternalRepresentationsKHR = ffi.typeof([[$ (*)($ , const $*, uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineExecutableInfoKHR, mod.VkPipelineExecutableInternalRepresentationKHR)
ffi.cdef([[$  vkGetPipelineExecutablePropertiesKHR($ , const $*, uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineInfoKHR, mod.VkPipelineExecutablePropertiesKHR)
ffi.cdef([[$  vkGetPipelineExecutableStatisticsKHR($ , const $*, uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineExecutableInfoKHR, mod.VkPipelineExecutableStatisticKHR)
ffi.cdef([[$  vkGetPipelineExecutableInternalRepresentationsKHR($ , const $*, uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineExecutableInfoKHR, mod.VkPipelineExecutableInternalRepresentationKHR)
mod.VkMemoryUnmapFlagBitsKHR = ffi.typeof([[$ ]], mod.VkMemoryUnmapFlagBits)
mod.VkMemoryUnmapFlagsKHR = ffi.typeof([[$ ]], mod.VkMemoryUnmapFlags)
mod.VkMemoryMapInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryMapInfo)
mod.VkMemoryUnmapInfoKHR = ffi.typeof([[$ ]], mod.VkMemoryUnmapInfo)
mod.PFN_vkMapMemory2KHR = ffi.typeof([[$ (*)($ , const $*, void**)]], mod.VkResult, mod.VkDevice, mod.VkMemoryMapInfo)
mod.PFN_vkUnmapMemory2KHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkMemoryUnmapInfo)
ffi.cdef([[$  vkMapMemory2KHR($ , const $*, void**);]], mod.VkResult, mod.VkDevice, mod.VkMemoryMapInfo)
ffi.cdef([[$  vkUnmapMemory2KHR($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkMemoryUnmapInfo)
mod.VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderIntegerDotProductFeatures)
mod.VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderIntegerDotProductProperties)
mod.VkPipelineLibraryCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t libraryCount;
	const $* pLibraries;
}]], mod.VkStructureType, mod.VkPipeline)
mod.VkPresentIdKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const uint64_t* pPresentIds;
}]], mod.VkStructureType)
mod.VkPhysicalDevicePresentIdFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentId;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoEncodeTuningModeKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
	VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
	VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
	VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
	VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeCapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeCapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeRateControlModeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeRateControlModeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeFeedbackFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeFeedbackFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeUsageFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeUsageFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeContentFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeContentFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeRateControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ dstBuffer;
	$ dstBufferOffset;
	$ dstBufferRange;
	$ srcPictureResource;
	const $* pSetupReferenceSlot;
	uint32_t referenceSlotCount;
	const $* pReferenceSlots;
	uint32_t precedingExternallyEncodedBytes;
}]], mod.VkStructureType, mod.VkVideoEncodeFlagsKHR, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkVideoPictureResourceInfoKHR, mod.VkVideoReferenceSlotInfoKHR, mod.VkVideoReferenceSlotInfoKHR)
mod.VkVideoEncodeCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ rateControlModes;
	uint32_t maxRateControlLayers;
	uint64_t maxBitrate;
	uint32_t maxQualityLevels;
	$ encodeInputPictureGranularity;
	$ supportedEncodeFeedbackFlags;
}]], mod.VkStructureType, mod.VkVideoEncodeCapabilityFlagsKHR, mod.VkVideoEncodeRateControlModeFlagsKHR, mod.VkExtent2D, mod.VkVideoEncodeFeedbackFlagsKHR)
mod.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ encodeFeedbackFlags;
}]], mod.VkStructureType, mod.VkVideoEncodeFeedbackFlagsKHR)
mod.VkVideoEncodeUsageInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ videoUsageHints;
	$ videoContentHints;
	$ tuningMode;
}]], mod.VkStructureType, mod.VkVideoEncodeUsageFlagsKHR, mod.VkVideoEncodeContentFlagsKHR, mod.VkVideoEncodeTuningModeKHR)
mod.VkVideoEncodeRateControlLayerInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t averageBitrate;
	uint64_t maxBitrate;
	uint32_t frameRateNumerator;
	uint32_t frameRateDenominator;
}]], mod.VkStructureType)
mod.VkVideoEncodeRateControlInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ rateControlMode;
	uint32_t layerCount;
	const $* pLayers;
	uint32_t virtualBufferSizeInMs;
	uint32_t initialVirtualBufferSizeInMs;
}]], mod.VkStructureType, mod.VkVideoEncodeRateControlFlagsKHR, mod.VkVideoEncodeRateControlModeFlagBitsKHR, mod.VkVideoEncodeRateControlLayerInfoKHR)
mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pVideoProfile;
	uint32_t qualityLevel;
}]], mod.VkStructureType, mod.VkVideoProfileInfoKHR)
mod.VkVideoEncodeQualityLevelPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ preferredRateControlMode;
	uint32_t preferredRateControlLayerCount;
}]], mod.VkStructureType, mod.VkVideoEncodeRateControlModeFlagBitsKHR)
mod.VkVideoEncodeQualityLevelInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t qualityLevel;
}]], mod.VkStructureType)
mod.VkVideoEncodeSessionParametersGetInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ videoSessionParameters;
}]], mod.VkStructureType, mod.VkVideoSessionParametersKHR)
mod.VkVideoEncodeSessionParametersFeedbackInfoKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ hasOverrides;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, mod.VkVideoEncodeQualityLevelPropertiesKHR)
mod.PFN_vkGetEncodedVideoSessionParametersKHR = ffi.typeof([[$ (*)($ , const $*, $*, size_t*, void*)]], mod.VkResult, mod.VkDevice, mod.VkVideoEncodeSessionParametersGetInfoKHR, mod.VkVideoEncodeSessionParametersFeedbackInfoKHR)
mod.PFN_vkCmdEncodeVideoKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkVideoEncodeInfoKHR)
ffi.cdef([[$  vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR($ , const $*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, mod.VkVideoEncodeQualityLevelPropertiesKHR)
ffi.cdef([[$  vkGetEncodedVideoSessionParametersKHR($ , const $*, $*, size_t*, void*);]], mod.VkResult, mod.VkDevice, mod.VkVideoEncodeSessionParametersGetInfoKHR, mod.VkVideoEncodeSessionParametersFeedbackInfoKHR)
ffi.cdef([[void  vkCmdEncodeVideoKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkVideoEncodeInfoKHR)
mod.VkPipelineStageFlags2KHR = ffi.typeof([[$ ]], mod.VkPipelineStageFlags2)
mod.VkPipelineStageFlagBits2KHR = ffi.typeof([[$ ]], mod.VkPipelineStageFlagBits2)
mod.VkAccessFlags2KHR = ffi.typeof([[$ ]], mod.VkAccessFlags2)
mod.VkAccessFlagBits2KHR = ffi.typeof([[$ ]], mod.VkAccessFlagBits2)
mod.VkSubmitFlagBitsKHR = ffi.typeof([[$ ]], mod.VkSubmitFlagBits)
mod.VkSubmitFlagsKHR = ffi.typeof([[$ ]], mod.VkSubmitFlags)
mod.VkMemoryBarrier2KHR = ffi.typeof([[$ ]], mod.VkMemoryBarrier2)
mod.VkBufferMemoryBarrier2KHR = ffi.typeof([[$ ]], mod.VkBufferMemoryBarrier2)
mod.VkImageMemoryBarrier2KHR = ffi.typeof([[$ ]], mod.VkImageMemoryBarrier2)
mod.VkDependencyInfoKHR = ffi.typeof([[$ ]], mod.VkDependencyInfo)
mod.VkSubmitInfo2KHR = ffi.typeof([[$ ]], mod.VkSubmitInfo2)
mod.VkSemaphoreSubmitInfoKHR = ffi.typeof([[$ ]], mod.VkSemaphoreSubmitInfo)
mod.VkCommandBufferSubmitInfoKHR = ffi.typeof([[$ ]], mod.VkCommandBufferSubmitInfo)
mod.VkPhysicalDeviceSynchronization2FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSynchronization2Features)
mod.PFN_vkCmdSetEvent2KHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkCommandBuffer, mod.VkEvent, mod.VkDependencyInfo)
mod.PFN_vkCmdResetEvent2KHR = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags2)
mod.PFN_vkCmdWaitEvents2KHR = ffi.typeof([[void (*)($ , uint32_t , const $*, const $*)]], mod.VkCommandBuffer, mod.VkEvent, mod.VkDependencyInfo)
mod.PFN_vkCmdPipelineBarrier2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDependencyInfo)
mod.PFN_vkCmdWriteTimestamp2KHR = ffi.typeof([[void (*)($ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkPipelineStageFlags2, mod.VkQueryPool)
mod.PFN_vkQueueSubmit2KHR = ffi.typeof([[$ (*)($ , uint32_t , const $*, $ )]], mod.VkResult, mod.VkQueue, mod.VkSubmitInfo2, mod.VkFence)
ffi.cdef([[void  vkCmdSetEvent2KHR($ , $ , const $*);]], mod.VkCommandBuffer, mod.VkEvent, mod.VkDependencyInfo)
ffi.cdef([[void  vkCmdResetEvent2KHR($ , $ , $ );]], mod.VkCommandBuffer, mod.VkEvent, mod.VkPipelineStageFlags2)
ffi.cdef([[void  vkCmdWaitEvents2KHR($ , uint32_t , const $*, const $*);]], mod.VkCommandBuffer, mod.VkEvent, mod.VkDependencyInfo)
ffi.cdef([[void  vkCmdPipelineBarrier2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkDependencyInfo)
ffi.cdef([[void  vkCmdWriteTimestamp2KHR($ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkPipelineStageFlags2, mod.VkQueryPool)
ffi.cdef([[$  vkQueueSubmit2KHR($ , uint32_t , const $*, $ );]], mod.VkResult, mod.VkQueue, mod.VkSubmitInfo2, mod.VkFence)
mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ fragmentShaderBarycentric;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ triStripVertexOrderIndependentOfProvokingVertex;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderSubgroupUniformControlFlow;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)
mod.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ workgroupMemoryExplicitLayout;
	$ workgroupMemoryExplicitLayoutScalarBlockLayout;
	$ workgroupMemoryExplicitLayout8BitAccess;
	$ workgroupMemoryExplicitLayout16BitAccess;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkCopyBufferInfo2KHR = ffi.typeof([[$ ]], mod.VkCopyBufferInfo2)
mod.VkCopyImageInfo2KHR = ffi.typeof([[$ ]], mod.VkCopyImageInfo2)
mod.VkCopyBufferToImageInfo2KHR = ffi.typeof([[$ ]], mod.VkCopyBufferToImageInfo2)
mod.VkCopyImageToBufferInfo2KHR = ffi.typeof([[$ ]], mod.VkCopyImageToBufferInfo2)
mod.VkBlitImageInfo2KHR = ffi.typeof([[$ ]], mod.VkBlitImageInfo2)
mod.VkResolveImageInfo2KHR = ffi.typeof([[$ ]], mod.VkResolveImageInfo2)
mod.VkBufferCopy2KHR = ffi.typeof([[$ ]], mod.VkBufferCopy2)
mod.VkImageCopy2KHR = ffi.typeof([[$ ]], mod.VkImageCopy2)
mod.VkImageBlit2KHR = ffi.typeof([[$ ]], mod.VkImageBlit2)
mod.VkBufferImageCopy2KHR = ffi.typeof([[$ ]], mod.VkBufferImageCopy2)
mod.VkImageResolve2KHR = ffi.typeof([[$ ]], mod.VkImageResolve2)
mod.PFN_vkCmdCopyBuffer2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyBufferInfo2)
mod.PFN_vkCmdCopyImage2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyImageInfo2)
mod.PFN_vkCmdCopyBufferToImage2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyBufferToImageInfo2)
mod.PFN_vkCmdCopyImageToBuffer2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyImageToBufferInfo2)
mod.PFN_vkCmdBlitImage2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBlitImageInfo2)
mod.PFN_vkCmdResolveImage2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkResolveImageInfo2)
ffi.cdef([[void  vkCmdCopyBuffer2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyBufferInfo2)
ffi.cdef([[void  vkCmdCopyImage2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyImageInfo2)
ffi.cdef([[void  vkCmdCopyBufferToImage2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyBufferToImageInfo2)
ffi.cdef([[void  vkCmdCopyImageToBuffer2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyImageToBufferInfo2)
ffi.cdef([[void  vkCmdBlitImage2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkBlitImageInfo2)
ffi.cdef([[void  vkCmdResolveImage2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkResolveImageInfo2)
mod.VkFormatFeatureFlags2KHR = ffi.typeof([[$ ]], mod.VkFormatFeatureFlags2)
mod.VkFormatFeatureFlagBits2KHR = ffi.typeof([[$ ]], mod.VkFormatFeatureFlagBits2)
mod.VkFormatProperties3KHR = ffi.typeof([[$ ]], mod.VkFormatProperties3)
mod.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rayTracingMaintenance1;
	$ rayTracingPipelineTraceRaysIndirect2;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkTraceRaysIndirectCommand2KHR = ffi.typeof([[struct {
	$ raygenShaderRecordAddress;
	$ raygenShaderRecordSize;
	$ missShaderBindingTableAddress;
	$ missShaderBindingTableSize;
	$ missShaderBindingTableStride;
	$ hitShaderBindingTableAddress;
	$ hitShaderBindingTableSize;
	$ hitShaderBindingTableStride;
	$ callableShaderBindingTableAddress;
	$ callableShaderBindingTableSize;
	$ callableShaderBindingTableStride;
	uint32_t width;
	uint32_t height;
	uint32_t depth;
}]], mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceSize)
mod.PFN_vkCmdTraceRaysIndirect2KHR = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkDeviceAddress)
ffi.cdef([[void  vkCmdTraceRaysIndirect2KHR($ , $ );]], mod.VkCommandBuffer, mod.VkDeviceAddress)
mod.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderUntypedPointers;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMaintenance4FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance4Features)
mod.VkPhysicalDeviceMaintenance4PropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance4Properties)
mod.VkDeviceBufferMemoryRequirementsKHR = ffi.typeof([[$ ]], mod.VkDeviceBufferMemoryRequirements)
mod.VkDeviceImageMemoryRequirementsKHR = ffi.typeof([[$ ]], mod.VkDeviceImageMemoryRequirements)
mod.PFN_vkGetDeviceBufferMemoryRequirementsKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceBufferMemoryRequirements, mod.VkMemoryRequirements2)
mod.PFN_vkGetDeviceImageMemoryRequirementsKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceImageMemoryRequirements, mod.VkMemoryRequirements2)
mod.PFN_vkGetDeviceImageSparseMemoryRequirementsKHR = ffi.typeof([[void (*)($ , const $*, uint32_t*, $*)]], mod.VkDevice, mod.VkDeviceImageMemoryRequirements, mod.VkSparseImageMemoryRequirements2)
ffi.cdef([[void  vkGetDeviceBufferMemoryRequirementsKHR($ , const $*, $*);]], mod.VkDevice, mod.VkDeviceBufferMemoryRequirements, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkGetDeviceImageMemoryRequirementsKHR($ , const $*, $*);]], mod.VkDevice, mod.VkDeviceImageMemoryRequirements, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkGetDeviceImageSparseMemoryRequirementsKHR($ , const $*, uint32_t*, $*);]], mod.VkDevice, mod.VkDeviceImageMemoryRequirements, mod.VkSparseImageMemoryRequirements2)
mod.VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderSubgroupRotateFeatures)
mod.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderMaximalReconvergence;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineCreateFlags2KHR = ffi.typeof([[$ ]], mod.VkPipelineCreateFlags2)
mod.VkPipelineCreateFlagBits2KHR = ffi.typeof([[$ ]], mod.VkPipelineCreateFlagBits2)
mod.VkBufferUsageFlags2KHR = ffi.typeof([[$ ]], mod.VkBufferUsageFlags2)
mod.VkBufferUsageFlagBits2KHR = ffi.typeof([[$ ]], mod.VkBufferUsageFlagBits2)
mod.VkPhysicalDeviceMaintenance5FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance5Features)
mod.VkPhysicalDeviceMaintenance5PropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance5Properties)
mod.VkRenderingAreaInfoKHR = ffi.typeof([[$ ]], mod.VkRenderingAreaInfo)
mod.VkDeviceImageSubresourceInfoKHR = ffi.typeof([[$ ]], mod.VkDeviceImageSubresourceInfo)
mod.VkImageSubresource2KHR = ffi.typeof([[$ ]], mod.VkImageSubresource2)
mod.VkSubresourceLayout2KHR = ffi.typeof([[$ ]], mod.VkSubresourceLayout2)
mod.VkPipelineCreateFlags2CreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineCreateFlags2CreateInfo)
mod.VkBufferUsageFlags2CreateInfoKHR = ffi.typeof([[$ ]], mod.VkBufferUsageFlags2CreateInfo)
mod.PFN_vkCmdBindIndexBuffer2KHR = ffi.typeof([[void (*)($ , $ , $ , $ , $ )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkIndexType)
mod.PFN_vkGetRenderingAreaGranularityKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkRenderingAreaInfo, mod.VkExtent2D)
mod.PFN_vkGetDeviceImageSubresourceLayoutKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceImageSubresourceInfo, mod.VkSubresourceLayout2)
mod.PFN_vkGetImageSubresourceLayout2KHR = ffi.typeof([[void (*)($ , $ , const $*, $*)]], mod.VkDevice, mod.VkImage, mod.VkImageSubresource2, mod.VkSubresourceLayout2)
ffi.cdef([[void  vkCmdBindIndexBuffer2KHR($ , $ , $ , $ , $ );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkIndexType)
ffi.cdef([[void  vkGetRenderingAreaGranularityKHR($ , const $*, $*);]], mod.VkDevice, mod.VkRenderingAreaInfo, mod.VkExtent2D)
ffi.cdef([[void  vkGetDeviceImageSubresourceLayoutKHR($ , const $*, $*);]], mod.VkDevice, mod.VkDeviceImageSubresourceInfo, mod.VkSubresourceLayout2)
ffi.cdef([[void  vkGetImageSubresourceLayout2KHR($ , $ , const $*, $*);]], mod.VkDevice, mod.VkImage, mod.VkImageSubresource2, mod.VkSubresourceLayout2)
mod.VkSurfaceCapabilitiesPresentId2KHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentId2Supported;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPresentId2KHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const uint64_t* pPresentIds;
}]], mod.VkStructureType)
mod.VkPhysicalDevicePresentId2FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentId2;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSurfaceCapabilitiesPresentWait2KHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentWait2Supported;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePresentWait2FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentWait2;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPresentWait2InfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t presentId;
	uint64_t timeout;
}]], mod.VkStructureType)
mod.PFN_vkWaitForPresent2KHR = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkPresentWait2InfoKHR)
ffi.cdef([[$  vkWaitForPresent2KHR($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkPresentWait2InfoKHR)
mod.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rayTracingPositionFetch;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineBinaryKHR = ffi.typeof([[void*]])
mod.VkPhysicalDevicePipelineBinaryFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineBinaries;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePipelineBinaryPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineBinaryInternalCache;
	$ pipelineBinaryInternalCacheControl;
	$ pipelineBinaryPrefersInternalCache;
	$ pipelineBinaryPrecompiledInternalCache;
	$ pipelineBinaryCompressedData;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDevicePipelineBinaryInternalCacheControlKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ disableInternalCache;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineBinaryKeyKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t keySize;
	uint8_t key[32U];
}]], mod.VkStructureType)
mod.VkPipelineBinaryDataKHR = ffi.typeof([[struct {
	size_t dataSize;
	void* pData;
}]])
mod.VkPipelineBinaryKeysAndDataKHR = ffi.typeof([[struct {
	uint32_t binaryCount;
	const $* pPipelineBinaryKeys;
	const $* pPipelineBinaryData;
}]], mod.VkPipelineBinaryKeyKHR, mod.VkPipelineBinaryDataKHR)
mod.VkPipelineCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
}]], mod.VkStructureType)
mod.VkPipelineBinaryCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pKeysAndDataInfo;
	$ pipeline;
	const $* pPipelineCreateInfo;
}]], mod.VkStructureType, mod.VkPipelineBinaryKeysAndDataKHR, mod.VkPipeline, mod.VkPipelineCreateInfoKHR)
mod.VkPipelineBinaryInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t binaryCount;
	const $* pPipelineBinaries;
}]], mod.VkStructureType, mod.VkPipelineBinaryKHR)
mod.VkReleaseCapturedPipelineDataInfoKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipeline;
}]], mod.VkStructureType, mod.VkPipeline)
mod.VkPipelineBinaryDataInfoKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineBinary;
}]], mod.VkStructureType, mod.VkPipelineBinaryKHR)
mod.VkPipelineBinaryHandlesInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t pipelineBinaryCount;
	$* pPipelineBinaries;
}]], mod.VkStructureType, mod.VkPipelineBinaryKHR)
mod.PFN_vkCreatePipelineBinariesKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineBinaryCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkPipelineBinaryHandlesInfoKHR)
mod.PFN_vkDestroyPipelineBinaryKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkPipelineBinaryKHR, mod.VkAllocationCallbacks)
mod.PFN_vkGetPipelineKeyKHR = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineCreateInfoKHR, mod.VkPipelineBinaryKeyKHR)
mod.PFN_vkGetPipelineBinaryDataKHR = ffi.typeof([[$ (*)($ , const $*, $*, size_t*, void*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineBinaryDataInfoKHR, mod.VkPipelineBinaryKeyKHR)
mod.PFN_vkReleaseCapturedPipelineDataKHR = ffi.typeof([[$ (*)($ , const $*, const $*)]], mod.VkResult, mod.VkDevice, mod.VkReleaseCapturedPipelineDataInfoKHR, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreatePipelineBinariesKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineBinaryCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkPipelineBinaryHandlesInfoKHR)
ffi.cdef([[void  vkDestroyPipelineBinaryKHR($ , $ , const $*);]], mod.VkDevice, mod.VkPipelineBinaryKHR, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkGetPipelineKeyKHR($ , const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineCreateInfoKHR, mod.VkPipelineBinaryKeyKHR)
ffi.cdef([[$  vkGetPipelineBinaryDataKHR($ , const $*, $*, size_t*, void*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineBinaryDataInfoKHR, mod.VkPipelineBinaryKeyKHR)
ffi.cdef([[$  vkReleaseCapturedPipelineDataKHR($ , const $*, const $*);]], mod.VkResult, mod.VkDevice, mod.VkReleaseCapturedPipelineDataInfoKHR, mod.VkAllocationCallbacks)
mod.VkPresentScalingFlagBitsKHR = ffi.typeof([[enum {
	VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR = 0x00000001,
	VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR = 0x00000002,
	VK_PRESENT_SCALING_STRETCH_BIT_KHR = 0x00000004,
	VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT = VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR,
	VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT = VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR,
	VK_PRESENT_SCALING_STRETCH_BIT_EXT = VK_PRESENT_SCALING_STRETCH_BIT_KHR,
	VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPresentScalingFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPresentGravityFlagBitsKHR = ffi.typeof([[enum {
	VK_PRESENT_GRAVITY_MIN_BIT_KHR = 0x00000001,
	VK_PRESENT_GRAVITY_MAX_BIT_KHR = 0x00000002,
	VK_PRESENT_GRAVITY_CENTERED_BIT_KHR = 0x00000004,
	VK_PRESENT_GRAVITY_MIN_BIT_EXT = VK_PRESENT_GRAVITY_MIN_BIT_KHR,
	VK_PRESENT_GRAVITY_MAX_BIT_EXT = VK_PRESENT_GRAVITY_MAX_BIT_KHR,
	VK_PRESENT_GRAVITY_CENTERED_BIT_EXT = VK_PRESENT_GRAVITY_CENTERED_BIT_KHR,
	VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPresentGravityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSurfacePresentModeKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentMode;
}]], mod.VkStructureType, mod.VkPresentModeKHR)
mod.VkSurfacePresentScalingCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ supportedPresentScaling;
	$ supportedPresentGravityX;
	$ supportedPresentGravityY;
	$ minScaledImageExtent;
	$ maxScaledImageExtent;
}]], mod.VkStructureType, mod.VkPresentScalingFlagsKHR, mod.VkPresentGravityFlagsKHR, mod.VkPresentGravityFlagsKHR, mod.VkExtent2D, mod.VkExtent2D)
mod.VkSurfacePresentModeCompatibilityKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t presentModeCount;
	$* pPresentModes;
}]], mod.VkStructureType, mod.VkPresentModeKHR)
mod.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ swapchainMaintenance1;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSwapchainPresentFenceInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const $* pFences;
}]], mod.VkStructureType, mod.VkFence)
mod.VkSwapchainPresentModesCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t presentModeCount;
	const $* pPresentModes;
}]], mod.VkStructureType, mod.VkPresentModeKHR)
mod.VkSwapchainPresentModeInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const $* pPresentModes;
}]], mod.VkStructureType, mod.VkPresentModeKHR)
mod.VkSwapchainPresentScalingCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ scalingBehavior;
	$ presentGravityX;
	$ presentGravityY;
}]], mod.VkStructureType, mod.VkPresentScalingFlagsKHR, mod.VkPresentGravityFlagsKHR, mod.VkPresentGravityFlagsKHR)
mod.VkReleaseSwapchainImagesInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ swapchain;
	uint32_t imageIndexCount;
	const uint32_t* pImageIndices;
}]], mod.VkStructureType, mod.VkSwapchainKHR)
mod.PFN_vkReleaseSwapchainImagesKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkReleaseSwapchainImagesInfoKHR)
ffi.cdef([[$  vkReleaseSwapchainImagesKHR($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkReleaseSwapchainImagesInfoKHR)
mod.VkComponentTypeKHR = ffi.typeof([[enum {
	VK_COMPONENT_TYPE_FLOAT16_KHR = 0,
	VK_COMPONENT_TYPE_FLOAT32_KHR = 1,
	VK_COMPONENT_TYPE_FLOAT64_KHR = 2,
	VK_COMPONENT_TYPE_SINT8_KHR = 3,
	VK_COMPONENT_TYPE_SINT16_KHR = 4,
	VK_COMPONENT_TYPE_SINT32_KHR = 5,
	VK_COMPONENT_TYPE_SINT64_KHR = 6,
	VK_COMPONENT_TYPE_UINT8_KHR = 7,
	VK_COMPONENT_TYPE_UINT16_KHR = 8,
	VK_COMPONENT_TYPE_UINT32_KHR = 9,
	VK_COMPONENT_TYPE_UINT64_KHR = 10,
	VK_COMPONENT_TYPE_BFLOAT16_KHR = 1000141000,
	VK_COMPONENT_TYPE_SINT8_PACKED_NV = 1000491000,
	VK_COMPONENT_TYPE_UINT8_PACKED_NV = 1000491001,
	VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT = 1000491002,
	VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT = 1000491003,
	VK_COMPONENT_TYPE_FLOAT16_NV = VK_COMPONENT_TYPE_FLOAT16_KHR,
	VK_COMPONENT_TYPE_FLOAT32_NV = VK_COMPONENT_TYPE_FLOAT32_KHR,
	VK_COMPONENT_TYPE_FLOAT64_NV = VK_COMPONENT_TYPE_FLOAT64_KHR,
	VK_COMPONENT_TYPE_SINT8_NV = VK_COMPONENT_TYPE_SINT8_KHR,
	VK_COMPONENT_TYPE_SINT16_NV = VK_COMPONENT_TYPE_SINT16_KHR,
	VK_COMPONENT_TYPE_SINT32_NV = VK_COMPONENT_TYPE_SINT32_KHR,
	VK_COMPONENT_TYPE_SINT64_NV = VK_COMPONENT_TYPE_SINT64_KHR,
	VK_COMPONENT_TYPE_UINT8_NV = VK_COMPONENT_TYPE_UINT8_KHR,
	VK_COMPONENT_TYPE_UINT16_NV = VK_COMPONENT_TYPE_UINT16_KHR,
	VK_COMPONENT_TYPE_UINT32_NV = VK_COMPONENT_TYPE_UINT32_KHR,
	VK_COMPONENT_TYPE_UINT64_NV = VK_COMPONENT_TYPE_UINT64_KHR,
	VK_COMPONENT_TYPE_FLOAT_E4M3_NV = VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT,
	VK_COMPONENT_TYPE_FLOAT_E5M2_NV = VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT,
	VK_COMPONENT_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkScopeKHR = ffi.typeof([[enum {
	VK_SCOPE_DEVICE_KHR = 1,
	VK_SCOPE_WORKGROUP_KHR = 2,
	VK_SCOPE_SUBGROUP_KHR = 3,
	VK_SCOPE_QUEUE_FAMILY_KHR = 5,
	VK_SCOPE_DEVICE_NV = VK_SCOPE_DEVICE_KHR,
	VK_SCOPE_WORKGROUP_NV = VK_SCOPE_WORKGROUP_KHR,
	VK_SCOPE_SUBGROUP_NV = VK_SCOPE_SUBGROUP_KHR,
	VK_SCOPE_QUEUE_FAMILY_NV = VK_SCOPE_QUEUE_FAMILY_KHR,
	VK_SCOPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCooperativeMatrixPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t MSize;
	uint32_t NSize;
	uint32_t KSize;
	$ AType;
	$ BType;
	$ CType;
	$ ResultType;
	$ saturatingAccumulation;
	$ scope;
}]], mod.VkStructureType, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkBool32, mod.VkScopeKHR)
mod.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrix;
	$ cooperativeMatrixRobustBufferAccess;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceCooperativeMatrixPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrixSupportedStages;
}]], mod.VkStructureType, mod.VkShaderStageFlags)
mod.PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkCooperativeMatrixPropertiesKHR)
ffi.cdef([[$  vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkCooperativeMatrixPropertiesKHR)
mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ computeDerivativeGroupQuads;
	$ computeDerivativeGroupLinear;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ meshAndTaskShaderDerivatives;
}]], mod.VkStructureType, mod.VkBool32)
mod.StdVideoAV1Profile = ffi.typeof([[enum {
	STD_VIDEO_AV1_PROFILE_MAIN = 0,
	STD_VIDEO_AV1_PROFILE_HIGH = 1,
	STD_VIDEO_AV1_PROFILE_PROFESSIONAL = 2,
	STD_VIDEO_AV1_PROFILE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_PROFILE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1Level = ffi.typeof([[enum {
	STD_VIDEO_AV1_LEVEL_2_0 = 0,
	STD_VIDEO_AV1_LEVEL_2_1 = 1,
	STD_VIDEO_AV1_LEVEL_2_2 = 2,
	STD_VIDEO_AV1_LEVEL_2_3 = 3,
	STD_VIDEO_AV1_LEVEL_3_0 = 4,
	STD_VIDEO_AV1_LEVEL_3_1 = 5,
	STD_VIDEO_AV1_LEVEL_3_2 = 6,
	STD_VIDEO_AV1_LEVEL_3_3 = 7,
	STD_VIDEO_AV1_LEVEL_4_0 = 8,
	STD_VIDEO_AV1_LEVEL_4_1 = 9,
	STD_VIDEO_AV1_LEVEL_4_2 = 10,
	STD_VIDEO_AV1_LEVEL_4_3 = 11,
	STD_VIDEO_AV1_LEVEL_5_0 = 12,
	STD_VIDEO_AV1_LEVEL_5_1 = 13,
	STD_VIDEO_AV1_LEVEL_5_2 = 14,
	STD_VIDEO_AV1_LEVEL_5_3 = 15,
	STD_VIDEO_AV1_LEVEL_6_0 = 16,
	STD_VIDEO_AV1_LEVEL_6_1 = 17,
	STD_VIDEO_AV1_LEVEL_6_2 = 18,
	STD_VIDEO_AV1_LEVEL_6_3 = 19,
	STD_VIDEO_AV1_LEVEL_7_0 = 20,
	STD_VIDEO_AV1_LEVEL_7_1 = 21,
	STD_VIDEO_AV1_LEVEL_7_2 = 22,
	STD_VIDEO_AV1_LEVEL_7_3 = 23,
	STD_VIDEO_AV1_LEVEL_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_LEVEL_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1FrameType = ffi.typeof([[enum {
	STD_VIDEO_AV1_FRAME_TYPE_KEY = 0,
	STD_VIDEO_AV1_FRAME_TYPE_INTER = 1,
	STD_VIDEO_AV1_FRAME_TYPE_INTRA_ONLY = 2,
	STD_VIDEO_AV1_FRAME_TYPE_SWITCH = 3,
	STD_VIDEO_AV1_FRAME_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_FRAME_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1ReferenceName = ffi.typeof([[enum {
	STD_VIDEO_AV1_REFERENCE_NAME_INTRA_FRAME = 0,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME = 1,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST2_FRAME = 2,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST3_FRAME = 3,
	STD_VIDEO_AV1_REFERENCE_NAME_GOLDEN_FRAME = 4,
	STD_VIDEO_AV1_REFERENCE_NAME_BWDREF_FRAME = 5,
	STD_VIDEO_AV1_REFERENCE_NAME_ALTREF2_FRAME = 6,
	STD_VIDEO_AV1_REFERENCE_NAME_ALTREF_FRAME = 7,
	STD_VIDEO_AV1_REFERENCE_NAME_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_REFERENCE_NAME_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1InterpolationFilter = ffi.typeof([[enum {
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP = 0,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_BILINEAR = 3,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_SWITCHABLE = 4,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1TxMode = ffi.typeof([[enum {
	STD_VIDEO_AV1_TX_MODE_ONLY_4X4 = 0,
	STD_VIDEO_AV1_TX_MODE_LARGEST = 1,
	STD_VIDEO_AV1_TX_MODE_SELECT = 2,
	STD_VIDEO_AV1_TX_MODE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_TX_MODE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1FrameRestorationType = ffi.typeof([[enum {
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_NONE = 0,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_WIENER = 1,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SGRPROJ = 2,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SWITCHABLE = 3,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1ColorPrimaries = ffi.typeof([[enum {
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_709 = 1,
	STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED = 2,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_M = 4,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_B_G = 5,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_601 = 6,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_240 = 7,
	STD_VIDEO_AV1_COLOR_PRIMARIES_GENERIC_FILM = 8,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_2020 = 9,
	STD_VIDEO_AV1_COLOR_PRIMARIES_XYZ = 10,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_431 = 11,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_432 = 12,
	STD_VIDEO_AV1_COLOR_PRIMARIES_EBU_3213 = 22,
	STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED = STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED,
	STD_VIDEO_AV1_COLOR_PRIMARIES_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1TransferCharacteristics = ffi.typeof([[enum {
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_0 = 0,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_709 = 1,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_3 = 3,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_M = 4,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_B_G = 5,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_601 = 6,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_240 = 7,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LINEAR = 8,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100 = 9,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100_SQRT10 = 10,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_IEC_61966 = 11,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_1361 = 12,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SRGB = 13,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_10_BIT = 14,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_12_BIT = 15,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_2084 = 16,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_428 = 17,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_HLG = 18,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1MatrixCoefficients = ffi.typeof([[enum {
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_IDENTITY = 0,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_709 = 1,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_UNSPECIFIED = 2,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_RESERVED_3 = 3,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_FCC = 4,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_470_B_G = 5,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_601 = 6,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_240 = 7,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_YCGCO = 8,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_NCL = 9,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_CL = 10,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_2085 = 11,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_NCL = 12,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_CL = 13,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_ICTCP = 14,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1ChromaSamplePosition = ffi.typeof([[enum {
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_UNKNOWN = 0,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_VERTICAL = 1,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_COLOCATED = 2,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_RESERVED = 3,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_INVALID = 0x7FFFFFFF,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoAV1ColorConfigFlags = ffi.typeof([[struct {
	uint32_t mono_chrome;
	uint32_t color_range;
	uint32_t separate_uv_delta_q;
	uint32_t color_description_present_flag;
	uint32_t reserved;
}]])
mod.StdVideoAV1ColorConfig = ffi.typeof([[struct {
	$ flags;
	uint8_t BitDepth;
	uint8_t subsampling_x;
	uint8_t subsampling_y;
	uint8_t reserved1;
	$ color_primaries;
	$ transfer_characteristics;
	$ matrix_coefficients;
	$ chroma_sample_position;
}]], mod.StdVideoAV1ColorConfigFlags, mod.StdVideoAV1ColorPrimaries, mod.StdVideoAV1TransferCharacteristics, mod.StdVideoAV1MatrixCoefficients, mod.StdVideoAV1ChromaSamplePosition)
mod.StdVideoAV1TimingInfoFlags = ffi.typeof([[struct {
	uint32_t equal_picture_interval;
	uint32_t reserved;
}]])
mod.StdVideoAV1TimingInfo = ffi.typeof([[struct {
	$ flags;
	uint32_t num_units_in_display_tick;
	uint32_t time_scale;
	uint32_t num_ticks_per_picture_minus_1;
}]], mod.StdVideoAV1TimingInfoFlags)
mod.StdVideoAV1LoopFilterFlags = ffi.typeof([[struct {
	uint32_t loop_filter_delta_enabled;
	uint32_t loop_filter_delta_update;
	uint32_t reserved;
}]])
mod.StdVideoAV1LoopFilter = ffi.typeof([[struct {
	$ flags;
	uint8_t loop_filter_level[4U];
	uint8_t loop_filter_sharpness;
	uint8_t update_ref_delta;
	int8_t loop_filter_ref_deltas[8U];
	uint8_t update_mode_delta;
	int8_t loop_filter_mode_deltas[2U];
}]], mod.StdVideoAV1LoopFilterFlags)
mod.StdVideoAV1QuantizationFlags = ffi.typeof([[struct {
	uint32_t using_qmatrix;
	uint32_t diff_uv_delta;
	uint32_t reserved;
}]])
mod.StdVideoAV1Quantization = ffi.typeof([[struct {
	$ flags;
	uint8_t base_q_idx;
	int8_t DeltaQYDc;
	int8_t DeltaQUDc;
	int8_t DeltaQUAc;
	int8_t DeltaQVDc;
	int8_t DeltaQVAc;
	uint8_t qm_y;
	uint8_t qm_u;
	uint8_t qm_v;
}]], mod.StdVideoAV1QuantizationFlags)
mod.StdVideoAV1Segmentation = ffi.typeof([[struct {
	uint8_t FeatureEnabled[8U];
	int16_t FeatureData[8U][8U];
}]])
mod.StdVideoAV1TileInfoFlags = ffi.typeof([[struct {
	uint32_t uniform_tile_spacing_flag;
	uint32_t reserved;
}]])
mod.StdVideoAV1TileInfo = ffi.typeof([[struct {
	$ flags;
	uint8_t TileCols;
	uint8_t TileRows;
	uint16_t context_update_tile_id;
	uint8_t tile_size_bytes_minus_1;
	uint8_t reserved1[7];
	const uint16_t* pMiColStarts;
	const uint16_t* pMiRowStarts;
	const uint16_t* pWidthInSbsMinus1;
	const uint16_t* pHeightInSbsMinus1;
}]], mod.StdVideoAV1TileInfoFlags)
mod.StdVideoAV1CDEF = ffi.typeof([[struct {
	uint8_t cdef_damping_minus_3;
	uint8_t cdef_bits;
	uint8_t cdef_y_pri_strength[8U];
	uint8_t cdef_y_sec_strength[8U];
	uint8_t cdef_uv_pri_strength[8U];
	uint8_t cdef_uv_sec_strength[8U];
}]])
mod.StdVideoAV1LoopRestoration = ffi.typeof([[struct {
	$ FrameRestorationType[3U];
	uint16_t LoopRestorationSize[3U];
}]], mod.StdVideoAV1FrameRestorationType)
mod.StdVideoAV1GlobalMotion = ffi.typeof([[struct {
	uint8_t GmType[8U];
	int32_t gm_params[6U][8U];
}]])
mod.StdVideoAV1FilmGrainFlags = ffi.typeof([[struct {
	uint32_t chroma_scaling_from_luma;
	uint32_t overlap_flag;
	uint32_t clip_to_restricted_range;
	uint32_t update_grain;
	uint32_t reserved;
}]])
mod.StdVideoAV1FilmGrain = ffi.typeof([[struct {
	$ flags;
	uint8_t grain_scaling_minus_8;
	uint8_t ar_coeff_lag;
	uint8_t ar_coeff_shift_minus_6;
	uint8_t grain_scale_shift;
	uint16_t grain_seed;
	uint8_t film_grain_params_ref_idx;
	uint8_t num_y_points;
	uint8_t point_y_value[14U];
	uint8_t point_y_scaling[14U];
	uint8_t num_cb_points;
	uint8_t point_cb_value[10U];
	uint8_t point_cb_scaling[10U];
	uint8_t num_cr_points;
	uint8_t point_cr_value[10U];
	uint8_t point_cr_scaling[10U];
	int8_t ar_coeffs_y_plus_128[24U];
	int8_t ar_coeffs_cb_plus_128[25U];
	int8_t ar_coeffs_cr_plus_128[25U];
	uint8_t cb_mult;
	uint8_t cb_luma_mult;
	uint16_t cb_offset;
	uint8_t cr_mult;
	uint8_t cr_luma_mult;
	uint16_t cr_offset;
}]], mod.StdVideoAV1FilmGrainFlags)
mod.StdVideoAV1SequenceHeaderFlags = ffi.typeof([[struct {
	uint32_t still_picture;
	uint32_t reduced_still_picture_header;
	uint32_t use_128x128_superblock;
	uint32_t enable_filter_intra;
	uint32_t enable_intra_edge_filter;
	uint32_t enable_interintra_compound;
	uint32_t enable_masked_compound;
	uint32_t enable_warped_motion;
	uint32_t enable_dual_filter;
	uint32_t enable_order_hint;
	uint32_t enable_jnt_comp;
	uint32_t enable_ref_frame_mvs;
	uint32_t frame_id_numbers_present_flag;
	uint32_t enable_superres;
	uint32_t enable_cdef;
	uint32_t enable_restoration;
	uint32_t film_grain_params_present;
	uint32_t timing_info_present_flag;
	uint32_t initial_display_delay_present_flag;
	uint32_t reserved;
}]])
mod.StdVideoAV1SequenceHeader = ffi.typeof([[struct {
	$ flags;
	$ seq_profile;
	uint8_t frame_width_bits_minus_1;
	uint8_t frame_height_bits_minus_1;
	uint16_t max_frame_width_minus_1;
	uint16_t max_frame_height_minus_1;
	uint8_t delta_frame_id_length_minus_2;
	uint8_t additional_frame_id_length_minus_1;
	uint8_t order_hint_bits_minus_1;
	uint8_t seq_force_integer_mv;
	uint8_t seq_force_screen_content_tools;
	uint8_t reserved1[5];
	const $* pColorConfig;
	const $* pTimingInfo;
}]], mod.StdVideoAV1SequenceHeaderFlags, mod.StdVideoAV1Profile, mod.StdVideoAV1ColorConfig, mod.StdVideoAV1TimingInfo)
mod.StdVideoDecodeAV1PictureInfoFlags = ffi.typeof([[struct {
	uint32_t error_resilient_mode;
	uint32_t disable_cdf_update;
	uint32_t use_superres;
	uint32_t render_and_frame_size_different;
	uint32_t allow_screen_content_tools;
	uint32_t is_filter_switchable;
	uint32_t force_integer_mv;
	uint32_t frame_size_override_flag;
	uint32_t buffer_removal_time_present_flag;
	uint32_t allow_intrabc;
	uint32_t frame_refs_short_signaling;
	uint32_t allow_high_precision_mv;
	uint32_t is_motion_mode_switchable;
	uint32_t use_ref_frame_mvs;
	uint32_t disable_frame_end_update_cdf;
	uint32_t allow_warped_motion;
	uint32_t reduced_tx_set;
	uint32_t reference_select;
	uint32_t skip_mode_present;
	uint32_t delta_q_present;
	uint32_t delta_lf_present;
	uint32_t delta_lf_multi;
	uint32_t segmentation_enabled;
	uint32_t segmentation_update_map;
	uint32_t segmentation_temporal_update;
	uint32_t segmentation_update_data;
	uint32_t UsesLr;
	uint32_t usesChromaLr;
	uint32_t apply_grain;
	uint32_t reserved;
}]])
mod.StdVideoDecodeAV1PictureInfo = ffi.typeof([[struct {
	$ flags;
	$ frame_type;
	uint32_t current_frame_id;
	uint8_t OrderHint;
	uint8_t primary_ref_frame;
	uint8_t refresh_frame_flags;
	uint8_t reserved1;
	$ interpolation_filter;
	$ TxMode;
	uint8_t delta_q_res;
	uint8_t delta_lf_res;
	uint8_t SkipModeFrame[2U];
	uint8_t coded_denom;
	uint8_t reserved2[3];
	uint8_t OrderHints[8U];
	uint32_t expectedFrameId[8U];
	const $* pTileInfo;
	const $* pQuantization;
	const $* pSegmentation;
	const $* pLoopFilter;
	const $* pCDEF;
	const $* pLoopRestoration;
	const $* pGlobalMotion;
	const $* pFilmGrain;
}]], mod.StdVideoDecodeAV1PictureInfoFlags, mod.StdVideoAV1FrameType, mod.StdVideoAV1InterpolationFilter, mod.StdVideoAV1TxMode, mod.StdVideoAV1TileInfo, mod.StdVideoAV1Quantization, mod.StdVideoAV1Segmentation, mod.StdVideoAV1LoopFilter, mod.StdVideoAV1CDEF, mod.StdVideoAV1LoopRestoration, mod.StdVideoAV1GlobalMotion, mod.StdVideoAV1FilmGrain)
mod.StdVideoDecodeAV1ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t disable_frame_end_update_cdf;
	uint32_t segmentation_enabled;
	uint32_t reserved;
}]])
mod.StdVideoDecodeAV1ReferenceInfo = ffi.typeof([[struct {
	$ flags;
	uint8_t frame_type;
	uint8_t RefFrameSignBias;
	uint8_t OrderHint;
	uint8_t SavedOrderHints[8U];
}]], mod.StdVideoDecodeAV1ReferenceInfoFlags)
mod.VkVideoDecodeAV1ProfileInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stdProfile;
	$ filmGrainSupport;
}]], mod.VkStructureType, mod.StdVideoAV1Profile, mod.VkBool32)
mod.VkVideoDecodeAV1CapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxLevel;
}]], mod.VkStructureType, mod.StdVideoAV1Level)
mod.VkVideoDecodeAV1SessionParametersCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdSequenceHeader;
}]], mod.VkStructureType, mod.StdVideoAV1SequenceHeader)
mod.VkVideoDecodeAV1PictureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdPictureInfo;
	int32_t referenceNameSlotIndices[7U];
	uint32_t frameHeaderOffset;
	uint32_t tileCount;
	const uint32_t* pTileOffsets;
	const uint32_t* pTileSizes;
}]], mod.VkStructureType, mod.StdVideoDecodeAV1PictureInfo)
mod.VkVideoDecodeAV1DpbSlotInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]], mod.VkStructureType, mod.StdVideoDecodeAV1ReferenceInfo)
mod.StdVideoEncodeAV1DecoderModelInfo = ffi.typeof([[struct {
	uint8_t buffer_delay_length_minus_1;
	uint8_t buffer_removal_time_length_minus_1;
	uint8_t frame_presentation_time_length_minus_1;
	uint8_t reserved1;
	uint32_t num_units_in_decoding_tick;
}]])
mod.StdVideoEncodeAV1ExtensionHeader = ffi.typeof([[struct {
	uint8_t temporal_id;
	uint8_t spatial_id;
}]])
mod.StdVideoEncodeAV1OperatingPointInfoFlags = ffi.typeof([[struct {
	uint32_t decoder_model_present_for_this_op;
	uint32_t low_delay_mode_flag;
	uint32_t initial_display_delay_present_for_this_op;
	uint32_t reserved;
}]])
mod.StdVideoEncodeAV1OperatingPointInfo = ffi.typeof([[struct {
	$ flags;
	uint16_t operating_point_idc;
	uint8_t seq_level_idx;
	uint8_t seq_tier;
	uint32_t decoder_buffer_delay;
	uint32_t encoder_buffer_delay;
	uint8_t initial_display_delay_minus_1;
}]], mod.StdVideoEncodeAV1OperatingPointInfoFlags)
mod.StdVideoEncodeAV1PictureInfoFlags = ffi.typeof([[struct {
	uint32_t error_resilient_mode;
	uint32_t disable_cdf_update;
	uint32_t use_superres;
	uint32_t render_and_frame_size_different;
	uint32_t allow_screen_content_tools;
	uint32_t is_filter_switchable;
	uint32_t force_integer_mv;
	uint32_t frame_size_override_flag;
	uint32_t buffer_removal_time_present_flag;
	uint32_t allow_intrabc;
	uint32_t frame_refs_short_signaling;
	uint32_t allow_high_precision_mv;
	uint32_t is_motion_mode_switchable;
	uint32_t use_ref_frame_mvs;
	uint32_t disable_frame_end_update_cdf;
	uint32_t allow_warped_motion;
	uint32_t reduced_tx_set;
	uint32_t skip_mode_present;
	uint32_t delta_q_present;
	uint32_t delta_lf_present;
	uint32_t delta_lf_multi;
	uint32_t segmentation_enabled;
	uint32_t segmentation_update_map;
	uint32_t segmentation_temporal_update;
	uint32_t segmentation_update_data;
	uint32_t UsesLr;
	uint32_t usesChromaLr;
	uint32_t show_frame;
	uint32_t showable_frame;
	uint32_t reserved;
}]])
mod.StdVideoEncodeAV1PictureInfo = ffi.typeof([[struct {
	$ flags;
	$ frame_type;
	uint32_t frame_presentation_time;
	uint32_t current_frame_id;
	uint8_t order_hint;
	uint8_t primary_ref_frame;
	uint8_t refresh_frame_flags;
	uint8_t coded_denom;
	uint16_t render_width_minus_1;
	uint16_t render_height_minus_1;
	$ interpolation_filter;
	$ TxMode;
	uint8_t delta_q_res;
	uint8_t delta_lf_res;
	uint8_t ref_order_hint[8U];
	int8_t ref_frame_idx[7U];
	uint8_t reserved1[3];
	uint32_t delta_frame_id_minus_1[7U];
	const $* pTileInfo;
	const $* pQuantization;
	const $* pSegmentation;
	const $* pLoopFilter;
	const $* pCDEF;
	const $* pLoopRestoration;
	const $* pGlobalMotion;
	const $* pExtensionHeader;
	const uint32_t* pBufferRemovalTimes;
}]], mod.StdVideoEncodeAV1PictureInfoFlags, mod.StdVideoAV1FrameType, mod.StdVideoAV1InterpolationFilter, mod.StdVideoAV1TxMode, mod.StdVideoAV1TileInfo, mod.StdVideoAV1Quantization, mod.StdVideoAV1Segmentation, mod.StdVideoAV1LoopFilter, mod.StdVideoAV1CDEF, mod.StdVideoAV1LoopRestoration, mod.StdVideoAV1GlobalMotion, mod.StdVideoEncodeAV1ExtensionHeader)
mod.StdVideoEncodeAV1ReferenceInfoFlags = ffi.typeof([[struct {
	uint32_t disable_frame_end_update_cdf;
	uint32_t segmentation_enabled;
	uint32_t reserved;
}]])
mod.StdVideoEncodeAV1ReferenceInfo = ffi.typeof([[struct {
	$ flags;
	uint32_t RefFrameId;
	$ frame_type;
	uint8_t OrderHint;
	uint8_t reserved1[3];
	const $* pExtensionHeader;
}]], mod.StdVideoEncodeAV1ReferenceInfoFlags, mod.StdVideoAV1FrameType, mod.StdVideoEncodeAV1ExtensionHeader)
mod.VkVideoEncodeAV1PredictionModeKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR = 0,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR = 1,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR = 2,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR = 3,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1RateControlGroupKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR = 0,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR = 1,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR = 2,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1CapabilityFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1CapabilityFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeAV1StdFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1StdFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeAV1SuperblockSizeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1SuperblockSizeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeAV1RateControlFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeAV1RateControlFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ videoEncodeAV1;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoEncodeAV1CapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ maxLevel;
	$ codedPictureAlignment;
	$ maxTiles;
	$ minTileSize;
	$ maxTileSize;
	$ superblockSizes;
	uint32_t maxSingleReferenceCount;
	uint32_t singleReferenceNameMask;
	uint32_t maxUnidirectionalCompoundReferenceCount;
	uint32_t maxUnidirectionalCompoundGroup1ReferenceCount;
	uint32_t unidirectionalCompoundReferenceNameMask;
	uint32_t maxBidirectionalCompoundReferenceCount;
	uint32_t maxBidirectionalCompoundGroup1ReferenceCount;
	uint32_t maxBidirectionalCompoundGroup2ReferenceCount;
	uint32_t bidirectionalCompoundReferenceNameMask;
	uint32_t maxTemporalLayerCount;
	uint32_t maxSpatialLayerCount;
	uint32_t maxOperatingPoints;
	uint32_t minQIndex;
	uint32_t maxQIndex;
	$ prefersGopRemainingFrames;
	$ requiresGopRemainingFrames;
	$ stdSyntaxFlags;
}]], mod.VkStructureType, mod.VkVideoEncodeAV1CapabilityFlagsKHR, mod.StdVideoAV1Level, mod.VkExtent2D, mod.VkExtent2D, mod.VkExtent2D, mod.VkExtent2D, mod.VkVideoEncodeAV1SuperblockSizeFlagsKHR, mod.VkBool32, mod.VkBool32, mod.VkVideoEncodeAV1StdFlagsKHR)
mod.VkVideoEncodeAV1QIndexKHR = ffi.typeof([[struct {
	uint32_t intraQIndex;
	uint32_t predictiveQIndex;
	uint32_t bipredictiveQIndex;
}]])
mod.VkVideoEncodeAV1QualityLevelPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ preferredRateControlFlags;
	uint32_t preferredGopFrameCount;
	uint32_t preferredKeyFramePeriod;
	uint32_t preferredConsecutiveBipredictiveFrameCount;
	uint32_t preferredTemporalLayerCount;
	$ preferredConstantQIndex;
	uint32_t preferredMaxSingleReferenceCount;
	uint32_t preferredSingleReferenceNameMask;
	uint32_t preferredMaxUnidirectionalCompoundReferenceCount;
	uint32_t preferredMaxUnidirectionalCompoundGroup1ReferenceCount;
	uint32_t preferredUnidirectionalCompoundReferenceNameMask;
	uint32_t preferredMaxBidirectionalCompoundReferenceCount;
	uint32_t preferredMaxBidirectionalCompoundGroup1ReferenceCount;
	uint32_t preferredMaxBidirectionalCompoundGroup2ReferenceCount;
	uint32_t preferredBidirectionalCompoundReferenceNameMask;
}]], mod.VkStructureType, mod.VkVideoEncodeAV1RateControlFlagsKHR, mod.VkVideoEncodeAV1QIndexKHR)
mod.VkVideoEncodeAV1SessionCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useMaxLevel;
	$ maxLevel;
}]], mod.VkStructureType, mod.VkBool32, mod.StdVideoAV1Level)
mod.VkVideoEncodeAV1SessionParametersCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdSequenceHeader;
	const $* pStdDecoderModelInfo;
	uint32_t stdOperatingPointCount;
	const $* pStdOperatingPoints;
}]], mod.VkStructureType, mod.StdVideoAV1SequenceHeader, mod.StdVideoEncodeAV1DecoderModelInfo, mod.StdVideoEncodeAV1OperatingPointInfo)
mod.VkVideoEncodeAV1PictureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ predictionMode;
	$ rateControlGroup;
	uint32_t constantQIndex;
	const $* pStdPictureInfo;
	int32_t referenceNameSlotIndices[7U];
	$ primaryReferenceCdfOnly;
	$ generateObuExtensionHeader;
}]], mod.VkStructureType, mod.VkVideoEncodeAV1PredictionModeKHR, mod.VkVideoEncodeAV1RateControlGroupKHR, mod.StdVideoEncodeAV1PictureInfo, mod.VkBool32, mod.VkBool32)
mod.VkVideoEncodeAV1DpbSlotInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdReferenceInfo;
}]], mod.VkStructureType, mod.StdVideoEncodeAV1ReferenceInfo)
mod.VkVideoEncodeAV1ProfileInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stdProfile;
}]], mod.VkStructureType, mod.StdVideoAV1Profile)
mod.VkVideoEncodeAV1FrameSizeKHR = ffi.typeof([[struct {
	uint32_t intraFrameSize;
	uint32_t predictiveFrameSize;
	uint32_t bipredictiveFrameSize;
}]])
mod.VkVideoEncodeAV1GopRemainingFrameInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useGopRemainingFrames;
	uint32_t gopRemainingIntra;
	uint32_t gopRemainingPredictive;
	uint32_t gopRemainingBipredictive;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoEncodeAV1RateControlInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t gopFrameCount;
	uint32_t keyFramePeriod;
	uint32_t consecutiveBipredictiveFrameCount;
	uint32_t temporalLayerCount;
}]], mod.VkStructureType, mod.VkVideoEncodeAV1RateControlFlagsKHR)
mod.VkVideoEncodeAV1RateControlLayerInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ useMinQIndex;
	$ minQIndex;
	$ useMaxQIndex;
	$ maxQIndex;
	$ useMaxFrameSize;
	$ maxFrameSize;
}]], mod.VkStructureType, mod.VkBool32, mod.VkVideoEncodeAV1QIndexKHR, mod.VkBool32, mod.VkVideoEncodeAV1QIndexKHR, mod.VkBool32, mod.VkVideoEncodeAV1FrameSizeKHR)
mod.StdVideoVP9Profile = ffi.typeof([[enum {
	STD_VIDEO_VP9_PROFILE_0 = 0,
	STD_VIDEO_VP9_PROFILE_1 = 1,
	STD_VIDEO_VP9_PROFILE_2 = 2,
	STD_VIDEO_VP9_PROFILE_3 = 3,
	STD_VIDEO_VP9_PROFILE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_PROFILE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9Level = ffi.typeof([[enum {
	STD_VIDEO_VP9_LEVEL_1_0 = 0,
	STD_VIDEO_VP9_LEVEL_1_1 = 1,
	STD_VIDEO_VP9_LEVEL_2_0 = 2,
	STD_VIDEO_VP9_LEVEL_2_1 = 3,
	STD_VIDEO_VP9_LEVEL_3_0 = 4,
	STD_VIDEO_VP9_LEVEL_3_1 = 5,
	STD_VIDEO_VP9_LEVEL_4_0 = 6,
	STD_VIDEO_VP9_LEVEL_4_1 = 7,
	STD_VIDEO_VP9_LEVEL_5_0 = 8,
	STD_VIDEO_VP9_LEVEL_5_1 = 9,
	STD_VIDEO_VP9_LEVEL_5_2 = 10,
	STD_VIDEO_VP9_LEVEL_6_0 = 11,
	STD_VIDEO_VP9_LEVEL_6_1 = 12,
	STD_VIDEO_VP9_LEVEL_6_2 = 13,
	STD_VIDEO_VP9_LEVEL_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_LEVEL_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9FrameType = ffi.typeof([[enum {
	STD_VIDEO_VP9_FRAME_TYPE_KEY = 0,
	STD_VIDEO_VP9_FRAME_TYPE_NON_KEY = 1,
	STD_VIDEO_VP9_FRAME_TYPE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_FRAME_TYPE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9ReferenceName = ffi.typeof([[enum {
	STD_VIDEO_VP9_REFERENCE_NAME_INTRA_FRAME = 0,
	STD_VIDEO_VP9_REFERENCE_NAME_LAST_FRAME = 1,
	STD_VIDEO_VP9_REFERENCE_NAME_GOLDEN_FRAME = 2,
	STD_VIDEO_VP9_REFERENCE_NAME_ALTREF_FRAME = 3,
	STD_VIDEO_VP9_REFERENCE_NAME_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_REFERENCE_NAME_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9InterpolationFilter = ffi.typeof([[enum {
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP = 0,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_BILINEAR = 3,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_SWITCHABLE = 4,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9ColorSpace = ffi.typeof([[enum {
	STD_VIDEO_VP9_COLOR_SPACE_UNKNOWN = 0,
	STD_VIDEO_VP9_COLOR_SPACE_BT_601 = 1,
	STD_VIDEO_VP9_COLOR_SPACE_BT_709 = 2,
	STD_VIDEO_VP9_COLOR_SPACE_SMPTE_170 = 3,
	STD_VIDEO_VP9_COLOR_SPACE_SMPTE_240 = 4,
	STD_VIDEO_VP9_COLOR_SPACE_BT_2020 = 5,
	STD_VIDEO_VP9_COLOR_SPACE_RESERVED = 6,
	STD_VIDEO_VP9_COLOR_SPACE_RGB = 7,
	STD_VIDEO_VP9_COLOR_SPACE_INVALID = 0x7FFFFFFF,
	STD_VIDEO_VP9_COLOR_SPACE_MAX_ENUM = 0x7FFFFFFF,
}]])
mod.StdVideoVP9ColorConfigFlags = ffi.typeof([[struct {
	uint32_t color_range;
	uint32_t reserved;
}]])
mod.StdVideoVP9ColorConfig = ffi.typeof([[struct {
	$ flags;
	uint8_t BitDepth;
	uint8_t subsampling_x;
	uint8_t subsampling_y;
	uint8_t reserved1;
	$ color_space;
}]], mod.StdVideoVP9ColorConfigFlags, mod.StdVideoVP9ColorSpace)
mod.StdVideoVP9LoopFilterFlags = ffi.typeof([[struct {
	uint32_t loop_filter_delta_enabled;
	uint32_t loop_filter_delta_update;
	uint32_t reserved;
}]])
mod.StdVideoVP9LoopFilter = ffi.typeof([[struct {
	$ flags;
	uint8_t loop_filter_level;
	uint8_t loop_filter_sharpness;
	uint8_t update_ref_delta;
	int8_t loop_filter_ref_deltas[4U];
	uint8_t update_mode_delta;
	int8_t loop_filter_mode_deltas[2U];
}]], mod.StdVideoVP9LoopFilterFlags)
mod.StdVideoVP9SegmentationFlags = ffi.typeof([[struct {
	uint32_t segmentation_update_map;
	uint32_t segmentation_temporal_update;
	uint32_t segmentation_update_data;
	uint32_t segmentation_abs_or_delta_update;
	uint32_t reserved;
}]])
mod.StdVideoVP9Segmentation = ffi.typeof([[struct {
	$ flags;
	uint8_t segmentation_tree_probs[7U];
	uint8_t segmentation_pred_prob[3U];
	uint8_t FeatureEnabled[8U];
	int16_t FeatureData[4U][8U];
}]], mod.StdVideoVP9SegmentationFlags)
mod.StdVideoDecodeVP9PictureInfoFlags = ffi.typeof([[struct {
	uint32_t error_resilient_mode;
	uint32_t intra_only;
	uint32_t allow_high_precision_mv;
	uint32_t refresh_frame_context;
	uint32_t frame_parallel_decoding_mode;
	uint32_t segmentation_enabled;
	uint32_t show_frame;
	uint32_t UsePrevFrameMvs;
	uint32_t reserved;
}]])
mod.StdVideoDecodeVP9PictureInfo = ffi.typeof([[struct {
	$ flags;
	$ profile;
	$ frame_type;
	uint8_t frame_context_idx;
	uint8_t reset_frame_context;
	uint8_t refresh_frame_flags;
	uint8_t ref_frame_sign_bias_mask;
	$ interpolation_filter;
	uint8_t base_q_idx;
	int8_t delta_q_y_dc;
	int8_t delta_q_uv_dc;
	int8_t delta_q_uv_ac;
	uint8_t tile_cols_log2;
	uint8_t tile_rows_log2;
	uint16_t reserved1[3];
	const $* pColorConfig;
	const $* pLoopFilter;
	const $* pSegmentation;
}]], mod.StdVideoDecodeVP9PictureInfoFlags, mod.StdVideoVP9Profile, mod.StdVideoVP9FrameType, mod.StdVideoVP9InterpolationFilter, mod.StdVideoVP9ColorConfig, mod.StdVideoVP9LoopFilter, mod.StdVideoVP9Segmentation)
mod.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ videoDecodeVP9;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoDecodeVP9ProfileInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stdProfile;
}]], mod.VkStructureType, mod.StdVideoVP9Profile)
mod.VkVideoDecodeVP9CapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxLevel;
}]], mod.VkStructureType, mod.StdVideoVP9Level)
mod.VkVideoDecodeVP9PictureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdPictureInfo;
	int32_t referenceNameSlotIndices[3U];
	uint32_t uncompressedHeaderOffset;
	uint32_t compressedHeaderOffset;
	uint32_t tilesOffset;
}]], mod.VkStructureType, mod.StdVideoDecodeVP9PictureInfo)
mod.VkPhysicalDeviceVideoMaintenance1FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ videoMaintenance1;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoInlineQueryInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ queryPool;
	uint32_t firstQuery;
	uint32_t queryCount;
}]], mod.VkStructureType, mod.VkQueryPool)
mod.VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVertexAttributeDivisorProperties)
mod.VkVertexInputBindingDivisorDescriptionKHR = ffi.typeof([[$ ]], mod.VkVertexInputBindingDivisorDescription)
mod.VkPipelineVertexInputDivisorStateCreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineVertexInputDivisorStateCreateInfo)
mod.VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVertexAttributeDivisorFeatures)
mod.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ unifiedImageLayouts;
	$ unifiedImageLayoutsVideo;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkAttachmentFeedbackLoopInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ feedbackLoopEnable;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderFloatControls2FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderFloatControls2Features)
mod.VkPhysicalDeviceIndexTypeUint8FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceIndexTypeUint8Features)
mod.VkLineRasterizationModeKHR = ffi.typeof([[$ ]], mod.VkLineRasterizationMode)
mod.VkPhysicalDeviceLineRasterizationFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceLineRasterizationFeatures)
mod.VkPhysicalDeviceLineRasterizationPropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceLineRasterizationProperties)
mod.VkPipelineRasterizationLineStateCreateInfoKHR = ffi.typeof([[$ ]], mod.VkPipelineRasterizationLineStateCreateInfo)
mod.PFN_vkCmdSetLineStippleKHR = ffi.typeof([[void (*)($ , uint32_t , uint16_t )]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetLineStippleKHR($ , uint32_t , uint16_t );]], mod.VkCommandBuffer)
mod.VkTimeDomainKHR = ffi.typeof([[enum {
	VK_TIME_DOMAIN_DEVICE_KHR = 0,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR = 1,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR = 2,
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR = 3,
	VK_TIME_DOMAIN_DEVICE_EXT = VK_TIME_DOMAIN_DEVICE_KHR,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
	VK_TIME_DOMAIN_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCalibratedTimestampInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ timeDomain;
}]], mod.VkStructureType, mod.VkTimeDomainKHR)
mod.PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkTimeDomainKHR)
mod.PFN_vkGetCalibratedTimestampsKHR = ffi.typeof([[$ (*)($ , uint32_t , const $*, uint64_t*, uint64_t*)]], mod.VkResult, mod.VkDevice, mod.VkCalibratedTimestampInfoKHR)
ffi.cdef([[$  vkGetPhysicalDeviceCalibrateableTimeDomainsKHR($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkTimeDomainKHR)
ffi.cdef([[$  vkGetCalibratedTimestampsKHR($ , uint32_t , const $*, uint64_t*, uint64_t*);]], mod.VkResult, mod.VkDevice, mod.VkCalibratedTimestampInfoKHR)
mod.VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderExpectAssumeFeatures)
mod.VkPhysicalDeviceMaintenance6FeaturesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance6Features)
mod.VkPhysicalDeviceMaintenance6PropertiesKHR = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMaintenance6Properties)
mod.VkBindMemoryStatusKHR = ffi.typeof([[$ ]], mod.VkBindMemoryStatus)
mod.VkBindDescriptorSetsInfoKHR = ffi.typeof([[$ ]], mod.VkBindDescriptorSetsInfo)
mod.VkPushConstantsInfoKHR = ffi.typeof([[$ ]], mod.VkPushConstantsInfo)
mod.VkPushDescriptorSetInfoKHR = ffi.typeof([[$ ]], mod.VkPushDescriptorSetInfo)
mod.VkPushDescriptorSetWithTemplateInfoKHR = ffi.typeof([[$ ]], mod.VkPushDescriptorSetWithTemplateInfo)
mod.VkSetDescriptorBufferOffsetsInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stageFlags;
	$ layout;
	uint32_t firstSet;
	uint32_t setCount;
	const uint32_t* pBufferIndices;
	const $* pOffsets;
}]], mod.VkStructureType, mod.VkShaderStageFlags, mod.VkPipelineLayout, mod.VkDeviceSize)
mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stageFlags;
	$ layout;
	uint32_t set;
}]], mod.VkStructureType, mod.VkShaderStageFlags, mod.VkPipelineLayout)
mod.PFN_vkCmdBindDescriptorSets2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBindDescriptorSetsInfo)
mod.PFN_vkCmdPushConstants2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushConstantsInfo)
mod.PFN_vkCmdPushDescriptorSet2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushDescriptorSetInfo)
mod.PFN_vkCmdPushDescriptorSetWithTemplate2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPushDescriptorSetWithTemplateInfo)
mod.PFN_vkCmdSetDescriptorBufferOffsets2EXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkSetDescriptorBufferOffsetsInfoEXT)
mod.PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT)
ffi.cdef([[void  vkCmdBindDescriptorSets2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkBindDescriptorSetsInfo)
ffi.cdef([[void  vkCmdPushConstants2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkPushConstantsInfo)
ffi.cdef([[void  vkCmdPushDescriptorSet2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkPushDescriptorSetInfo)
ffi.cdef([[void  vkCmdPushDescriptorSetWithTemplate2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkPushDescriptorSetWithTemplateInfo)
ffi.cdef([[void  vkCmdSetDescriptorBufferOffsets2EXT($ , const $*);]], mod.VkCommandBuffer, mod.VkSetDescriptorBufferOffsetsInfoEXT)
ffi.cdef([[void  vkCmdBindDescriptorBufferEmbeddedSamplers2EXT($ , const $*);]], mod.VkCommandBuffer, mod.VkBindDescriptorBufferEmbeddedSamplersInfoEXT)
mod.VkAddressCopyFlagBitsKHR = ffi.typeof([[enum {
	VK_ADDRESS_COPY_DEVICE_LOCAL_BIT_KHR = 0x00000001,
	VK_ADDRESS_COPY_SPARSE_BIT_KHR = 0x00000002,
	VK_ADDRESS_COPY_PROTECTED_BIT_KHR = 0x00000004,
	VK_ADDRESS_COPY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAddressCopyFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkStridedDeviceAddressRangeKHR = ffi.typeof([[struct {
	$ address;
	$ size;
	$ stride;
}]], mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkCopyMemoryIndirectCommandKHR = ffi.typeof([[struct {
	$ srcAddress;
	$ dstAddress;
	$ size;
}]], mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceSize)
mod.VkCopyMemoryIndirectInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcCopyFlags;
	$ dstCopyFlags;
	uint32_t copyCount;
	$ copyAddressRange;
}]], mod.VkStructureType, mod.VkAddressCopyFlagsKHR, mod.VkAddressCopyFlagsKHR, mod.VkStridedDeviceAddressRangeKHR)
mod.VkCopyMemoryToImageIndirectCommandKHR = ffi.typeof([[struct {
	$ srcAddress;
	uint32_t bufferRowLength;
	uint32_t bufferImageHeight;
	$ imageSubresource;
	$ imageOffset;
	$ imageExtent;
}]], mod.VkDeviceAddress, mod.VkImageSubresourceLayers, mod.VkOffset3D, mod.VkExtent3D)
mod.VkCopyMemoryToImageIndirectInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcCopyFlags;
	uint32_t copyCount;
	$ copyAddressRange;
	$ dstImage;
	$ dstImageLayout;
	const $* pImageSubresources;
}]], mod.VkStructureType, mod.VkAddressCopyFlagsKHR, mod.VkStridedDeviceAddressRangeKHR, mod.VkImage, mod.VkImageLayout, mod.VkImageSubresourceLayers)
mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ indirectMemoryCopy;
	$ indirectMemoryToImageCopy;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ supportedQueues;
}]], mod.VkStructureType, mod.VkQueueFlags)
mod.PFN_vkCmdCopyMemoryIndirectKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyMemoryIndirectInfoKHR)
mod.PFN_vkCmdCopyMemoryToImageIndirectKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyMemoryToImageIndirectInfoKHR)
ffi.cdef([[void  vkCmdCopyMemoryIndirectKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyMemoryIndirectInfoKHR)
ffi.cdef([[void  vkCmdCopyMemoryToImageIndirectKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyMemoryToImageIndirectInfoKHR)
mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR = 0,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeIntraRefreshModeFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeIntraRefreshCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ intraRefreshModes;
	uint32_t maxIntraRefreshCycleDuration;
	uint32_t maxIntraRefreshActiveReferencePictures;
	$ partitionIndependentIntraRefreshRegions;
	$ nonRectangularIntraRefreshRegions;
}]], mod.VkStructureType, mod.VkVideoEncodeIntraRefreshModeFlagsKHR, mod.VkBool32, mod.VkBool32)
mod.VkVideoEncodeSessionIntraRefreshCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ intraRefreshMode;
}]], mod.VkStructureType, mod.VkVideoEncodeIntraRefreshModeFlagBitsKHR)
mod.VkVideoEncodeIntraRefreshInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t intraRefreshCycleDuration;
	uint32_t intraRefreshIndex;
}]], mod.VkStructureType)
mod.VkVideoReferenceIntraRefreshInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t dirtyIntraRefreshRegions;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ videoEncodeIntraRefresh;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoEncodeQuantizationMapCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxQuantizationMapExtent;
}]], mod.VkStructureType, mod.VkExtent2D)
mod.VkVideoFormatQuantizationMapPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ quantizationMapTexelSize;
}]], mod.VkStructureType, mod.VkExtent2D)
mod.VkVideoEncodeQuantizationMapInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ quantizationMap;
	$ quantizationMapExtent;
}]], mod.VkStructureType, mod.VkImageView, mod.VkExtent2D)
mod.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ quantizationMapTexelSize;
}]], mod.VkStructureType, mod.VkExtent2D)
mod.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ videoEncodeQuantizationMap;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoEncodeH264QuantizationMapCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	int32_t minQpDelta;
	int32_t maxQpDelta;
}]], mod.VkStructureType)
mod.VkVideoEncodeH265QuantizationMapCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	int32_t minQpDelta;
	int32_t maxQpDelta;
}]], mod.VkStructureType)
mod.VkVideoFormatH265QuantizationMapPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ compatibleCtbSizes;
}]], mod.VkStructureType, mod.VkVideoEncodeH265CtbSizeFlagsKHR)
mod.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	int32_t minQIndexDelta;
	int32_t maxQIndexDelta;
}]], mod.VkStructureType)
mod.VkVideoFormatAV1QuantizationMapPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ compatibleSuperblockSizes;
}]], mod.VkStructureType, mod.VkVideoEncodeAV1SuperblockSizeFlagsKHR)
mod.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderRelaxedExtendedInstruction;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceLayeredApiKHR = ffi.typeof([[enum {
	VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR = 0,
	VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR = 1,
	VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR = 2,
	VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR = 3,
	VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR = 4,
	VK_PHYSICAL_DEVICE_LAYERED_API_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceMaintenance7FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maintenance7;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMaintenance7PropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ robustFragmentShadingRateAttachmentAccess;
	$ separateDepthStencilAttachmentAccess;
	uint32_t maxDescriptorSetTotalUniformBuffersDynamic;
	uint32_t maxDescriptorSetTotalStorageBuffersDynamic;
	uint32_t maxDescriptorSetTotalBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic;
	uint32_t maxDescriptorSetUpdateAfterBindTotalBuffersDynamic;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceLayeredApiPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t vendorID;
	uint32_t deviceID;
	$ layeredAPI;
	char deviceName[256U];
}]], mod.VkStructureType, mod.VkPhysicalDeviceLayeredApiKHR)
mod.VkPhysicalDeviceLayeredApiPropertiesListKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t layeredApiCount;
	$* pLayeredApis;
}]], mod.VkStructureType, mod.VkPhysicalDeviceLayeredApiPropertiesKHR)
mod.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ properties;
}]], mod.VkStructureType, mod.VkPhysicalDeviceProperties2)
mod.VkAccessFlags3KHR = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkAccessFlagBits3KHR = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_ACCESS_3_NONE_KHR = 0ULL
mod.VkMemoryBarrierAccessFlags3KHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcAccessMask3;
	$ dstAccessMask3;
}]], mod.VkStructureType, mod.VkAccessFlags3KHR, mod.VkAccessFlags3KHR)
mod.VkPhysicalDeviceMaintenance8FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maintenance8;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderFmaFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderFmaFloat16;
	$ shaderFmaFloat32;
	$ shaderFmaFloat64;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDefaultVertexAttributeValueKHR = ffi.typeof([[enum {
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR = 0,
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR = 1,
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceMaintenance9FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maintenance9;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMaintenance9PropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ image2DViewOf3DSparse;
	$ defaultVertexAttributeValue;
}]], mod.VkStructureType, mod.VkBool32, mod.VkDefaultVertexAttributeValueKHR)
mod.VkQueueFamilyOwnershipTransferPropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t optimalImageTransferToQueueFamilies;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceVideoMaintenance2FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ videoMaintenance2;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoDecodeH264InlineSessionParametersInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdSPS;
	const $* pStdPPS;
}]], mod.VkStructureType, mod.StdVideoH264SequenceParameterSet, mod.StdVideoH264PictureParameterSet)
mod.VkVideoDecodeH265InlineSessionParametersInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdVPS;
	const $* pStdSPS;
	const $* pStdPPS;
}]], mod.VkStructureType, mod.StdVideoH265VideoParameterSet, mod.StdVideoH265SequenceParameterSet, mod.StdVideoH265PictureParameterSet)
mod.VkVideoDecodeAV1InlineSessionParametersInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pStdSequenceHeader;
}]], mod.VkStructureType, mod.StdVideoAV1SequenceHeader)
mod.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ depthClampZeroOne;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceRobustness2FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ robustBufferAccess2;
	$ robustImageAccess2;
	$ nullDescriptor;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceRobustness2PropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ robustStorageBufferAccessSizeAlignment;
	$ robustUniformBufferAccessSizeAlignment;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentModeFifoLatestReady;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkRenderingAttachmentFlagBitsKHR = ffi.typeof([[enum {
	VK_RENDERING_ATTACHMENT_INPUT_ATTACHMENT_FEEDBACK_BIT_KHR = 0x00000001,
	VK_RENDERING_ATTACHMENT_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR = 0x00000002,
	VK_RENDERING_ATTACHMENT_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR = 0x00000004,
	VK_RENDERING_ATTACHMENT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkRenderingAttachmentFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkResolveImageFlagBitsKHR = ffi.typeof([[enum {
	VK_RESOLVE_IMAGE_SKIP_TRANSFER_FUNCTION_BIT_KHR = 0x00000001,
	VK_RESOLVE_IMAGE_ENABLE_TRANSFER_FUNCTION_BIT_KHR = 0x00000002,
	VK_RESOLVE_IMAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkResolveImageFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceMaintenance10FeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maintenance10;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMaintenance10PropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rgba4OpaqueBlackSwizzled;
	$ resolveSrgbFormatAppliesTransferFunction;
	$ resolveSrgbFormatSupportsTransferFunctionControl;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkRenderingEndInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
mod.VkRenderingAttachmentFlagsInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkRenderingAttachmentFlagsKHR)
mod.VkResolveImageModeInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ resolveMode;
	$ stencilResolveMode;
}]], mod.VkStructureType, mod.VkResolveImageFlagsKHR, mod.VkResolveModeFlagBits, mod.VkResolveModeFlagBits)
mod.PFN_vkCmdEndRendering2KHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingEndInfoKHR)
ffi.cdef([[void  vkCmdEndRendering2KHR($ , const $*);]], mod.VkCommandBuffer, mod.VkRenderingEndInfoKHR)
mod.VkDebugReportCallbackEXT = ffi.typeof([[void*]])
mod.VkDebugReportObjectTypeEXT = ffi.typeof([[enum {
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT = 1000307000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT = 1000307001,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
	VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDebugReportFlagBitsEXT = ffi.typeof([[enum {
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
	VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
	VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
	VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
	VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDebugReportFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.PFN_vkDebugReportCallbackEXT = ffi.typeof([[$ (*)($ , $ , uint64_t , size_t , int32_t , const char*, const char*, void*)]], mod.VkBool32, mod.VkDebugReportFlagsEXT, mod.VkDebugReportObjectTypeEXT)
mod.VkDebugReportCallbackCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ pfnCallback;
	void* pUserData;
}]], mod.VkStructureType, mod.VkDebugReportFlagsEXT, mod.PFN_vkDebugReportCallbackEXT)
mod.PFN_vkCreateDebugReportCallbackEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkDebugReportCallbackCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkDebugReportCallbackEXT)
mod.PFN_vkDestroyDebugReportCallbackEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkInstance, mod.VkDebugReportCallbackEXT, mod.VkAllocationCallbacks)
mod.PFN_vkDebugReportMessageEXT = ffi.typeof([[void (*)($ , $ , $ , uint64_t , size_t , int32_t , const char*, const char*)]], mod.VkInstance, mod.VkDebugReportFlagsEXT, mod.VkDebugReportObjectTypeEXT)
ffi.cdef([[$  vkCreateDebugReportCallbackEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkDebugReportCallbackCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkDebugReportCallbackEXT)
ffi.cdef([[void  vkDestroyDebugReportCallbackEXT($ , $ , const $*);]], mod.VkInstance, mod.VkDebugReportCallbackEXT, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkDebugReportMessageEXT($ , $ , $ , uint64_t , size_t , int32_t , const char*, const char*);]], mod.VkInstance, mod.VkDebugReportFlagsEXT, mod.VkDebugReportObjectTypeEXT)
mod.VkRasterizationOrderAMD = ffi.typeof([[enum {
	VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
	VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
	VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkPipelineRasterizationStateRasterizationOrderAMD = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ rasterizationOrder;
}]], mod.VkStructureType, mod.VkRasterizationOrderAMD)
mod.VkDebugMarkerObjectNameInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ objectType;
	uint64_t object;
	const char* pObjectName;
}]], mod.VkStructureType, mod.VkDebugReportObjectTypeEXT)
mod.VkDebugMarkerObjectTagInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ objectType;
	uint64_t object;
	uint64_t tagName;
	size_t tagSize;
	const void* pTag;
}]], mod.VkStructureType, mod.VkDebugReportObjectTypeEXT)
mod.VkDebugMarkerMarkerInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const char* pMarkerName;
	float color[4];
}]], mod.VkStructureType)
mod.PFN_vkDebugMarkerSetObjectTagEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDebugMarkerObjectTagInfoEXT)
mod.PFN_vkDebugMarkerSetObjectNameEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDebugMarkerObjectNameInfoEXT)
mod.PFN_vkCmdDebugMarkerBeginEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDebugMarkerMarkerInfoEXT)
mod.PFN_vkCmdDebugMarkerEndEXT = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDebugMarkerInsertEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDebugMarkerMarkerInfoEXT)
ffi.cdef([[$  vkDebugMarkerSetObjectTagEXT($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDebugMarkerObjectTagInfoEXT)
ffi.cdef([[$  vkDebugMarkerSetObjectNameEXT($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDebugMarkerObjectNameInfoEXT)
ffi.cdef([[void  vkCmdDebugMarkerBeginEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkDebugMarkerMarkerInfoEXT)
ffi.cdef([[void  vkCmdDebugMarkerEndEXT($ );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdDebugMarkerInsertEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkDebugMarkerMarkerInfoEXT)
mod.VkDedicatedAllocationImageCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ dedicatedAllocation;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDedicatedAllocationBufferCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ dedicatedAllocation;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDedicatedAllocationMemoryAllocateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ buffer;
}]], mod.VkStructureType, mod.VkImage, mod.VkBuffer)
mod.VkPipelineRasterizationStateStreamCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceTransformFeedbackFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ transformFeedback;
	$ geometryStreams;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceTransformFeedbackPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxTransformFeedbackStreams;
	uint32_t maxTransformFeedbackBuffers;
	$ maxTransformFeedbackBufferSize;
	uint32_t maxTransformFeedbackStreamDataSize;
	uint32_t maxTransformFeedbackBufferDataSize;
	uint32_t maxTransformFeedbackBufferDataStride;
	$ transformFeedbackQueries;
	$ transformFeedbackStreamsLinesTriangles;
	$ transformFeedbackRasterizationStreamSelect;
	$ transformFeedbackDraw;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPipelineRasterizationStateStreamCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t rasterizationStream;
}]], mod.VkStructureType, mod.VkPipelineRasterizationStateStreamCreateFlagsEXT)
mod.PFN_vkCmdBindTransformFeedbackBuffersEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*, const $*, const $*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
mod.PFN_vkCmdBeginTransformFeedbackEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*, const $*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdEndTransformFeedbackEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*, const $*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdBeginQueryIndexedEXT = ffi.typeof([[void (*)($ , $ , uint32_t , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkQueryPool, mod.VkQueryControlFlags)
mod.PFN_vkCmdEndQueryIndexedEXT = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkQueryPool)
mod.PFN_vkCmdDrawIndirectByteCountEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdBindTransformFeedbackBuffersEXT($ , uint32_t , uint32_t , const $*, const $*, const $*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdBeginTransformFeedbackEXT($ , uint32_t , uint32_t , const $*, const $*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdEndTransformFeedbackEXT($ , uint32_t , uint32_t , const $*, const $*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdBeginQueryIndexedEXT($ , $ , uint32_t , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkQueryPool, mod.VkQueryControlFlags)
ffi.cdef([[void  vkCmdEndQueryIndexedEXT($ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkQueryPool)
ffi.cdef([[void  vkCmdDrawIndirectByteCountEXT($ , uint32_t , uint32_t , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.VkCuModuleNVX = ffi.typeof([[void*]])
mod.VkCuFunctionNVX = ffi.typeof([[void*]])
mod.VkCuModuleCreateInfoNVX = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	size_t dataSize;
	const void* pData;
}]], mod.VkStructureType)
mod.VkCuModuleTexturingModeCreateInfoNVX = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ use64bitTexturing;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkCuFunctionCreateInfoNVX = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ module;
	const char* pName;
}]], mod.VkStructureType, mod.VkCuModuleNVX)
mod.VkCuLaunchInfoNVX = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ function;
	uint32_t gridDimX;
	uint32_t gridDimY;
	uint32_t gridDimZ;
	uint32_t blockDimX;
	uint32_t blockDimY;
	uint32_t blockDimZ;
	uint32_t sharedMemBytes;
	size_t paramCount;
	const void** const pParams;
	size_t extraCount;
	const void** const pExtras;
}]], mod.VkStructureType, mod.VkCuFunctionNVX)
mod.PFN_vkCreateCuModuleNVX = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkCuModuleCreateInfoNVX, mod.VkAllocationCallbacks, mod.VkCuModuleNVX)
mod.PFN_vkCreateCuFunctionNVX = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkCuFunctionCreateInfoNVX, mod.VkAllocationCallbacks, mod.VkCuFunctionNVX)
mod.PFN_vkDestroyCuModuleNVX = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkCuModuleNVX, mod.VkAllocationCallbacks)
mod.PFN_vkDestroyCuFunctionNVX = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkCuFunctionNVX, mod.VkAllocationCallbacks)
mod.PFN_vkCmdCuLaunchKernelNVX = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCuLaunchInfoNVX)
ffi.cdef([[$  vkCreateCuModuleNVX($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkCuModuleCreateInfoNVX, mod.VkAllocationCallbacks, mod.VkCuModuleNVX)
ffi.cdef([[$  vkCreateCuFunctionNVX($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkCuFunctionCreateInfoNVX, mod.VkAllocationCallbacks, mod.VkCuFunctionNVX)
ffi.cdef([[void  vkDestroyCuModuleNVX($ , $ , const $*);]], mod.VkDevice, mod.VkCuModuleNVX, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkDestroyCuFunctionNVX($ , $ , const $*);]], mod.VkDevice, mod.VkCuFunctionNVX, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkCmdCuLaunchKernelNVX($ , const $*);]], mod.VkCommandBuffer, mod.VkCuLaunchInfoNVX)
mod.VkImageViewHandleInfoNVX = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ imageView;
	$ descriptorType;
	$ sampler;
}]], mod.VkStructureType, mod.VkImageView, mod.VkDescriptorType, mod.VkSampler)
mod.VkImageViewAddressPropertiesNVX = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ deviceAddress;
	$ size;
}]], mod.VkStructureType, mod.VkDeviceAddress, mod.VkDeviceSize)
mod.PFN_vkGetImageViewHandleNVX = ffi.typeof([[uint32_t (*)($ , const $*)]], mod.VkDevice, mod.VkImageViewHandleInfoNVX)
mod.PFN_vkGetImageViewHandle64NVX = ffi.typeof([[uint64_t (*)($ , const $*)]], mod.VkDevice, mod.VkImageViewHandleInfoNVX)
mod.PFN_vkGetImageViewAddressNVX = ffi.typeof([[$ (*)($ , $ , $*)]], mod.VkResult, mod.VkDevice, mod.VkImageView, mod.VkImageViewAddressPropertiesNVX)
ffi.cdef([[uint32_t  vkGetImageViewHandleNVX($ , const $*);]], mod.VkDevice, mod.VkImageViewHandleInfoNVX)
ffi.cdef([[uint64_t  vkGetImageViewHandle64NVX($ , const $*);]], mod.VkDevice, mod.VkImageViewHandleInfoNVX)
ffi.cdef([[$  vkGetImageViewAddressNVX($ , $ , $*);]], mod.VkResult, mod.VkDevice, mod.VkImageView, mod.VkImageViewAddressPropertiesNVX)
mod.PFN_vkCmdDrawIndirectCountAMD = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdDrawIndexedIndirectCountAMD = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawIndirectCountAMD($ , $ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawIndexedIndirectCountAMD($ , $ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.VkTextureLODGatherFormatPropertiesAMD = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ supportsTextureGatherLODBiasAMD;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkShaderInfoTypeAMD = ffi.typeof([[enum {
	VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
	VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
	VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
	VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkShaderResourceUsageAMD = ffi.typeof([[struct {
	uint32_t numUsedVgprs;
	uint32_t numUsedSgprs;
	uint32_t ldsSizePerLocalWorkGroup;
	size_t ldsUsageSizeInBytes;
	size_t scratchMemUsageInBytes;
}]])
mod.VkShaderStatisticsInfoAMD = ffi.typeof([[struct {
	$ shaderStageMask;
	$ resourceUsage;
	uint32_t numPhysicalVgprs;
	uint32_t numPhysicalSgprs;
	uint32_t numAvailableVgprs;
	uint32_t numAvailableSgprs;
	uint32_t computeWorkGroupSize[3];
}]], mod.VkShaderStageFlags, mod.VkShaderResourceUsageAMD)
mod.PFN_vkGetShaderInfoAMD = ffi.typeof([[$ (*)($ , $ , $ , $ , size_t*, void*)]], mod.VkResult, mod.VkDevice, mod.VkPipeline, mod.VkShaderStageFlagBits, mod.VkShaderInfoTypeAMD)
ffi.cdef([[$  vkGetShaderInfoAMD($ , $ , $ , $ , size_t*, void*);]], mod.VkResult, mod.VkDevice, mod.VkPipeline, mod.VkShaderStageFlagBits, mod.VkShaderInfoTypeAMD)
mod.VkPhysicalDeviceCornerSampledImageFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cornerSampledImage;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkExternalMemoryHandleTypeFlagBitsNV = ffi.typeof([[enum {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkExternalMemoryHandleTypeFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalMemoryFeatureFlagBitsNV = ffi.typeof([[enum {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkExternalMemoryFeatureFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExternalImageFormatPropertiesNV = ffi.typeof([[struct {
	$ imageFormatProperties;
	$ externalMemoryFeatures;
	$ exportFromImportedHandleTypes;
	$ compatibleHandleTypes;
}]], mod.VkImageFormatProperties, mod.VkExternalMemoryFeatureFlagsNV, mod.VkExternalMemoryHandleTypeFlagsNV, mod.VkExternalMemoryHandleTypeFlagsNV)
mod.PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = ffi.typeof([[$ (*)($ , $ , $ , $ , $ , $ , $ , $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkFormat, mod.VkImageType, mod.VkImageTiling, mod.VkImageUsageFlags, mod.VkImageCreateFlags, mod.VkExternalMemoryHandleTypeFlagsNV, mod.VkExternalImageFormatPropertiesNV)
ffi.cdef([[$  vkGetPhysicalDeviceExternalImageFormatPropertiesNV($ , $ , $ , $ , $ , $ , $ , $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkFormat, mod.VkImageType, mod.VkImageTiling, mod.VkImageUsageFlags, mod.VkImageCreateFlags, mod.VkExternalMemoryHandleTypeFlagsNV, mod.VkExternalImageFormatPropertiesNV)
mod.VkExternalMemoryImageCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlagsNV)
mod.VkExportMemoryAllocateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlagsNV)
mod.VkValidationCheckEXT = ffi.typeof([[enum {
	VK_VALIDATION_CHECK_ALL_EXT = 0,
	VK_VALIDATION_CHECK_SHADERS_EXT = 1,
	VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkValidationFlagsEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t disabledValidationCheckCount;
	const $* pDisabledValidationChecks;
}]], mod.VkStructureType, mod.VkValidationCheckEXT)
mod.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceTextureCompressionASTCHDRFeatures)
mod.VkImageViewASTCDecodeModeEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ decodeMode;
}]], mod.VkStructureType, mod.VkFormat)
mod.VkPhysicalDeviceASTCDecodeFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ decodeModeSharedExponent;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineRobustnessBufferBehaviorEXT = ffi.typeof([[$ ]], mod.VkPipelineRobustnessBufferBehavior)
mod.VkPipelineRobustnessImageBehaviorEXT = ffi.typeof([[$ ]], mod.VkPipelineRobustnessImageBehavior)
mod.VkPhysicalDevicePipelineRobustnessFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePipelineRobustnessFeatures)
mod.VkPhysicalDevicePipelineRobustnessPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePipelineRobustnessProperties)
mod.VkPipelineRobustnessCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineRobustnessCreateInfo)
mod.VkConditionalRenderingFlagBitsEXT = ffi.typeof([[enum {
	VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x00000001,
	VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkConditionalRenderingFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkConditionalRenderingBeginInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ buffer;
	$ offset;
	$ flags;
}]], mod.VkStructureType, mod.VkBuffer, mod.VkDeviceSize, mod.VkConditionalRenderingFlagsEXT)
mod.VkPhysicalDeviceConditionalRenderingFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ conditionalRendering;
	$ inheritedConditionalRendering;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkCommandBufferInheritanceConditionalRenderingInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ conditionalRenderingEnable;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkCmdBeginConditionalRenderingEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkConditionalRenderingBeginInfoEXT)
mod.PFN_vkCmdEndConditionalRenderingEXT = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdBeginConditionalRenderingEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkConditionalRenderingBeginInfoEXT)
ffi.cdef([[void  vkCmdEndConditionalRenderingEXT($ );]], mod.VkCommandBuffer)
mod.VkViewportWScalingNV = ffi.typeof([[struct {
	float xcoeff;
	float ycoeff;
}]])
mod.VkPipelineViewportWScalingStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ viewportWScalingEnable;
	uint32_t viewportCount;
	const $* pViewportWScalings;
}]], mod.VkStructureType, mod.VkBool32, mod.VkViewportWScalingNV)
mod.PFN_vkCmdSetViewportWScalingNV = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkViewportWScalingNV)
ffi.cdef([[void  vkCmdSetViewportWScalingNV($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkViewportWScalingNV)
mod.PFN_vkReleaseDisplayEXT = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
ffi.cdef([[$  vkReleaseDisplayEXT($ , $ );]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
mod.VkSurfaceCounterFlagBitsEXT = ffi.typeof([[enum {
	VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 0x00000001,
	VK_SURFACE_COUNTER_VBLANK_EXT = VK_SURFACE_COUNTER_VBLANK_BIT_EXT,
	VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkSurfaceCounterFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkSurfaceCapabilities2EXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t minImageCount;
	uint32_t maxImageCount;
	$ currentExtent;
	$ minImageExtent;
	$ maxImageExtent;
	uint32_t maxImageArrayLayers;
	$ supportedTransforms;
	$ currentTransform;
	$ supportedCompositeAlpha;
	$ supportedUsageFlags;
	$ supportedSurfaceCounters;
}]], mod.VkStructureType, mod.VkExtent2D, mod.VkExtent2D, mod.VkExtent2D, mod.VkSurfaceTransformFlagsKHR, mod.VkSurfaceTransformFlagBitsKHR, mod.VkCompositeAlphaFlagsKHR, mod.VkImageUsageFlags, mod.VkSurfaceCounterFlagsEXT)
mod.PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = ffi.typeof([[$ (*)($ , $ , $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkSurfaceCapabilities2EXT)
ffi.cdef([[$  vkGetPhysicalDeviceSurfaceCapabilities2EXT($ , $ , $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkSurfaceKHR, mod.VkSurfaceCapabilities2EXT)
mod.VkDisplayPowerStateEXT = ffi.typeof([[enum {
	VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
	VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
	VK_DISPLAY_POWER_STATE_ON_EXT = 2,
	VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceEventTypeEXT = ffi.typeof([[enum {
	VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
	VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDisplayEventTypeEXT = ffi.typeof([[enum {
	VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
	VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDisplayPowerInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ powerState;
}]], mod.VkStructureType, mod.VkDisplayPowerStateEXT)
mod.VkDeviceEventInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ deviceEvent;
}]], mod.VkStructureType, mod.VkDeviceEventTypeEXT)
mod.VkDisplayEventInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ displayEvent;
}]], mod.VkStructureType, mod.VkDisplayEventTypeEXT)
mod.VkSwapchainCounterCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ surfaceCounters;
}]], mod.VkStructureType, mod.VkSurfaceCounterFlagsEXT)
mod.PFN_vkDisplayPowerControlEXT = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDisplayKHR, mod.VkDisplayPowerInfoEXT)
mod.PFN_vkRegisterDeviceEventEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDeviceEventInfoEXT, mod.VkAllocationCallbacks, mod.VkFence)
mod.PFN_vkRegisterDisplayEventEXT = ffi.typeof([[$ (*)($ , $ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDisplayKHR, mod.VkDisplayEventInfoEXT, mod.VkAllocationCallbacks, mod.VkFence)
mod.PFN_vkGetSwapchainCounterEXT = ffi.typeof([[$ (*)($ , $ , $ , uint64_t*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkSurfaceCounterFlagBitsEXT)
ffi.cdef([[$  vkDisplayPowerControlEXT($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDisplayKHR, mod.VkDisplayPowerInfoEXT)
ffi.cdef([[$  vkRegisterDeviceEventEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDeviceEventInfoEXT, mod.VkAllocationCallbacks, mod.VkFence)
ffi.cdef([[$  vkRegisterDisplayEventEXT($ , $ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDisplayKHR, mod.VkDisplayEventInfoEXT, mod.VkAllocationCallbacks, mod.VkFence)
ffi.cdef([[$  vkGetSwapchainCounterEXT($ , $ , $ , uint64_t*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkSurfaceCounterFlagBitsEXT)
mod.VkRefreshCycleDurationGOOGLE = ffi.typeof([[struct {
	uint64_t refreshDuration;
}]])
mod.VkPastPresentationTimingGOOGLE = ffi.typeof([[struct {
	uint32_t presentID;
	uint64_t desiredPresentTime;
	uint64_t actualPresentTime;
	uint64_t earliestPresentTime;
	uint64_t presentMargin;
}]])
mod.VkPresentTimeGOOGLE = ffi.typeof([[struct {
	uint32_t presentID;
	uint64_t desiredPresentTime;
}]])
mod.VkPresentTimesInfoGOOGLE = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t swapchainCount;
	const $* pTimes;
}]], mod.VkStructureType, mod.VkPresentTimeGOOGLE)
mod.PFN_vkGetRefreshCycleDurationGOOGLE = ffi.typeof([[$ (*)($ , $ , $*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkRefreshCycleDurationGOOGLE)
mod.PFN_vkGetPastPresentationTimingGOOGLE = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkPastPresentationTimingGOOGLE)
ffi.cdef([[$  vkGetRefreshCycleDurationGOOGLE($ , $ , $*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkRefreshCycleDurationGOOGLE)
ffi.cdef([[$  vkGetPastPresentationTimingGOOGLE($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkPastPresentationTimingGOOGLE)
mod.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ perViewPositionAllComponents;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkMultiviewPerViewAttributesInfoNVX = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ perViewAttributes;
	$ perViewAttributesPositionXOnly;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkViewportCoordinateSwizzleNV = ffi.typeof([[enum {
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
	VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPipelineViewportSwizzleStateCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkViewportSwizzleNV = ffi.typeof([[struct {
	$ x;
	$ y;
	$ z;
	$ w;
}]], mod.VkViewportCoordinateSwizzleNV, mod.VkViewportCoordinateSwizzleNV, mod.VkViewportCoordinateSwizzleNV, mod.VkViewportCoordinateSwizzleNV)
mod.VkPipelineViewportSwizzleStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t viewportCount;
	const $* pViewportSwizzles;
}]], mod.VkStructureType, mod.VkPipelineViewportSwizzleStateCreateFlagsNV, mod.VkViewportSwizzleNV)
mod.VkDiscardRectangleModeEXT = ffi.typeof([[enum {
	VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
	VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
	VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPipelineDiscardRectangleStateCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDiscardRectanglePropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxDiscardRectangles;
}]], mod.VkStructureType)
mod.VkPipelineDiscardRectangleStateCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ discardRectangleMode;
	uint32_t discardRectangleCount;
	const $* pDiscardRectangles;
}]], mod.VkStructureType, mod.VkPipelineDiscardRectangleStateCreateFlagsEXT, mod.VkDiscardRectangleModeEXT, mod.VkRect2D)
mod.PFN_vkCmdSetDiscardRectangleEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkRect2D)
mod.PFN_vkCmdSetDiscardRectangleEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDiscardRectangleModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkDiscardRectangleModeEXT)
ffi.cdef([[void  vkCmdSetDiscardRectangleEXT($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkRect2D)
ffi.cdef([[void  vkCmdSetDiscardRectangleEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDiscardRectangleModeEXT($ , $ );]], mod.VkCommandBuffer, mod.VkDiscardRectangleModeEXT)
mod.VkConservativeRasterizationModeEXT = ffi.typeof([[enum {
	VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
	VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
	VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
	VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPipelineRasterizationConservativeStateCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceConservativeRasterizationPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	float primitiveOverestimationSize;
	float maxExtraPrimitiveOverestimationSize;
	float extraPrimitiveOverestimationSizeGranularity;
	$ primitiveUnderestimation;
	$ conservativePointAndLineRasterization;
	$ degenerateTrianglesRasterized;
	$ degenerateLinesRasterized;
	$ fullyCoveredFragmentShaderInputVariable;
	$ conservativeRasterizationPostDepthCoverage;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPipelineRasterizationConservativeStateCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ conservativeRasterizationMode;
	float extraPrimitiveOverestimationSize;
}]], mod.VkStructureType, mod.VkPipelineRasterizationConservativeStateCreateFlagsEXT, mod.VkConservativeRasterizationModeEXT)
mod.VkPipelineRasterizationDepthClipStateCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDepthClipEnableFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ depthClipEnable;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineRasterizationDepthClipStateCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ depthClipEnable;
}]], mod.VkStructureType, mod.VkPipelineRasterizationDepthClipStateCreateFlagsEXT, mod.VkBool32)
mod.VkXYColorEXT = ffi.typeof([[struct {
	float x;
	float y;
}]])
mod.VkHdrMetadataEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ displayPrimaryRed;
	$ displayPrimaryGreen;
	$ displayPrimaryBlue;
	$ whitePoint;
	float maxLuminance;
	float minLuminance;
	float maxContentLightLevel;
	float maxFrameAverageLightLevel;
}]], mod.VkStructureType, mod.VkXYColorEXT, mod.VkXYColorEXT, mod.VkXYColorEXT, mod.VkXYColorEXT)
mod.PFN_vkSetHdrMetadataEXT = ffi.typeof([[void (*)($ , uint32_t , const $*, const $*)]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkHdrMetadataEXT)
ffi.cdef([[void  vkSetHdrMetadataEXT($ , uint32_t , const $*, const $*);]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkHdrMetadataEXT)
mod.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ relaxedLineRasterization;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDebugUtilsMessengerEXT = ffi.typeof([[void*]])
mod.VkDebugUtilsMessengerCallbackDataFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDebugUtilsMessageSeverityFlagBitsEXT = ffi.typeof([[enum {
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x00000010,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x00001000,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDebugUtilsMessageTypeFlagBitsEXT = ffi.typeof([[enum {
	VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x00000001,
	VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x00000002,
	VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004,
	VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 0x00000008,
	VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDebugUtilsMessageTypeFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDebugUtilsMessageSeverityFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDebugUtilsMessengerCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDebugUtilsLabelEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const char* pLabelName;
	float color[4];
}]], mod.VkStructureType)
mod.VkDebugUtilsObjectNameInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ objectType;
	uint64_t objectHandle;
	const char* pObjectName;
}]], mod.VkStructureType, mod.VkObjectType)
mod.VkDebugUtilsMessengerCallbackDataEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const char* pMessageIdName;
	int32_t messageIdNumber;
	const char* pMessage;
	uint32_t queueLabelCount;
	const $* pQueueLabels;
	uint32_t cmdBufLabelCount;
	const $* pCmdBufLabels;
	uint32_t objectCount;
	const $* pObjects;
}]], mod.VkStructureType, mod.VkDebugUtilsMessengerCallbackDataFlagsEXT, mod.VkDebugUtilsLabelEXT, mod.VkDebugUtilsLabelEXT, mod.VkDebugUtilsObjectNameInfoEXT)
mod.PFN_vkDebugUtilsMessengerCallbackEXT = ffi.typeof([[$ (*)($ , $ , const $*, void*)]], mod.VkBool32, mod.VkDebugUtilsMessageSeverityFlagBitsEXT, mod.VkDebugUtilsMessageTypeFlagsEXT, mod.VkDebugUtilsMessengerCallbackDataEXT)
mod.VkDebugUtilsMessengerCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ messageSeverity;
	$ messageType;
	$ pfnUserCallback;
	void* pUserData;
}]], mod.VkStructureType, mod.VkDebugUtilsMessengerCreateFlagsEXT, mod.VkDebugUtilsMessageSeverityFlagsEXT, mod.VkDebugUtilsMessageTypeFlagsEXT, mod.PFN_vkDebugUtilsMessengerCallbackEXT)
mod.VkDebugUtilsObjectTagInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ objectType;
	uint64_t objectHandle;
	uint64_t tagName;
	size_t tagSize;
	const void* pTag;
}]], mod.VkStructureType, mod.VkObjectType)
mod.PFN_vkSetDebugUtilsObjectNameEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDebugUtilsObjectNameInfoEXT)
mod.PFN_vkSetDebugUtilsObjectTagEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDebugUtilsObjectTagInfoEXT)
mod.PFN_vkQueueBeginDebugUtilsLabelEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkQueue, mod.VkDebugUtilsLabelEXT)
mod.PFN_vkQueueEndDebugUtilsLabelEXT = ffi.typeof([[void (*)($ )]], mod.VkQueue)
mod.PFN_vkQueueInsertDebugUtilsLabelEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkQueue, mod.VkDebugUtilsLabelEXT)
mod.PFN_vkCmdBeginDebugUtilsLabelEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDebugUtilsLabelEXT)
mod.PFN_vkCmdEndDebugUtilsLabelEXT = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
mod.PFN_vkCmdInsertDebugUtilsLabelEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDebugUtilsLabelEXT)
mod.PFN_vkCreateDebugUtilsMessengerEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkDebugUtilsMessengerCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkDebugUtilsMessengerEXT)
mod.PFN_vkDestroyDebugUtilsMessengerEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkInstance, mod.VkDebugUtilsMessengerEXT, mod.VkAllocationCallbacks)
mod.PFN_vkSubmitDebugUtilsMessageEXT = ffi.typeof([[void (*)($ , $ , $ , const $*)]], mod.VkInstance, mod.VkDebugUtilsMessageSeverityFlagBitsEXT, mod.VkDebugUtilsMessageTypeFlagsEXT, mod.VkDebugUtilsMessengerCallbackDataEXT)
ffi.cdef([[$  vkSetDebugUtilsObjectNameEXT($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDebugUtilsObjectNameInfoEXT)
ffi.cdef([[$  vkSetDebugUtilsObjectTagEXT($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDebugUtilsObjectTagInfoEXT)
ffi.cdef([[void  vkQueueBeginDebugUtilsLabelEXT($ , const $*);]], mod.VkQueue, mod.VkDebugUtilsLabelEXT)
ffi.cdef([[void  vkQueueEndDebugUtilsLabelEXT($ );]], mod.VkQueue)
ffi.cdef([[void  vkQueueInsertDebugUtilsLabelEXT($ , const $*);]], mod.VkQueue, mod.VkDebugUtilsLabelEXT)
ffi.cdef([[void  vkCmdBeginDebugUtilsLabelEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkDebugUtilsLabelEXT)
ffi.cdef([[void  vkCmdEndDebugUtilsLabelEXT($ );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdInsertDebugUtilsLabelEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkDebugUtilsLabelEXT)
ffi.cdef([[$  vkCreateDebugUtilsMessengerEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkDebugUtilsMessengerCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkDebugUtilsMessengerEXT)
ffi.cdef([[void  vkDestroyDebugUtilsMessengerEXT($ , $ , const $*);]], mod.VkInstance, mod.VkDebugUtilsMessengerEXT, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkSubmitDebugUtilsMessageEXT($ , $ , $ , const $*);]], mod.VkInstance, mod.VkDebugUtilsMessageSeverityFlagBitsEXT, mod.VkDebugUtilsMessageTypeFlagsEXT, mod.VkDebugUtilsMessengerCallbackDataEXT)
mod.VkSamplerReductionModeEXT = ffi.typeof([[$ ]], mod.VkSamplerReductionMode)
mod.VkSamplerReductionModeCreateInfoEXT = ffi.typeof([[$ ]], mod.VkSamplerReductionModeCreateInfo)
mod.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSamplerFilterMinmaxProperties)
mod.VkAttachmentSampleCountInfoAMD = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t colorAttachmentCount;
	const $* pColorAttachmentSamples;
	$ depthStencilAttachmentSamples;
}]], mod.VkStructureType, mod.VkSampleCountFlagBits, mod.VkSampleCountFlagBits)
mod.VkPhysicalDeviceInlineUniformBlockFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceInlineUniformBlockFeatures)
mod.VkPhysicalDeviceInlineUniformBlockPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceInlineUniformBlockProperties)
mod.VkWriteDescriptorSetInlineUniformBlockEXT = ffi.typeof([[$ ]], mod.VkWriteDescriptorSetInlineUniformBlock)
mod.VkDescriptorPoolInlineUniformBlockCreateInfoEXT = ffi.typeof([[$ ]], mod.VkDescriptorPoolInlineUniformBlockCreateInfo)
mod.VkSampleLocationEXT = ffi.typeof([[struct {
	float x;
	float y;
}]])
mod.VkSampleLocationsInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ sampleLocationsPerPixel;
	$ sampleLocationGridSize;
	uint32_t sampleLocationsCount;
	const $* pSampleLocations;
}]], mod.VkStructureType, mod.VkSampleCountFlagBits, mod.VkExtent2D, mod.VkSampleLocationEXT)
mod.VkAttachmentSampleLocationsEXT = ffi.typeof([[struct {
	uint32_t attachmentIndex;
	$ sampleLocationsInfo;
}]], mod.VkSampleLocationsInfoEXT)
mod.VkSubpassSampleLocationsEXT = ffi.typeof([[struct {
	uint32_t subpassIndex;
	$ sampleLocationsInfo;
}]], mod.VkSampleLocationsInfoEXT)
mod.VkRenderPassSampleLocationsBeginInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t attachmentInitialSampleLocationsCount;
	const $* pAttachmentInitialSampleLocations;
	uint32_t postSubpassSampleLocationsCount;
	const $* pPostSubpassSampleLocations;
}]], mod.VkStructureType, mod.VkAttachmentSampleLocationsEXT, mod.VkSubpassSampleLocationsEXT)
mod.VkPipelineSampleLocationsStateCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ sampleLocationsEnable;
	$ sampleLocationsInfo;
}]], mod.VkStructureType, mod.VkBool32, mod.VkSampleLocationsInfoEXT)
mod.VkPhysicalDeviceSampleLocationsPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ sampleLocationSampleCounts;
	$ maxSampleLocationGridSize;
	float sampleLocationCoordinateRange[2];
	uint32_t sampleLocationSubPixelBits;
	$ variableSampleLocations;
}]], mod.VkStructureType, mod.VkSampleCountFlags, mod.VkExtent2D, mod.VkBool32)
mod.VkMultisamplePropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxSampleLocationGridSize;
}]], mod.VkStructureType, mod.VkExtent2D)
mod.PFN_vkCmdSetSampleLocationsEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkSampleLocationsInfoEXT)
mod.PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkPhysicalDevice, mod.VkSampleCountFlagBits, mod.VkMultisamplePropertiesEXT)
ffi.cdef([[void  vkCmdSetSampleLocationsEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkSampleLocationsInfoEXT)
ffi.cdef([[void  vkGetPhysicalDeviceMultisamplePropertiesEXT($ , $ , $*);]], mod.VkPhysicalDevice, mod.VkSampleCountFlagBits, mod.VkMultisamplePropertiesEXT)
mod.VkBlendOverlapEXT = ffi.typeof([[enum {
	VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
	VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
	VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
	VK_BLEND_OVERLAP_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ advancedBlendCoherentOperations;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t advancedBlendMaxColorAttachments;
	$ advancedBlendIndependentBlend;
	$ advancedBlendNonPremultipliedSrcColor;
	$ advancedBlendNonPremultipliedDstColor;
	$ advancedBlendCorrelatedOverlap;
	$ advancedBlendAllOperations;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPipelineColorBlendAdvancedStateCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcPremultiplied;
	$ dstPremultiplied;
	$ blendOverlap;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBlendOverlapEXT)
mod.VkPipelineCoverageToColorStateCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCoverageToColorStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ coverageToColorEnable;
	uint32_t coverageToColorLocation;
}]], mod.VkStructureType, mod.VkPipelineCoverageToColorStateCreateFlagsNV, mod.VkBool32)
mod.VkCoverageModulationModeNV = ffi.typeof([[enum {
	VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
	VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
	VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
	VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
	VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPipelineCoverageModulationStateCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCoverageModulationStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ coverageModulationMode;
	$ coverageModulationTableEnable;
	uint32_t coverageModulationTableCount;
	const float* pCoverageModulationTable;
}]], mod.VkStructureType, mod.VkPipelineCoverageModulationStateCreateFlagsNV, mod.VkCoverageModulationModeNV, mod.VkBool32)
mod.VkAttachmentSampleCountInfoNV = ffi.typeof([[$ ]], mod.VkAttachmentSampleCountInfoAMD)
mod.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t shaderSMCount;
	uint32_t shaderWarpsPerSM;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderSMBuiltins;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDrmFormatModifierPropertiesEXT = ffi.typeof([[struct {
	uint64_t drmFormatModifier;
	uint32_t drmFormatModifierPlaneCount;
	$ drmFormatModifierTilingFeatures;
}]], mod.VkFormatFeatureFlags)
mod.VkDrmFormatModifierPropertiesListEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t drmFormatModifierCount;
	$* pDrmFormatModifierProperties;
}]], mod.VkStructureType, mod.VkDrmFormatModifierPropertiesEXT)
mod.VkPhysicalDeviceImageDrmFormatModifierInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t drmFormatModifier;
	$ sharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
}]], mod.VkStructureType, mod.VkSharingMode)
mod.VkImageDrmFormatModifierListCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t drmFormatModifierCount;
	const uint64_t* pDrmFormatModifiers;
}]], mod.VkStructureType)
mod.VkImageDrmFormatModifierExplicitCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t drmFormatModifier;
	uint32_t drmFormatModifierPlaneCount;
	const $* pPlaneLayouts;
}]], mod.VkStructureType, mod.VkSubresourceLayout)
mod.VkImageDrmFormatModifierPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint64_t drmFormatModifier;
}]], mod.VkStructureType)
mod.VkDrmFormatModifierProperties2EXT = ffi.typeof([[struct {
	uint64_t drmFormatModifier;
	uint32_t drmFormatModifierPlaneCount;
	$ drmFormatModifierTilingFeatures;
}]], mod.VkFormatFeatureFlags2)
mod.VkDrmFormatModifierPropertiesList2EXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t drmFormatModifierCount;
	$* pDrmFormatModifierProperties;
}]], mod.VkStructureType, mod.VkDrmFormatModifierProperties2EXT)
mod.PFN_vkGetImageDrmFormatModifierPropertiesEXT = ffi.typeof([[$ (*)($ , $ , $*)]], mod.VkResult, mod.VkDevice, mod.VkImage, mod.VkImageDrmFormatModifierPropertiesEXT)
ffi.cdef([[$  vkGetImageDrmFormatModifierPropertiesEXT($ , $ , $*);]], mod.VkResult, mod.VkDevice, mod.VkImage, mod.VkImageDrmFormatModifierPropertiesEXT)
mod.VkValidationCacheEXT = ffi.typeof([[void*]])
mod.VkValidationCacheHeaderVersionEXT = ffi.typeof([[enum {
	VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
	VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkValidationCacheCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkValidationCacheCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	size_t initialDataSize;
	const void* pInitialData;
}]], mod.VkStructureType, mod.VkValidationCacheCreateFlagsEXT)
mod.VkShaderModuleValidationCacheCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ validationCache;
}]], mod.VkStructureType, mod.VkValidationCacheEXT)
mod.PFN_vkCreateValidationCacheEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkValidationCacheCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkValidationCacheEXT)
mod.PFN_vkDestroyValidationCacheEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkValidationCacheEXT, mod.VkAllocationCallbacks)
mod.PFN_vkMergeValidationCachesEXT = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkValidationCacheEXT, mod.VkValidationCacheEXT)
mod.PFN_vkGetValidationCacheDataEXT = ffi.typeof([[$ (*)($ , $ , size_t*, void*)]], mod.VkResult, mod.VkDevice, mod.VkValidationCacheEXT)
ffi.cdef([[$  vkCreateValidationCacheEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkValidationCacheCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkValidationCacheEXT)
ffi.cdef([[void  vkDestroyValidationCacheEXT($ , $ , const $*);]], mod.VkDevice, mod.VkValidationCacheEXT, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkMergeValidationCachesEXT($ , $ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkValidationCacheEXT, mod.VkValidationCacheEXT)
ffi.cdef([[$  vkGetValidationCacheDataEXT($ , $ , size_t*, void*);]], mod.VkResult, mod.VkDevice, mod.VkValidationCacheEXT)
mod.VkDescriptorBindingFlagBitsEXT = ffi.typeof([[$ ]], mod.VkDescriptorBindingFlagBits)
mod.VkDescriptorBindingFlagsEXT = ffi.typeof([[$ ]], mod.VkDescriptorBindingFlags)
mod.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = ffi.typeof([[$ ]], mod.VkDescriptorSetLayoutBindingFlagsCreateInfo)
mod.VkPhysicalDeviceDescriptorIndexingFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDescriptorIndexingFeatures)
mod.VkPhysicalDeviceDescriptorIndexingPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDescriptorIndexingProperties)
mod.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = ffi.typeof([[$ ]], mod.VkDescriptorSetVariableDescriptorCountAllocateInfo)
mod.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = ffi.typeof([[$ ]], mod.VkDescriptorSetVariableDescriptorCountLayoutSupport)
mod.VkShadingRatePaletteEntryNV = ffi.typeof([[enum {
	VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
	VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
	VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
	VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
	VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
	VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkCoarseSampleOrderTypeNV = ffi.typeof([[enum {
	VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
	VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
	VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
	VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
	VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkShadingRatePaletteNV = ffi.typeof([[struct {
	uint32_t shadingRatePaletteEntryCount;
	const $* pShadingRatePaletteEntries;
}]], mod.VkShadingRatePaletteEntryNV)
mod.VkPipelineViewportShadingRateImageStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ shadingRateImageEnable;
	uint32_t viewportCount;
	const $* pShadingRatePalettes;
}]], mod.VkStructureType, mod.VkBool32, mod.VkShadingRatePaletteNV)
mod.VkPhysicalDeviceShadingRateImageFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shadingRateImage;
	$ shadingRateCoarseSampleOrder;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceShadingRateImagePropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shadingRateTexelSize;
	uint32_t shadingRatePaletteSize;
	uint32_t shadingRateMaxCoarseSamples;
}]], mod.VkStructureType, mod.VkExtent2D)
mod.VkCoarseSampleLocationNV = ffi.typeof([[struct {
	uint32_t pixelX;
	uint32_t pixelY;
	uint32_t sample;
}]])
mod.VkCoarseSampleOrderCustomNV = ffi.typeof([[struct {
	$ shadingRate;
	uint32_t sampleCount;
	uint32_t sampleLocationCount;
	const $* pSampleLocations;
}]], mod.VkShadingRatePaletteEntryNV, mod.VkCoarseSampleLocationNV)
mod.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ sampleOrderType;
	uint32_t customSampleOrderCount;
	const $* pCustomSampleOrders;
}]], mod.VkStructureType, mod.VkCoarseSampleOrderTypeNV, mod.VkCoarseSampleOrderCustomNV)
mod.PFN_vkCmdBindShadingRateImageNV = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkImageView, mod.VkImageLayout)
mod.PFN_vkCmdSetViewportShadingRatePaletteNV = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkShadingRatePaletteNV)
mod.PFN_vkCmdSetCoarseSampleOrderNV = ffi.typeof([[void (*)($ , $ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkCoarseSampleOrderTypeNV, mod.VkCoarseSampleOrderCustomNV)
ffi.cdef([[void  vkCmdBindShadingRateImageNV($ , $ , $ );]], mod.VkCommandBuffer, mod.VkImageView, mod.VkImageLayout)
ffi.cdef([[void  vkCmdSetViewportShadingRatePaletteNV($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkShadingRatePaletteNV)
ffi.cdef([[void  vkCmdSetCoarseSampleOrderNV($ , $ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkCoarseSampleOrderTypeNV, mod.VkCoarseSampleOrderCustomNV)
mod.VkAccelerationStructureNV = ffi.typeof([[void*]])
mod.VkRayTracingShaderGroupTypeKHR = ffi.typeof([[enum {
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkRayTracingShaderGroupTypeNV = ffi.typeof([[$ ]], mod.VkRayTracingShaderGroupTypeKHR)
mod.VkGeometryTypeKHR = ffi.typeof([[enum {
	VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
	VK_GEOMETRY_TYPE_AABBS_KHR = 1,
	VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
	VK_GEOMETRY_TYPE_SPHERES_NV = 1000429004,
	VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV = 1000429005,
	VK_GEOMETRY_TYPE_TRIANGLES_NV = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
	VK_GEOMETRY_TYPE_AABBS_NV = VK_GEOMETRY_TYPE_AABBS_KHR,
	VK_GEOMETRY_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkGeometryTypeNV = ffi.typeof([[$ ]], mod.VkGeometryTypeKHR)
mod.VkAccelerationStructureTypeKHR = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
	VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
	VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureTypeNV = ffi.typeof([[$ ]], mod.VkAccelerationStructureTypeKHR)
mod.VkCopyAccelerationStructureModeKHR = ffi.typeof([[enum {
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkCopyAccelerationStructureModeNV = ffi.typeof([[$ ]], mod.VkCopyAccelerationStructureModeKHR)
mod.VkAccelerationStructureMemoryRequirementsTypeNV = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkGeometryFlagBitsKHR = ffi.typeof([[enum {
	VK_GEOMETRY_OPAQUE_BIT_KHR = 0x00000001,
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x00000002,
	VK_GEOMETRY_OPAQUE_BIT_NV = VK_GEOMETRY_OPAQUE_BIT_KHR,
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
	VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkGeometryFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkGeometryFlagsNV = ffi.typeof([[$ ]], mod.VkGeometryFlagsKHR)
mod.VkGeometryFlagBitsNV = ffi.typeof([[$ ]], mod.VkGeometryFlagBitsKHR)
mod.VkGeometryInstanceFlagBitsKHR = ffi.typeof([[enum {
	VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x00000001,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x00000002,
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x00000004,
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x00000008,
	VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT = 0x00000010,
	VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT = 0x00000020,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
	VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
	VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT = VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT,
	VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT = VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT,
	VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkGeometryInstanceFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkGeometryInstanceFlagsNV = ffi.typeof([[$ ]], mod.VkGeometryInstanceFlagsKHR)
mod.VkGeometryInstanceFlagBitsNV = ffi.typeof([[$ ]], mod.VkGeometryInstanceFlagBitsKHR)
mod.VkBuildAccelerationStructureFlagBitsKHR = ffi.typeof([[enum {
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x00000001,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x00000002,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x00000004,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x00000008,
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x00000010,
	VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x00000020,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT = 0x00000040,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT = 0x00000080,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT = 0x00000100,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR = 0x00000800,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV = 0x00001000,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR,
	VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkBuildAccelerationStructureFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkBuildAccelerationStructureFlagsNV = ffi.typeof([[$ ]], mod.VkBuildAccelerationStructureFlagsKHR)
mod.VkBuildAccelerationStructureFlagBitsNV = ffi.typeof([[$ ]], mod.VkBuildAccelerationStructureFlagBitsKHR)
mod.VkRayTracingShaderGroupCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	uint32_t generalShader;
	uint32_t closestHitShader;
	uint32_t anyHitShader;
	uint32_t intersectionShader;
}]], mod.VkStructureType, mod.VkRayTracingShaderGroupTypeKHR)
mod.VkRayTracingPipelineCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t stageCount;
	const $* pStages;
	uint32_t groupCount;
	const $* pGroups;
	uint32_t maxRecursionDepth;
	$ layout;
	$ basePipelineHandle;
	int32_t basePipelineIndex;
}]], mod.VkStructureType, mod.VkPipelineCreateFlags, mod.VkPipelineShaderStageCreateInfo, mod.VkRayTracingShaderGroupCreateInfoNV, mod.VkPipelineLayout, mod.VkPipeline)
mod.VkGeometryTrianglesNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ vertexData;
	$ vertexOffset;
	uint32_t vertexCount;
	$ vertexStride;
	$ vertexFormat;
	$ indexData;
	$ indexOffset;
	uint32_t indexCount;
	$ indexType;
	$ transformData;
	$ transformOffset;
}]], mod.VkStructureType, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkFormat, mod.VkBuffer, mod.VkDeviceSize, mod.VkIndexType, mod.VkBuffer, mod.VkDeviceSize)
mod.VkGeometryAABBNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ aabbData;
	uint32_t numAABBs;
	uint32_t stride;
	$ offset;
}]], mod.VkStructureType, mod.VkBuffer, mod.VkDeviceSize)
mod.VkGeometryDataNV = ffi.typeof([[struct {
	$ triangles;
	$ aabbs;
}]], mod.VkGeometryTrianglesNV, mod.VkGeometryAABBNV)
mod.VkGeometryNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ geometryType;
	$ geometry;
	$ flags;
}]], mod.VkStructureType, mod.VkGeometryTypeKHR, mod.VkGeometryDataNV, mod.VkGeometryFlagsKHR)
mod.VkAccelerationStructureInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ flags;
	uint32_t instanceCount;
	uint32_t geometryCount;
	const $* pGeometries;
}]], mod.VkStructureType, mod.VkAccelerationStructureTypeNV, mod.VkBuildAccelerationStructureFlagsNV, mod.VkGeometryNV)
mod.VkAccelerationStructureCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ compactedSize;
	$ info;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkAccelerationStructureInfoNV)
mod.VkBindAccelerationStructureMemoryInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ accelerationStructure;
	$ memory;
	$ memoryOffset;
	uint32_t deviceIndexCount;
	const uint32_t* pDeviceIndices;
}]], mod.VkStructureType, mod.VkAccelerationStructureNV, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.VkWriteDescriptorSetAccelerationStructureNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t accelerationStructureCount;
	const $* pAccelerationStructures;
}]], mod.VkStructureType, mod.VkAccelerationStructureNV)
mod.VkAccelerationStructureMemoryRequirementsInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ accelerationStructure;
}]], mod.VkStructureType, mod.VkAccelerationStructureMemoryRequirementsTypeNV, mod.VkAccelerationStructureNV)
mod.VkPhysicalDeviceRayTracingPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t shaderGroupHandleSize;
	uint32_t maxRecursionDepth;
	uint32_t maxShaderGroupStride;
	uint32_t shaderGroupBaseAlignment;
	uint64_t maxGeometryCount;
	uint64_t maxInstanceCount;
	uint64_t maxTriangleCount;
	uint32_t maxDescriptorSetAccelerationStructures;
}]], mod.VkStructureType)
mod.VkTransformMatrixKHR = ffi.typeof([[struct {
	float matrix[4][3];
}]])
mod.VkTransformMatrixNV = ffi.typeof([[$ ]], mod.VkTransformMatrixKHR)
mod.VkAabbPositionsKHR = ffi.typeof([[struct {
	float minX;
	float minY;
	float minZ;
	float maxX;
	float maxY;
	float maxZ;
}]])
mod.VkAabbPositionsNV = ffi.typeof([[$ ]], mod.VkAabbPositionsKHR)
mod.VkAccelerationStructureInstanceKHR = ffi.typeof([[struct {
	$ transform;
	uint32_t instanceCustomIndex;
	uint32_t mask;
	uint32_t instanceShaderBindingTableRecordOffset;
	$ flags;
	uint64_t accelerationStructureReference;
}]], mod.VkTransformMatrixKHR, mod.VkGeometryInstanceFlagsKHR)
mod.VkAccelerationStructureInstanceNV = ffi.typeof([[$ ]], mod.VkAccelerationStructureInstanceKHR)
mod.PFN_vkCreateAccelerationStructureNV = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureCreateInfoNV, mod.VkAllocationCallbacks, mod.VkAccelerationStructureNV)
mod.PFN_vkDestroyAccelerationStructureNV = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkAccelerationStructureNV, mod.VkAllocationCallbacks)
mod.PFN_vkGetAccelerationStructureMemoryRequirementsNV = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkAccelerationStructureMemoryRequirementsInfoNV, mod.VkMemoryRequirements2KHR)
mod.PFN_vkBindAccelerationStructureMemoryNV = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkBindAccelerationStructureMemoryInfoNV)
mod.PFN_vkCmdBuildAccelerationStructureNV = ffi.typeof([[void (*)($ , const $*, $ , $ , $ , $ , $ , $ , $ )]], mod.VkCommandBuffer, mod.VkAccelerationStructureInfoNV, mod.VkBuffer, mod.VkDeviceSize, mod.VkBool32, mod.VkAccelerationStructureNV, mod.VkAccelerationStructureNV, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdCopyAccelerationStructureNV = ffi.typeof([[void (*)($ , $ , $ , $ )]], mod.VkCommandBuffer, mod.VkAccelerationStructureNV, mod.VkAccelerationStructureNV, mod.VkCopyAccelerationStructureModeKHR)
mod.PFN_vkCmdTraceRaysNV = ffi.typeof([[void (*)($ , $ , $ , $ , $ , $ , $ , $ , $ , $ , $ , $ , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
mod.PFN_vkCreateRayTracingPipelinesNV = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache, mod.VkRayTracingPipelineCreateInfoNV, mod.VkAllocationCallbacks, mod.VkPipeline)
mod.PFN_vkGetRayTracingShaderGroupHandlesKHR = ffi.typeof([[$ (*)($ , $ , uint32_t , uint32_t , size_t , void*)]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
mod.PFN_vkGetRayTracingShaderGroupHandlesNV = ffi.typeof([[$ (*)($ , $ , uint32_t , uint32_t , size_t , void*)]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
mod.PFN_vkGetAccelerationStructureHandleNV = ffi.typeof([[$ (*)($ , $ , size_t , void*)]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureNV)
mod.PFN_vkCmdWriteAccelerationStructuresPropertiesNV = ffi.typeof([[void (*)($ , uint32_t , const $*, $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkAccelerationStructureNV, mod.VkQueryType, mod.VkQueryPool)
mod.PFN_vkCompileDeferredNV = ffi.typeof([[$ (*)($ , $ , uint32_t )]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
ffi.cdef([[$  vkCreateAccelerationStructureNV($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureCreateInfoNV, mod.VkAllocationCallbacks, mod.VkAccelerationStructureNV)
ffi.cdef([[void  vkDestroyAccelerationStructureNV($ , $ , const $*);]], mod.VkDevice, mod.VkAccelerationStructureNV, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkGetAccelerationStructureMemoryRequirementsNV($ , const $*, $*);]], mod.VkDevice, mod.VkAccelerationStructureMemoryRequirementsInfoNV, mod.VkMemoryRequirements2KHR)
ffi.cdef([[$  vkBindAccelerationStructureMemoryNV($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkBindAccelerationStructureMemoryInfoNV)
ffi.cdef([[void  vkCmdBuildAccelerationStructureNV($ , const $*, $ , $ , $ , $ , $ , $ , $ );]], mod.VkCommandBuffer, mod.VkAccelerationStructureInfoNV, mod.VkBuffer, mod.VkDeviceSize, mod.VkBool32, mod.VkAccelerationStructureNV, mod.VkAccelerationStructureNV, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdCopyAccelerationStructureNV($ , $ , $ , $ );]], mod.VkCommandBuffer, mod.VkAccelerationStructureNV, mod.VkAccelerationStructureNV, mod.VkCopyAccelerationStructureModeKHR)
ffi.cdef([[void  vkCmdTraceRaysNV($ , $ , $ , $ , $ , $ , $ , $ , $ , $ , $ , $ , uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize)
ffi.cdef([[$  vkCreateRayTracingPipelinesNV($ , $ , uint32_t , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineCache, mod.VkRayTracingPipelineCreateInfoNV, mod.VkAllocationCallbacks, mod.VkPipeline)
ffi.cdef([[$  vkGetRayTracingShaderGroupHandlesKHR($ , $ , uint32_t , uint32_t , size_t , void*);]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
ffi.cdef([[$  vkGetRayTracingShaderGroupHandlesNV($ , $ , uint32_t , uint32_t , size_t , void*);]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
ffi.cdef([[$  vkGetAccelerationStructureHandleNV($ , $ , size_t , void*);]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureNV)
ffi.cdef([[void  vkCmdWriteAccelerationStructuresPropertiesNV($ , uint32_t , const $*, $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkAccelerationStructureNV, mod.VkQueryType, mod.VkQueryPool)
ffi.cdef([[$  vkCompileDeferredNV($ , $ , uint32_t );]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
mod.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ representativeFragmentTest;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineRepresentativeFragmentTestStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ representativeFragmentTestEnable;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceImageViewImageFormatInfoEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageViewType;
}]], mod.VkStructureType, mod.VkImageViewType)
mod.VkFilterCubicImageViewImageFormatPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ filterCubic;
	$ filterCubicMinmax;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkQueueGlobalPriorityEXT = ffi.typeof([[$ ]], mod.VkQueueGlobalPriority)
mod.VkDeviceQueueGlobalPriorityCreateInfoEXT = ffi.typeof([[$ ]], mod.VkDeviceQueueGlobalPriorityCreateInfo)
mod.VkImportMemoryHostPointerInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleType;
	void* pHostPointer;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkMemoryHostPointerPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t memoryTypeBits;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceExternalMemoryHostPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ minImportedHostPointerAlignment;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.PFN_vkGetMemoryHostPointerPropertiesEXT = ffi.typeof([[$ (*)($ , $ , const void*, $*)]], mod.VkResult, mod.VkDevice, mod.VkExternalMemoryHandleTypeFlagBits, mod.VkMemoryHostPointerPropertiesEXT)
ffi.cdef([[$  vkGetMemoryHostPointerPropertiesEXT($ , $ , const void*, $*);]], mod.VkResult, mod.VkDevice, mod.VkExternalMemoryHandleTypeFlagBits, mod.VkMemoryHostPointerPropertiesEXT)
mod.PFN_vkCmdWriteBufferMarkerAMD = ffi.typeof([[void (*)($ , $ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkPipelineStageFlagBits, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdWriteBufferMarker2AMD = ffi.typeof([[void (*)($ , $ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkPipelineStageFlags2, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdWriteBufferMarkerAMD($ , $ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkPipelineStageFlagBits, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdWriteBufferMarker2AMD($ , $ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkPipelineStageFlags2, mod.VkBuffer, mod.VkDeviceSize)
mod.VkPipelineCompilerControlFlagBitsAMD = ffi.typeof([[enum {
	VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkPipelineCompilerControlFlagsAMD = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPipelineCompilerControlCreateInfoAMD = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ compilerControlFlags;
}]], mod.VkStructureType, mod.VkPipelineCompilerControlFlagsAMD)
mod.VkTimeDomainEXT = ffi.typeof([[$ ]], mod.VkTimeDomainKHR)
mod.VkCalibratedTimestampInfoEXT = ffi.typeof([[$ ]], mod.VkCalibratedTimestampInfoKHR)
mod.PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkTimeDomainKHR)
mod.PFN_vkGetCalibratedTimestampsEXT = ffi.typeof([[$ (*)($ , uint32_t , const $*, uint64_t*, uint64_t*)]], mod.VkResult, mod.VkDevice, mod.VkCalibratedTimestampInfoKHR)
ffi.cdef([[$  vkGetPhysicalDeviceCalibrateableTimeDomainsEXT($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkTimeDomainKHR)
ffi.cdef([[$  vkGetCalibratedTimestampsEXT($ , uint32_t , const $*, uint64_t*, uint64_t*);]], mod.VkResult, mod.VkDevice, mod.VkCalibratedTimestampInfoKHR)
mod.VkPhysicalDeviceShaderCorePropertiesAMD = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t shaderEngineCount;
	uint32_t shaderArraysPerEngineCount;
	uint32_t computeUnitsPerShaderArray;
	uint32_t simdPerComputeUnit;
	uint32_t wavefrontsPerSimd;
	uint32_t wavefrontSize;
	uint32_t sgprsPerSimd;
	uint32_t minSgprAllocation;
	uint32_t maxSgprAllocation;
	uint32_t sgprAllocationGranularity;
	uint32_t vgprsPerSimd;
	uint32_t minVgprAllocation;
	uint32_t maxVgprAllocation;
	uint32_t vgprAllocationGranularity;
}]], mod.VkStructureType)
mod.VkMemoryOverallocationBehaviorAMD = ffi.typeof([[enum {
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkDeviceMemoryOverallocationCreateInfoAMD = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ overallocationBehavior;
}]], mod.VkStructureType, mod.VkMemoryOverallocationBehaviorAMD)
mod.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxVertexAttribDivisor;
}]], mod.VkStructureType)
mod.VkVertexInputBindingDivisorDescriptionEXT = ffi.typeof([[$ ]], mod.VkVertexInputBindingDivisorDescription)
mod.VkPipelineVertexInputDivisorStateCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineVertexInputDivisorStateCreateInfo)
mod.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceVertexAttributeDivisorFeatures)
mod.VkPipelineCreationFeedbackFlagBitsEXT = ffi.typeof([[$ ]], mod.VkPipelineCreationFeedbackFlagBits)
mod.VkPipelineCreationFeedbackFlagsEXT = ffi.typeof([[$ ]], mod.VkPipelineCreationFeedbackFlags)
mod.VkPipelineCreationFeedbackCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineCreationFeedbackCreateInfo)
mod.VkPipelineCreationFeedbackEXT = ffi.typeof([[$ ]], mod.VkPipelineCreationFeedback)
mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = ffi.typeof([[$ ]], mod.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR)
mod.VkPhysicalDeviceMeshShaderFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ taskShader;
	$ meshShader;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceMeshShaderPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxDrawMeshTasksCount;
	uint32_t maxTaskWorkGroupInvocations;
	uint32_t maxTaskWorkGroupSize[3];
	uint32_t maxTaskTotalMemorySize;
	uint32_t maxTaskOutputCount;
	uint32_t maxMeshWorkGroupInvocations;
	uint32_t maxMeshWorkGroupSize[3];
	uint32_t maxMeshTotalMemorySize;
	uint32_t maxMeshOutputVertices;
	uint32_t maxMeshOutputPrimitives;
	uint32_t maxMeshMultiviewViewCount;
	uint32_t meshOutputPerVertexGranularity;
	uint32_t meshOutputPerPrimitiveGranularity;
}]], mod.VkStructureType)
mod.VkDrawMeshTasksIndirectCommandNV = ffi.typeof([[struct {
	uint32_t taskCount;
	uint32_t firstTask;
}]])
mod.PFN_vkCmdDrawMeshTasksNV = ffi.typeof([[void (*)($ , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawMeshTasksIndirectNV = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdDrawMeshTasksIndirectCountNV = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawMeshTasksNV($ , uint32_t , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdDrawMeshTasksIndirectNV($ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawMeshTasksIndirectCountNV($ , $ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR)
mod.VkPhysicalDeviceShaderImageFootprintFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageFootprint;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineViewportExclusiveScissorStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t exclusiveScissorCount;
	const $* pExclusiveScissors;
}]], mod.VkStructureType, mod.VkRect2D)
mod.VkPhysicalDeviceExclusiveScissorFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ exclusiveScissor;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkCmdSetExclusiveScissorEnableNV = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetExclusiveScissorNV = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkRect2D)
ffi.cdef([[void  vkCmdSetExclusiveScissorEnableNV($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetExclusiveScissorNV($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkRect2D)
mod.VkQueueFamilyCheckpointPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ checkpointExecutionStageMask;
}]], mod.VkStructureType, mod.VkPipelineStageFlags)
mod.VkCheckpointDataNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ stage;
	void* pCheckpointMarker;
}]], mod.VkStructureType, mod.VkPipelineStageFlagBits)
mod.VkQueueFamilyCheckpointProperties2NV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ checkpointExecutionStageMask;
}]], mod.VkStructureType, mod.VkPipelineStageFlags2)
mod.VkCheckpointData2NV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ stage;
	void* pCheckpointMarker;
}]], mod.VkStructureType, mod.VkPipelineStageFlags2)
mod.PFN_vkCmdSetCheckpointNV = ffi.typeof([[void (*)($ , const void*)]], mod.VkCommandBuffer)
mod.PFN_vkGetQueueCheckpointDataNV = ffi.typeof([[void (*)($ , uint32_t*, $*)]], mod.VkQueue, mod.VkCheckpointDataNV)
mod.PFN_vkGetQueueCheckpointData2NV = ffi.typeof([[void (*)($ , uint32_t*, $*)]], mod.VkQueue, mod.VkCheckpointData2NV)
ffi.cdef([[void  vkCmdSetCheckpointNV($ , const void*);]], mod.VkCommandBuffer)
ffi.cdef([[void  vkGetQueueCheckpointDataNV($ , uint32_t*, $*);]], mod.VkQueue, mod.VkCheckpointDataNV)
ffi.cdef([[void  vkGetQueueCheckpointData2NV($ , uint32_t*, $*);]], mod.VkQueue, mod.VkCheckpointData2NV)
mod.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderIntegerFunctions2;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPerformanceConfigurationINTEL = ffi.typeof([[void*]])
mod.VkPerformanceConfigurationTypeINTEL = ffi.typeof([[enum {
	VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
	VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkQueryPoolSamplingModeINTEL = ffi.typeof([[enum {
	VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
	VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkPerformanceOverrideTypeINTEL = ffi.typeof([[enum {
	VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
	VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
	VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkPerformanceParameterTypeINTEL = ffi.typeof([[enum {
	VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
	VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
	VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkPerformanceValueTypeINTEL = ffi.typeof([[enum {
	VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
	VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
	VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
	VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
	VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
	VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF,
}]])
mod.VkPerformanceValueDataINTEL = ffi.typeof([[union {
	uint32_t value32;
	uint64_t value64;
	float valueFloat;
	$ valueBool;
	const char* valueString;
}]], mod.VkBool32)
mod.VkPerformanceValueINTEL = ffi.typeof([[struct {
	$ type;
	$ data;
}]], mod.VkPerformanceValueTypeINTEL, mod.VkPerformanceValueDataINTEL)
mod.VkInitializePerformanceApiInfoINTEL = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	void* pUserData;
}]], mod.VkStructureType)
mod.VkQueryPoolPerformanceQueryCreateInfoINTEL = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ performanceCountersSampling;
}]], mod.VkStructureType, mod.VkQueryPoolSamplingModeINTEL)
mod.VkQueryPoolCreateInfoINTEL = ffi.typeof([[$ ]], mod.VkQueryPoolPerformanceQueryCreateInfoINTEL)
mod.VkPerformanceMarkerInfoINTEL = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t marker;
}]], mod.VkStructureType)
mod.VkPerformanceStreamMarkerInfoINTEL = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t marker;
}]], mod.VkStructureType)
mod.VkPerformanceOverrideInfoINTEL = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ enable;
	uint64_t parameter;
}]], mod.VkStructureType, mod.VkPerformanceOverrideTypeINTEL, mod.VkBool32)
mod.VkPerformanceConfigurationAcquireInfoINTEL = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
}]], mod.VkStructureType, mod.VkPerformanceConfigurationTypeINTEL)
mod.PFN_vkInitializePerformanceApiINTEL = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkInitializePerformanceApiInfoINTEL)
mod.PFN_vkUninitializePerformanceApiINTEL = ffi.typeof([[void (*)($ )]], mod.VkDevice)
mod.PFN_vkCmdSetPerformanceMarkerINTEL = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkCommandBuffer, mod.VkPerformanceMarkerInfoINTEL)
mod.PFN_vkCmdSetPerformanceStreamMarkerINTEL = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkCommandBuffer, mod.VkPerformanceStreamMarkerInfoINTEL)
mod.PFN_vkCmdSetPerformanceOverrideINTEL = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkCommandBuffer, mod.VkPerformanceOverrideInfoINTEL)
mod.PFN_vkAcquirePerformanceConfigurationINTEL = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPerformanceConfigurationAcquireInfoINTEL, mod.VkPerformanceConfigurationINTEL)
mod.PFN_vkReleasePerformanceConfigurationINTEL = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkDevice, mod.VkPerformanceConfigurationINTEL)
mod.PFN_vkQueueSetPerformanceConfigurationINTEL = ffi.typeof([[$ (*)($ , $ )]], mod.VkResult, mod.VkQueue, mod.VkPerformanceConfigurationINTEL)
mod.PFN_vkGetPerformanceParameterINTEL = ffi.typeof([[$ (*)($ , $ , $*)]], mod.VkResult, mod.VkDevice, mod.VkPerformanceParameterTypeINTEL, mod.VkPerformanceValueINTEL)
ffi.cdef([[$  vkInitializePerformanceApiINTEL($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkInitializePerformanceApiInfoINTEL)
ffi.cdef([[void  vkUninitializePerformanceApiINTEL($ );]], mod.VkDevice)
ffi.cdef([[$  vkCmdSetPerformanceMarkerINTEL($ , const $*);]], mod.VkResult, mod.VkCommandBuffer, mod.VkPerformanceMarkerInfoINTEL)
ffi.cdef([[$  vkCmdSetPerformanceStreamMarkerINTEL($ , const $*);]], mod.VkResult, mod.VkCommandBuffer, mod.VkPerformanceStreamMarkerInfoINTEL)
ffi.cdef([[$  vkCmdSetPerformanceOverrideINTEL($ , const $*);]], mod.VkResult, mod.VkCommandBuffer, mod.VkPerformanceOverrideInfoINTEL)
ffi.cdef([[$  vkAcquirePerformanceConfigurationINTEL($ , const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPerformanceConfigurationAcquireInfoINTEL, mod.VkPerformanceConfigurationINTEL)
ffi.cdef([[$  vkReleasePerformanceConfigurationINTEL($ , $ );]], mod.VkResult, mod.VkDevice, mod.VkPerformanceConfigurationINTEL)
ffi.cdef([[$  vkQueueSetPerformanceConfigurationINTEL($ , $ );]], mod.VkResult, mod.VkQueue, mod.VkPerformanceConfigurationINTEL)
ffi.cdef([[$  vkGetPerformanceParameterINTEL($ , $ , $*);]], mod.VkResult, mod.VkDevice, mod.VkPerformanceParameterTypeINTEL, mod.VkPerformanceValueINTEL)
mod.VkPhysicalDevicePCIBusInfoPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t pciDomain;
	uint32_t pciBus;
	uint32_t pciDevice;
	uint32_t pciFunction;
}]], mod.VkStructureType)
mod.VkDisplayNativeHdrSurfaceCapabilitiesAMD = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ localDimmingSupport;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSwapchainDisplayNativeHdrCreateInfoAMD = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ localDimmingEnable;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkSetLocalDimmingAMD = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkBool32)
ffi.cdef([[void  vkSetLocalDimmingAMD($ , $ , $ );]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkBool32)
mod.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityMap;
	$ fragmentDensityMapDynamic;
	$ fragmentDensityMapNonSubsampledImages;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceFragmentDensityMapPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ minFragmentDensityTexelSize;
	$ maxFragmentDensityTexelSize;
	$ fragmentDensityInvocations;
}]], mod.VkStructureType, mod.VkExtent2D, mod.VkExtent2D, mod.VkBool32)
mod.VkRenderPassFragmentDensityMapCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ fragmentDensityMapAttachment;
}]], mod.VkStructureType, mod.VkAttachmentReference)
mod.VkRenderingFragmentDensityMapAttachmentInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ imageView;
	$ imageLayout;
}]], mod.VkStructureType, mod.VkImageView, mod.VkImageLayout)
mod.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceScalarBlockLayoutFeatures)
mod.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSubgroupSizeControlFeatures)
mod.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSubgroupSizeControlProperties)
mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo)
mod.VkShaderCorePropertiesFlagBitsAMD = ffi.typeof([[enum {
	VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkShaderCorePropertiesFlagsAMD = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceShaderCoreProperties2AMD = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderCoreFeatures;
	uint32_t activeComputeUnitCount;
}]], mod.VkStructureType, mod.VkShaderCorePropertiesFlagsAMD)
mod.VkPhysicalDeviceCoherentMemoryFeaturesAMD = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ deviceCoherentMemory;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderImageInt64Atomics;
	$ sparseImageInt64Atomics;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceMemoryBudgetPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ heapBudget[16U];
	$ heapUsage[16U];
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkPhysicalDeviceMemoryPriorityFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ memoryPriority;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkMemoryPriorityAllocateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	float priority;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ dedicatedAllocationImageAliasing;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ bufferDeviceAddress;
	$ bufferDeviceAddressCaptureReplay;
	$ bufferDeviceAddressMultiDevice;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceBufferAddressFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
mod.VkBufferDeviceAddressInfoEXT = ffi.typeof([[$ ]], mod.VkBufferDeviceAddressInfo)
mod.VkBufferDeviceAddressCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ deviceAddress;
}]], mod.VkStructureType, mod.VkDeviceAddress)
mod.PFN_vkGetBufferDeviceAddressEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkDeviceAddress, mod.VkDevice, mod.VkBufferDeviceAddressInfo)
ffi.cdef([[$  vkGetBufferDeviceAddressEXT($ , const $*);]], mod.VkDeviceAddress, mod.VkDevice, mod.VkBufferDeviceAddressInfo)
mod.VkToolPurposeFlagBitsEXT = ffi.typeof([[$ ]], mod.VkToolPurposeFlagBits)
mod.VkToolPurposeFlagsEXT = ffi.typeof([[$ ]], mod.VkToolPurposeFlags)
mod.VkPhysicalDeviceToolPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceToolProperties)
mod.PFN_vkGetPhysicalDeviceToolPropertiesEXT = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceToolProperties)
ffi.cdef([[$  vkGetPhysicalDeviceToolPropertiesEXT($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkPhysicalDeviceToolProperties)
mod.VkImageStencilUsageCreateInfoEXT = ffi.typeof([[$ ]], mod.VkImageStencilUsageCreateInfo)
mod.VkValidationFeatureEnableEXT = ffi.typeof([[enum {
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
	VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
	VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
	VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
	VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkValidationFeatureDisableEXT = ffi.typeof([[enum {
	VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
	VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
	VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
	VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
	VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
	VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
	VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
	VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
	VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkValidationFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t enabledValidationFeatureCount;
	const $* pEnabledValidationFeatures;
	uint32_t disabledValidationFeatureCount;
	const $* pDisabledValidationFeatures;
}]], mod.VkStructureType, mod.VkValidationFeatureEnableEXT, mod.VkValidationFeatureDisableEXT)
mod.VkComponentTypeNV = ffi.typeof([[$ ]], mod.VkComponentTypeKHR)
mod.VkScopeNV = ffi.typeof([[$ ]], mod.VkScopeKHR)
mod.VkCooperativeMatrixPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t MSize;
	uint32_t NSize;
	uint32_t KSize;
	$ AType;
	$ BType;
	$ CType;
	$ DType;
	$ scope;
}]], mod.VkStructureType, mod.VkComponentTypeNV, mod.VkComponentTypeNV, mod.VkComponentTypeNV, mod.VkComponentTypeNV, mod.VkScopeNV)
mod.VkPhysicalDeviceCooperativeMatrixFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrix;
	$ cooperativeMatrixRobustBufferAccess;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceCooperativeMatrixPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrixSupportedStages;
}]], mod.VkStructureType, mod.VkShaderStageFlags)
mod.PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkCooperativeMatrixPropertiesNV)
ffi.cdef([[$  vkGetPhysicalDeviceCooperativeMatrixPropertiesNV($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkCooperativeMatrixPropertiesNV)
mod.VkCoverageReductionModeNV = ffi.typeof([[enum {
	VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
	VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
	VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPipelineCoverageReductionStateCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceCoverageReductionModeFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ coverageReductionMode;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineCoverageReductionStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ coverageReductionMode;
}]], mod.VkStructureType, mod.VkPipelineCoverageReductionStateCreateFlagsNV, mod.VkCoverageReductionModeNV)
mod.VkFramebufferMixedSamplesCombinationNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ coverageReductionMode;
	$ rasterizationSamples;
	$ depthStencilSamples;
	$ colorSamples;
}]], mod.VkStructureType, mod.VkCoverageReductionModeNV, mod.VkSampleCountFlagBits, mod.VkSampleCountFlags, mod.VkSampleCountFlags)
mod.PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkFramebufferMixedSamplesCombinationNV)
ffi.cdef([[$  vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkFramebufferMixedSamplesCombinationNV)
mod.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ fragmentShaderSampleInterlock;
	$ fragmentShaderPixelInterlock;
	$ fragmentShaderShadingRateInterlock;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ ycbcrImageArrays;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkProvokingVertexModeEXT = ffi.typeof([[enum {
	VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
	VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
	VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceProvokingVertexFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ provokingVertexLast;
	$ transformFeedbackPreservesProvokingVertex;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceProvokingVertexPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ provokingVertexModePerPipeline;
	$ transformFeedbackPreservesTriangleFanProvokingVertex;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ provokingVertexMode;
}]], mod.VkStructureType, mod.VkProvokingVertexModeEXT)
mod.VkHeadlessSurfaceCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkHeadlessSurfaceCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkHeadlessSurfaceCreateFlagsEXT)
mod.PFN_vkCreateHeadlessSurfaceEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkHeadlessSurfaceCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkCreateHeadlessSurfaceEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkHeadlessSurfaceCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.VkLineRasterizationModeEXT = ffi.typeof([[$ ]], mod.VkLineRasterizationMode)
mod.VkPhysicalDeviceLineRasterizationFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceLineRasterizationFeatures)
mod.VkPhysicalDeviceLineRasterizationPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceLineRasterizationProperties)
mod.VkPipelineRasterizationLineStateCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineRasterizationLineStateCreateInfo)
mod.PFN_vkCmdSetLineStippleEXT = ffi.typeof([[void (*)($ , uint32_t , uint16_t )]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetLineStippleEXT($ , uint32_t , uint16_t );]], mod.VkCommandBuffer)
mod.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderBufferFloat32Atomics;
	$ shaderBufferFloat32AtomicAdd;
	$ shaderBufferFloat64Atomics;
	$ shaderBufferFloat64AtomicAdd;
	$ shaderSharedFloat32Atomics;
	$ shaderSharedFloat32AtomicAdd;
	$ shaderSharedFloat64Atomics;
	$ shaderSharedFloat64AtomicAdd;
	$ shaderImageFloat32Atomics;
	$ shaderImageFloat32AtomicAdd;
	$ sparseImageFloat32Atomics;
	$ sparseImageFloat32AtomicAdd;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceHostQueryResetFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceHostQueryResetFeatures)
mod.PFN_vkResetQueryPoolEXT = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkDevice, mod.VkQueryPool)
ffi.cdef([[void  vkResetQueryPoolEXT($ , $ , uint32_t , uint32_t );]], mod.VkDevice, mod.VkQueryPool)
mod.VkPhysicalDeviceIndexTypeUint8FeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceIndexTypeUint8Features)
mod.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ extendedDynamicState;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkCmdSetCullModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCullModeFlags)
mod.PFN_vkCmdSetFrontFaceEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkFrontFace)
mod.PFN_vkCmdSetPrimitiveTopologyEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkPrimitiveTopology)
mod.PFN_vkCmdSetViewportWithCountEXT = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkViewport)
mod.PFN_vkCmdSetScissorWithCountEXT = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkRect2D)
mod.PFN_vkCmdBindVertexBuffers2EXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*, const $*, const $*, const $*)]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.PFN_vkCmdSetDepthTestEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthWriteEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthCompareOpEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCompareOp)
mod.PFN_vkCmdSetDepthBoundsTestEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetStencilTestEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetStencilOpEXT = ffi.typeof([[void (*)($ , $ , $ , $ , $ , $ )]], mod.VkCommandBuffer, mod.VkStencilFaceFlags, mod.VkStencilOp, mod.VkStencilOp, mod.VkStencilOp, mod.VkCompareOp)
ffi.cdef([[void  vkCmdSetCullModeEXT($ , $ );]], mod.VkCommandBuffer, mod.VkCullModeFlags)
ffi.cdef([[void  vkCmdSetFrontFaceEXT($ , $ );]], mod.VkCommandBuffer, mod.VkFrontFace)
ffi.cdef([[void  vkCmdSetPrimitiveTopologyEXT($ , $ );]], mod.VkCommandBuffer, mod.VkPrimitiveTopology)
ffi.cdef([[void  vkCmdSetViewportWithCountEXT($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkViewport)
ffi.cdef([[void  vkCmdSetScissorWithCountEXT($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkRect2D)
ffi.cdef([[void  vkCmdBindVertexBuffers2EXT($ , uint32_t , uint32_t , const $*, const $*, const $*, const $*);]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdSetDepthTestEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthWriteEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthCompareOpEXT($ , $ );]], mod.VkCommandBuffer, mod.VkCompareOp)
ffi.cdef([[void  vkCmdSetDepthBoundsTestEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetStencilTestEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetStencilOpEXT($ , $ , $ , $ , $ , $ );]], mod.VkCommandBuffer, mod.VkStencilFaceFlags, mod.VkStencilOp, mod.VkStencilOp, mod.VkStencilOp, mod.VkCompareOp)
mod.VkHostImageCopyFlagBitsEXT = ffi.typeof([[$ ]], mod.VkHostImageCopyFlagBits)
mod.VkHostImageCopyFlagsEXT = ffi.typeof([[$ ]], mod.VkHostImageCopyFlags)
mod.VkPhysicalDeviceHostImageCopyFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceHostImageCopyFeatures)
mod.VkPhysicalDeviceHostImageCopyPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceHostImageCopyProperties)
mod.VkMemoryToImageCopyEXT = ffi.typeof([[$ ]], mod.VkMemoryToImageCopy)
mod.VkImageToMemoryCopyEXT = ffi.typeof([[$ ]], mod.VkImageToMemoryCopy)
mod.VkCopyMemoryToImageInfoEXT = ffi.typeof([[$ ]], mod.VkCopyMemoryToImageInfo)
mod.VkCopyImageToMemoryInfoEXT = ffi.typeof([[$ ]], mod.VkCopyImageToMemoryInfo)
mod.VkCopyImageToImageInfoEXT = ffi.typeof([[$ ]], mod.VkCopyImageToImageInfo)
mod.VkHostImageLayoutTransitionInfoEXT = ffi.typeof([[$ ]], mod.VkHostImageLayoutTransitionInfo)
mod.VkSubresourceHostMemcpySizeEXT = ffi.typeof([[$ ]], mod.VkSubresourceHostMemcpySize)
mod.VkHostImageCopyDevicePerformanceQueryEXT = ffi.typeof([[$ ]], mod.VkHostImageCopyDevicePerformanceQuery)
mod.VkSubresourceLayout2EXT = ffi.typeof([[$ ]], mod.VkSubresourceLayout2)
mod.VkImageSubresource2EXT = ffi.typeof([[$ ]], mod.VkImageSubresource2)
mod.PFN_vkCopyMemoryToImageEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyMemoryToImageInfo)
mod.PFN_vkCopyImageToMemoryEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToMemoryInfo)
mod.PFN_vkCopyImageToImageEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToImageInfo)
mod.PFN_vkTransitionImageLayoutEXT = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkHostImageLayoutTransitionInfo)
mod.PFN_vkGetImageSubresourceLayout2EXT = ffi.typeof([[void (*)($ , $ , const $*, $*)]], mod.VkDevice, mod.VkImage, mod.VkImageSubresource2, mod.VkSubresourceLayout2)
ffi.cdef([[$  vkCopyMemoryToImageEXT($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkCopyMemoryToImageInfo)
ffi.cdef([[$  vkCopyImageToMemoryEXT($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToMemoryInfo)
ffi.cdef([[$  vkCopyImageToImageEXT($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkCopyImageToImageInfo)
ffi.cdef([[$  vkTransitionImageLayoutEXT($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkHostImageLayoutTransitionInfo)
ffi.cdef([[void  vkGetImageSubresourceLayout2EXT($ , $ , const $*, $*);]], mod.VkDevice, mod.VkImage, mod.VkImageSubresource2, mod.VkSubresourceLayout2)
mod.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ memoryMapPlaced;
	$ memoryMapRangePlaced;
	$ memoryUnmapReserve;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ minPlacedMemoryMapAlignment;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkMemoryMapPlacedInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	void* pPlacedAddress;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderBufferFloat16Atomics;
	$ shaderBufferFloat16AtomicAdd;
	$ shaderBufferFloat16AtomicMinMax;
	$ shaderBufferFloat32AtomicMinMax;
	$ shaderBufferFloat64AtomicMinMax;
	$ shaderSharedFloat16Atomics;
	$ shaderSharedFloat16AtomicAdd;
	$ shaderSharedFloat16AtomicMinMax;
	$ shaderSharedFloat32AtomicMinMax;
	$ shaderSharedFloat64AtomicMinMax;
	$ shaderImageFloat32AtomicMinMax;
	$ sparseImageFloat32AtomicMinMax;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPresentScalingFlagBitsEXT = ffi.typeof([[$ ]], mod.VkPresentScalingFlagBitsKHR)
mod.VkPresentScalingFlagsEXT = ffi.typeof([[$ ]], mod.VkPresentScalingFlagsKHR)
mod.VkPresentGravityFlagBitsEXT = ffi.typeof([[$ ]], mod.VkPresentGravityFlagBitsKHR)
mod.VkPresentGravityFlagsEXT = ffi.typeof([[$ ]], mod.VkPresentGravityFlagsKHR)
mod.VkSurfacePresentModeEXT = ffi.typeof([[$ ]], mod.VkSurfacePresentModeKHR)
mod.VkSurfacePresentScalingCapabilitiesEXT = ffi.typeof([[$ ]], mod.VkSurfacePresentScalingCapabilitiesKHR)
mod.VkSurfacePresentModeCompatibilityEXT = ffi.typeof([[$ ]], mod.VkSurfacePresentModeCompatibilityKHR)
mod.VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR)
mod.VkSwapchainPresentFenceInfoEXT = ffi.typeof([[$ ]], mod.VkSwapchainPresentFenceInfoKHR)
mod.VkSwapchainPresentModesCreateInfoEXT = ffi.typeof([[$ ]], mod.VkSwapchainPresentModesCreateInfoKHR)
mod.VkSwapchainPresentModeInfoEXT = ffi.typeof([[$ ]], mod.VkSwapchainPresentModeInfoKHR)
mod.VkSwapchainPresentScalingCreateInfoEXT = ffi.typeof([[$ ]], mod.VkSwapchainPresentScalingCreateInfoKHR)
mod.VkReleaseSwapchainImagesInfoEXT = ffi.typeof([[$ ]], mod.VkReleaseSwapchainImagesInfoKHR)
mod.PFN_vkReleaseSwapchainImagesEXT = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkReleaseSwapchainImagesInfoKHR)
ffi.cdef([[$  vkReleaseSwapchainImagesEXT($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkReleaseSwapchainImagesInfoKHR)
mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures)
mod.VkIndirectCommandsLayoutNV = ffi.typeof([[void*]])
mod.VkIndirectCommandsTokenTypeNV = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkIndirectStateFlagBitsNV = ffi.typeof([[enum {
	VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x00000001,
	VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkIndirectStateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkIndirectCommandsLayoutUsageFlagBitsNV = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x00000001,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x00000002,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x00000004,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsLayoutUsageFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxGraphicsShaderGroupCount;
	uint32_t maxIndirectSequenceCount;
	uint32_t maxIndirectCommandsTokenCount;
	uint32_t maxIndirectCommandsStreamCount;
	uint32_t maxIndirectCommandsTokenOffset;
	uint32_t maxIndirectCommandsStreamStride;
	uint32_t minSequencesCountBufferOffsetAlignment;
	uint32_t minSequencesIndexBufferOffsetAlignment;
	uint32_t minIndirectCommandsBufferOffsetAlignment;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ deviceGeneratedCommands;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkGraphicsShaderGroupCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t stageCount;
	const $* pStages;
	const $* pVertexInputState;
	const $* pTessellationState;
}]], mod.VkStructureType, mod.VkPipelineShaderStageCreateInfo, mod.VkPipelineVertexInputStateCreateInfo, mod.VkPipelineTessellationStateCreateInfo)
mod.VkGraphicsPipelineShaderGroupsCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t groupCount;
	const $* pGroups;
	uint32_t pipelineCount;
	const $* pPipelines;
}]], mod.VkStructureType, mod.VkGraphicsShaderGroupCreateInfoNV, mod.VkPipeline)
mod.VkBindShaderGroupIndirectCommandNV = ffi.typeof([[struct {
	uint32_t groupIndex;
}]])
mod.VkBindIndexBufferIndirectCommandNV = ffi.typeof([[struct {
	$ bufferAddress;
	uint32_t size;
	$ indexType;
}]], mod.VkDeviceAddress, mod.VkIndexType)
mod.VkBindVertexBufferIndirectCommandNV = ffi.typeof([[struct {
	$ bufferAddress;
	uint32_t size;
	uint32_t stride;
}]], mod.VkDeviceAddress)
mod.VkSetStateFlagsIndirectCommandNV = ffi.typeof([[struct {
	uint32_t data;
}]])
mod.VkIndirectCommandsStreamNV = ffi.typeof([[struct {
	$ buffer;
	$ offset;
}]], mod.VkBuffer, mod.VkDeviceSize)
mod.VkIndirectCommandsLayoutTokenNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ tokenType;
	uint32_t stream;
	uint32_t offset;
	uint32_t vertexBindingUnit;
	$ vertexDynamicStride;
	$ pushconstantPipelineLayout;
	$ pushconstantShaderStageFlags;
	uint32_t pushconstantOffset;
	uint32_t pushconstantSize;
	$ indirectStateFlags;
	uint32_t indexTypeCount;
	const $* pIndexTypes;
	const uint32_t* pIndexTypeValues;
}]], mod.VkStructureType, mod.VkIndirectCommandsTokenTypeNV, mod.VkBool32, mod.VkPipelineLayout, mod.VkShaderStageFlags, mod.VkIndirectStateFlagsNV, mod.VkIndexType)
mod.VkIndirectCommandsLayoutCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ pipelineBindPoint;
	uint32_t tokenCount;
	const $* pTokens;
	uint32_t streamCount;
	const uint32_t* pStreamStrides;
}]], mod.VkStructureType, mod.VkIndirectCommandsLayoutUsageFlagsNV, mod.VkPipelineBindPoint, mod.VkIndirectCommandsLayoutTokenNV)
mod.VkGeneratedCommandsInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ pipelineBindPoint;
	$ pipeline;
	$ indirectCommandsLayout;
	uint32_t streamCount;
	const $* pStreams;
	uint32_t sequencesCount;
	$ preprocessBuffer;
	$ preprocessOffset;
	$ preprocessSize;
	$ sequencesCountBuffer;
	$ sequencesCountOffset;
	$ sequencesIndexBuffer;
	$ sequencesIndexOffset;
}]], mod.VkStructureType, mod.VkPipelineBindPoint, mod.VkPipeline, mod.VkIndirectCommandsLayoutNV, mod.VkIndirectCommandsStreamNV, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.VkGeneratedCommandsMemoryRequirementsInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ pipelineBindPoint;
	$ pipeline;
	$ indirectCommandsLayout;
	uint32_t maxSequencesCount;
}]], mod.VkStructureType, mod.VkPipelineBindPoint, mod.VkPipeline, mod.VkIndirectCommandsLayoutNV)
mod.PFN_vkGetGeneratedCommandsMemoryRequirementsNV = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkGeneratedCommandsMemoryRequirementsInfoNV, mod.VkMemoryRequirements2)
mod.PFN_vkCmdPreprocessGeneratedCommandsNV = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkGeneratedCommandsInfoNV)
mod.PFN_vkCmdExecuteGeneratedCommandsNV = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkCommandBuffer, mod.VkBool32, mod.VkGeneratedCommandsInfoNV)
mod.PFN_vkCmdBindPipelineShaderGroupNV = ffi.typeof([[void (*)($ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipeline)
mod.PFN_vkCreateIndirectCommandsLayoutNV = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkIndirectCommandsLayoutCreateInfoNV, mod.VkAllocationCallbacks, mod.VkIndirectCommandsLayoutNV)
mod.PFN_vkDestroyIndirectCommandsLayoutNV = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkIndirectCommandsLayoutNV, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkGetGeneratedCommandsMemoryRequirementsNV($ , const $*, $*);]], mod.VkDevice, mod.VkGeneratedCommandsMemoryRequirementsInfoNV, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkCmdPreprocessGeneratedCommandsNV($ , const $*);]], mod.VkCommandBuffer, mod.VkGeneratedCommandsInfoNV)
ffi.cdef([[void  vkCmdExecuteGeneratedCommandsNV($ , $ , const $*);]], mod.VkCommandBuffer, mod.VkBool32, mod.VkGeneratedCommandsInfoNV)
ffi.cdef([[void  vkCmdBindPipelineShaderGroupNV($ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipeline)
ffi.cdef([[$  vkCreateIndirectCommandsLayoutNV($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkIndirectCommandsLayoutCreateInfoNV, mod.VkAllocationCallbacks, mod.VkIndirectCommandsLayoutNV)
ffi.cdef([[void  vkDestroyIndirectCommandsLayoutNV($ , $ , const $*);]], mod.VkDevice, mod.VkIndirectCommandsLayoutNV, mod.VkAllocationCallbacks)
mod.VkPhysicalDeviceInheritedViewportScissorFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ inheritedViewportScissor2D;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkCommandBufferInheritanceViewportScissorInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ viewportScissor2D;
	uint32_t viewportDepthCount;
	const $* pViewportDepths;
}]], mod.VkStructureType, mod.VkBool32, mod.VkViewport)
mod.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ texelBufferAlignment;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceTexelBufferAlignmentProperties)
mod.VkRenderPassTransformBeginInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ transform;
}]], mod.VkStructureType, mod.VkSurfaceTransformFlagBitsKHR)
mod.VkCommandBufferInheritanceRenderPassTransformInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ transform;
	$ renderArea;
}]], mod.VkStructureType, mod.VkSurfaceTransformFlagBitsKHR, mod.VkRect2D)
mod.VkDepthBiasRepresentationEXT = ffi.typeof([[enum {
	VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0,
	VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1,
	VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2,
	VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceDepthBiasControlFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ depthBiasControl;
	$ leastRepresentableValueForceUnormRepresentation;
	$ floatRepresentation;
	$ depthBiasExact;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDepthBiasInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	float depthBiasConstantFactor;
	float depthBiasClamp;
	float depthBiasSlopeFactor;
}]], mod.VkStructureType)
mod.VkDepthBiasRepresentationInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ depthBiasRepresentation;
	$ depthBiasExact;
}]], mod.VkStructureType, mod.VkDepthBiasRepresentationEXT, mod.VkBool32)
mod.PFN_vkCmdSetDepthBias2EXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDepthBiasInfoEXT)
ffi.cdef([[void  vkCmdSetDepthBias2EXT($ , const $*);]], mod.VkCommandBuffer, mod.VkDepthBiasInfoEXT)
mod.VkDeviceMemoryReportEventTypeEXT = ffi.typeof([[enum {
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceMemoryReportFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ deviceMemoryReport;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDeviceMemoryReportCallbackDataEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ type;
	uint64_t memoryObjectId;
	$ size;
	$ objectType;
	uint64_t objectHandle;
	uint32_t heapIndex;
}]], mod.VkStructureType, mod.VkDeviceMemoryReportFlagsEXT, mod.VkDeviceMemoryReportEventTypeEXT, mod.VkDeviceSize, mod.VkObjectType)
mod.PFN_vkDeviceMemoryReportCallbackEXT = ffi.typeof([[void (*)(const $*, void*)]], mod.VkDeviceMemoryReportCallbackDataEXT)
mod.VkDeviceDeviceMemoryReportCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ pfnUserCallback;
	void* pUserData;
}]], mod.VkStructureType, mod.VkDeviceMemoryReportFlagsEXT, mod.PFN_vkDeviceMemoryReportCallbackEXT)
mod.PFN_vkAcquireDrmDisplayEXT = ffi.typeof([[$ (*)($ , int32_t , $ )]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
mod.PFN_vkGetDrmDisplayEXT = ffi.typeof([[$ (*)($ , int32_t , uint32_t , $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
ffi.cdef([[$  vkAcquireDrmDisplayEXT($ , int32_t , $ );]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
ffi.cdef([[$  vkGetDrmDisplayEXT($ , int32_t , uint32_t , $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkDisplayKHR)
mod.VkPhysicalDeviceRobustness2FeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceRobustness2FeaturesKHR)
mod.VkPhysicalDeviceRobustness2PropertiesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceRobustness2PropertiesKHR)
mod.VkSamplerCustomBorderColorCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ customBorderColor;
	$ format;
}]], mod.VkStructureType, mod.VkClearColorValue, mod.VkFormat)
mod.VkPhysicalDeviceCustomBorderColorPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxCustomBorderColorSamplers;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceCustomBorderColorFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ customBorderColors;
	$ customBorderColorWithoutFormat;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDevicePresentBarrierFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentBarrier;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSurfaceCapabilitiesPresentBarrierNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentBarrierSupported;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSwapchainPresentBarrierCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentBarrierEnable;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPrivateDataSlotEXT = ffi.typeof([[$ ]], mod.VkPrivateDataSlot)
mod.VkPrivateDataSlotCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkPrivateDataSlotCreateFlags)
mod.VkPhysicalDevicePrivateDataFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePrivateDataFeatures)
mod.VkDevicePrivateDataCreateInfoEXT = ffi.typeof([[$ ]], mod.VkDevicePrivateDataCreateInfo)
mod.VkPrivateDataSlotCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPrivateDataSlotCreateInfo)
mod.PFN_vkCreatePrivateDataSlotEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPrivateDataSlotCreateInfo, mod.VkAllocationCallbacks, mod.VkPrivateDataSlot)
mod.PFN_vkDestroyPrivateDataSlotEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkPrivateDataSlot, mod.VkAllocationCallbacks)
mod.PFN_vkSetPrivateDataEXT = ffi.typeof([[$ (*)($ , $ , uint64_t , $ , uint64_t )]], mod.VkResult, mod.VkDevice, mod.VkObjectType, mod.VkPrivateDataSlot)
mod.PFN_vkGetPrivateDataEXT = ffi.typeof([[void (*)($ , $ , uint64_t , $ , uint64_t*)]], mod.VkDevice, mod.VkObjectType, mod.VkPrivateDataSlot)
ffi.cdef([[$  vkCreatePrivateDataSlotEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPrivateDataSlotCreateInfo, mod.VkAllocationCallbacks, mod.VkPrivateDataSlot)
ffi.cdef([[void  vkDestroyPrivateDataSlotEXT($ , $ , const $*);]], mod.VkDevice, mod.VkPrivateDataSlot, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkSetPrivateDataEXT($ , $ , uint64_t , $ , uint64_t );]], mod.VkResult, mod.VkDevice, mod.VkObjectType, mod.VkPrivateDataSlot)
ffi.cdef([[void  vkGetPrivateDataEXT($ , $ , uint64_t , $ , uint64_t*);]], mod.VkDevice, mod.VkObjectType, mod.VkPrivateDataSlot)
mod.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePipelineCreationCacheControlFeatures)
mod.VkDeviceDiagnosticsConfigFlagBitsNV = ffi.typeof([[enum {
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x00000001,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x00000002,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x00000004,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x00000008,
	VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkDeviceDiagnosticsConfigFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDiagnosticsConfigFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ diagnosticsConfig;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDeviceDiagnosticsConfigCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkDeviceDiagnosticsConfigFlagsNV)
mod.VkTileShadingRenderPassFlagBitsQCOM = ffi.typeof([[enum {
	VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM = 0x00000001,
	VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM = 0x00000002,
	VK_TILE_SHADING_RENDER_PASS_FLAG_BITS_MAX_ENUM_QCOM = 0x7FFFFFFF,
}]])
mod.VkTileShadingRenderPassFlagsQCOM = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceTileShadingFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ tileShading;
	$ tileShadingFragmentStage;
	$ tileShadingColorAttachments;
	$ tileShadingDepthAttachments;
	$ tileShadingStencilAttachments;
	$ tileShadingInputAttachments;
	$ tileShadingSampledAttachments;
	$ tileShadingPerTileDraw;
	$ tileShadingPerTileDispatch;
	$ tileShadingDispatchTile;
	$ tileShadingApron;
	$ tileShadingAnisotropicApron;
	$ tileShadingAtomicOps;
	$ tileShadingImageProcessing;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceTileShadingPropertiesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxApronSize;
	$ preferNonCoherent;
	$ tileGranularity;
	$ maxTileShadingRate;
}]], mod.VkStructureType, mod.VkBool32, mod.VkExtent2D, mod.VkExtent2D)
mod.VkRenderPassTileShadingCreateInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ tileApronSize;
}]], mod.VkStructureType, mod.VkTileShadingRenderPassFlagsQCOM, mod.VkExtent2D)
mod.VkPerTileBeginInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
mod.VkPerTileEndInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
mod.VkDispatchTileInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
mod.PFN_vkCmdDispatchTileQCOM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDispatchTileInfoQCOM)
mod.PFN_vkCmdBeginPerTileExecutionQCOM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPerTileBeginInfoQCOM)
mod.PFN_vkCmdEndPerTileExecutionQCOM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkPerTileEndInfoQCOM)
ffi.cdef([[void  vkCmdDispatchTileQCOM($ , const $*);]], mod.VkCommandBuffer, mod.VkDispatchTileInfoQCOM)
ffi.cdef([[void  vkCmdBeginPerTileExecutionQCOM($ , const $*);]], mod.VkCommandBuffer, mod.VkPerTileBeginInfoQCOM)
ffi.cdef([[void  vkCmdEndPerTileExecutionQCOM($ , const $*);]], mod.VkCommandBuffer, mod.VkPerTileEndInfoQCOM)
mod.VkQueryLowLatencySupportNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	void* pQueriedLowLatencyData;
}]], mod.VkStructureType)
mod.VkAccelerationStructureKHR = ffi.typeof([[void*]])
mod.VkPhysicalDeviceDescriptorBufferPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ combinedImageSamplerDescriptorSingleArray;
	$ bufferlessPushDescriptors;
	$ allowSamplerImageViewPostSubmitCreation;
	$ descriptorBufferOffsetAlignment;
	uint32_t maxDescriptorBufferBindings;
	uint32_t maxResourceDescriptorBufferBindings;
	uint32_t maxSamplerDescriptorBufferBindings;
	uint32_t maxEmbeddedImmutableSamplerBindings;
	uint32_t maxEmbeddedImmutableSamplers;
	size_t bufferCaptureReplayDescriptorDataSize;
	size_t imageCaptureReplayDescriptorDataSize;
	size_t imageViewCaptureReplayDescriptorDataSize;
	size_t samplerCaptureReplayDescriptorDataSize;
	size_t accelerationStructureCaptureReplayDescriptorDataSize;
	size_t samplerDescriptorSize;
	size_t combinedImageSamplerDescriptorSize;
	size_t sampledImageDescriptorSize;
	size_t storageImageDescriptorSize;
	size_t uniformTexelBufferDescriptorSize;
	size_t robustUniformTexelBufferDescriptorSize;
	size_t storageTexelBufferDescriptorSize;
	size_t robustStorageTexelBufferDescriptorSize;
	size_t uniformBufferDescriptorSize;
	size_t robustUniformBufferDescriptorSize;
	size_t storageBufferDescriptorSize;
	size_t robustStorageBufferDescriptorSize;
	size_t inputAttachmentDescriptorSize;
	size_t accelerationStructureDescriptorSize;
	$ maxSamplerDescriptorBufferRange;
	$ maxResourceDescriptorBufferRange;
	$ samplerDescriptorBufferAddressSpaceSize;
	$ resourceDescriptorBufferAddressSpaceSize;
	$ descriptorBufferAddressSpaceSize;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	size_t combinedImageSamplerDensityMapDescriptorSize;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceDescriptorBufferFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ descriptorBuffer;
	$ descriptorBufferCaptureReplay;
	$ descriptorBufferImageLayoutIgnored;
	$ descriptorBufferPushDescriptors;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDescriptorAddressInfoEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ address;
	$ range;
	$ format;
}]], mod.VkStructureType, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkFormat)
mod.VkDescriptorBufferBindingInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ address;
	$ usage;
}]], mod.VkStructureType, mod.VkDeviceAddress, mod.VkBufferUsageFlags)
mod.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ buffer;
}]], mod.VkStructureType, mod.VkBuffer)
mod.VkDescriptorDataEXT = ffi.typeof([[union {
	const $* pSampler;
	const $* pCombinedImageSampler;
	const $* pInputAttachmentImage;
	const $* pSampledImage;
	const $* pStorageImage;
	const $* pUniformTexelBuffer;
	const $* pStorageTexelBuffer;
	const $* pUniformBuffer;
	const $* pStorageBuffer;
	$ accelerationStructure;
}]], mod.VkSampler, mod.VkDescriptorImageInfo, mod.VkDescriptorImageInfo, mod.VkDescriptorImageInfo, mod.VkDescriptorImageInfo, mod.VkDescriptorAddressInfoEXT, mod.VkDescriptorAddressInfoEXT, mod.VkDescriptorAddressInfoEXT, mod.VkDescriptorAddressInfoEXT, mod.VkDeviceAddress)
mod.VkDescriptorGetInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ data;
}]], mod.VkStructureType, mod.VkDescriptorType, mod.VkDescriptorDataEXT)
mod.VkBufferCaptureDescriptorDataInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ buffer;
}]], mod.VkStructureType, mod.VkBuffer)
mod.VkImageCaptureDescriptorDataInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
}]], mod.VkStructureType, mod.VkImage)
mod.VkImageViewCaptureDescriptorDataInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ imageView;
}]], mod.VkStructureType, mod.VkImageView)
mod.VkSamplerCaptureDescriptorDataInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ sampler;
}]], mod.VkStructureType, mod.VkSampler)
mod.VkOpaqueCaptureDescriptorDataCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const void* opaqueCaptureDescriptorData;
}]], mod.VkStructureType)
mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ accelerationStructure;
	$ accelerationStructureNV;
}]], mod.VkStructureType, mod.VkAccelerationStructureKHR, mod.VkAccelerationStructureNV)
mod.PFN_vkGetDescriptorSetLayoutSizeEXT = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkDescriptorSetLayout, mod.VkDeviceSize)
mod.PFN_vkGetDescriptorSetLayoutBindingOffsetEXT = ffi.typeof([[void (*)($ , $ , uint32_t , $*)]], mod.VkDevice, mod.VkDescriptorSetLayout, mod.VkDeviceSize)
mod.PFN_vkGetDescriptorEXT = ffi.typeof([[void (*)($ , const $*, size_t , void*)]], mod.VkDevice, mod.VkDescriptorGetInfoEXT)
mod.PFN_vkCmdBindDescriptorBuffersEXT = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkDescriptorBufferBindingInfoEXT)
mod.PFN_vkCmdSetDescriptorBufferOffsetsEXT = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t , const uint32_t*, const $*)]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout, mod.VkDeviceSize)
mod.PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT = ffi.typeof([[void (*)($ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout)
mod.PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT = ffi.typeof([[$ (*)($ , const $*, void*)]], mod.VkResult, mod.VkDevice, mod.VkBufferCaptureDescriptorDataInfoEXT)
mod.PFN_vkGetImageOpaqueCaptureDescriptorDataEXT = ffi.typeof([[$ (*)($ , const $*, void*)]], mod.VkResult, mod.VkDevice, mod.VkImageCaptureDescriptorDataInfoEXT)
mod.PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT = ffi.typeof([[$ (*)($ , const $*, void*)]], mod.VkResult, mod.VkDevice, mod.VkImageViewCaptureDescriptorDataInfoEXT)
mod.PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT = ffi.typeof([[$ (*)($ , const $*, void*)]], mod.VkResult, mod.VkDevice, mod.VkSamplerCaptureDescriptorDataInfoEXT)
mod.PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = ffi.typeof([[$ (*)($ , const $*, void*)]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT)
ffi.cdef([[void  vkGetDescriptorSetLayoutSizeEXT($ , $ , $*);]], mod.VkDevice, mod.VkDescriptorSetLayout, mod.VkDeviceSize)
ffi.cdef([[void  vkGetDescriptorSetLayoutBindingOffsetEXT($ , $ , uint32_t , $*);]], mod.VkDevice, mod.VkDescriptorSetLayout, mod.VkDeviceSize)
ffi.cdef([[void  vkGetDescriptorEXT($ , const $*, size_t , void*);]], mod.VkDevice, mod.VkDescriptorGetInfoEXT)
ffi.cdef([[void  vkCmdBindDescriptorBuffersEXT($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkDescriptorBufferBindingInfoEXT)
ffi.cdef([[void  vkCmdSetDescriptorBufferOffsetsEXT($ , $ , $ , uint32_t , uint32_t , const uint32_t*, const $*);]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdBindDescriptorBufferEmbeddedSamplersEXT($ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipelineLayout)
ffi.cdef([[$  vkGetBufferOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]], mod.VkResult, mod.VkDevice, mod.VkBufferCaptureDescriptorDataInfoEXT)
ffi.cdef([[$  vkGetImageOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]], mod.VkResult, mod.VkDevice, mod.VkImageCaptureDescriptorDataInfoEXT)
ffi.cdef([[$  vkGetImageViewOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]], mod.VkResult, mod.VkDevice, mod.VkImageViewCaptureDescriptorDataInfoEXT)
ffi.cdef([[$  vkGetSamplerOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]], mod.VkResult, mod.VkDevice, mod.VkSamplerCaptureDescriptorDataInfoEXT)
ffi.cdef([[$  vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT($ , const $*, void*);]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureCaptureDescriptorDataInfoEXT)
mod.VkGraphicsPipelineLibraryFlagBitsEXT = ffi.typeof([[enum {
	VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x00000001,
	VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x00000002,
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x00000004,
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x00000008,
	VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkGraphicsPipelineLibraryFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ graphicsPipelineLibrary;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ graphicsPipelineLibraryFastLinking;
	$ graphicsPipelineLibraryIndependentInterpolationDecoration;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkGraphicsPipelineLibraryCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkGraphicsPipelineLibraryFlagsEXT)
mod.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderEarlyAndLateFragmentTests;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkFragmentShadingRateTypeNV = ffi.typeof([[enum {
	VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
	VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkFragmentShadingRateNV = ffi.typeof([[enum {
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
	VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
	VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
	VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
	VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
	VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
	VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ fragmentShadingRateEnums;
	$ supersampleFragmentShadingRates;
	$ noInvocationFragmentShadingRates;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxFragmentShadingRateInvocationCount;
}]], mod.VkStructureType, mod.VkSampleCountFlagBits)
mod.VkPipelineFragmentShadingRateEnumStateCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ shadingRateType;
	$ shadingRate;
	$ combinerOps[2];
}]], mod.VkStructureType, mod.VkFragmentShadingRateTypeNV, mod.VkFragmentShadingRateNV, mod.VkFragmentShadingRateCombinerOpKHR)
mod.PFN_vkCmdSetFragmentShadingRateEnumNV = ffi.typeof([[void (*)($ , $ , const $[2])]], mod.VkCommandBuffer, mod.VkFragmentShadingRateNV, mod.VkFragmentShadingRateCombinerOpKHR)
ffi.cdef([[void  vkCmdSetFragmentShadingRateEnumNV($ , $ , const $[2]);]], mod.VkCommandBuffer, mod.VkFragmentShadingRateNV, mod.VkFragmentShadingRateCombinerOpKHR)
mod.VkAccelerationStructureMotionInstanceTypeNV = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureMotionInfoFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAccelerationStructureMotionInstanceFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDeviceOrHostAddressConstKHR = ffi.typeof([[union {
	$ deviceAddress;
	const void* hostAddress;
}]], mod.VkDeviceAddress)
mod.VkAccelerationStructureGeometryMotionTrianglesDataNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ vertexData;
}]], mod.VkStructureType, mod.VkDeviceOrHostAddressConstKHR)
mod.VkAccelerationStructureMotionInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maxInstances;
	$ flags;
}]], mod.VkStructureType, mod.VkAccelerationStructureMotionInfoFlagsNV)
mod.VkAccelerationStructureMatrixMotionInstanceNV = ffi.typeof([[struct {
	$ transformT0;
	$ transformT1;
	uint32_t instanceCustomIndex;
	uint32_t mask;
	uint32_t instanceShaderBindingTableRecordOffset;
	$ flags;
	uint64_t accelerationStructureReference;
}]], mod.VkTransformMatrixKHR, mod.VkTransformMatrixKHR, mod.VkGeometryInstanceFlagsKHR)
mod.VkSRTDataNV = ffi.typeof([[struct {
	float sx;
	float a;
	float b;
	float pvx;
	float sy;
	float c;
	float pvy;
	float sz;
	float pvz;
	float qx;
	float qy;
	float qz;
	float qw;
	float tx;
	float ty;
	float tz;
}]])
mod.VkAccelerationStructureSRTMotionInstanceNV = ffi.typeof([[struct {
	$ transformT0;
	$ transformT1;
	uint32_t instanceCustomIndex;
	uint32_t mask;
	uint32_t instanceShaderBindingTableRecordOffset;
	$ flags;
	uint64_t accelerationStructureReference;
}]], mod.VkSRTDataNV, mod.VkSRTDataNV, mod.VkGeometryInstanceFlagsKHR)
mod.VkAccelerationStructureMotionInstanceDataNV = ffi.typeof([[union {
	$ staticInstance;
	$ matrixMotionInstance;
	$ srtMotionInstance;
}]], mod.VkAccelerationStructureInstanceKHR, mod.VkAccelerationStructureMatrixMotionInstanceNV, mod.VkAccelerationStructureSRTMotionInstanceNV)
mod.VkAccelerationStructureMotionInstanceNV = ffi.typeof([[struct {
	$ type;
	$ flags;
	$ data;
}]], mod.VkAccelerationStructureMotionInstanceTypeNV, mod.VkAccelerationStructureMotionInstanceFlagsNV, mod.VkAccelerationStructureMotionInstanceDataNV)
mod.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rayTracingMotionBlur;
	$ rayTracingMotionBlurPipelineTraceRaysIndirect;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ ycbcr2plane444Formats;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityMapDeferred;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ subsampledLoads;
	$ subsampledCoarseReconstructionEarlyAccess;
	uint32_t maxSubsampledArrayLayers;
	uint32_t maxDescriptorSetSubsampledSamplers;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkCopyCommandTransformInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ transform;
}]], mod.VkStructureType, mod.VkSurfaceTransformFlagBitsKHR)
mod.VkPhysicalDeviceImageRobustnessFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceImageRobustnessFeatures)
mod.VkImageCompressionFlagBitsEXT = ffi.typeof([[enum {
	VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0,
	VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 0x00000001,
	VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 0x00000002,
	VK_IMAGE_COMPRESSION_DISABLED_EXT = 0x00000004,
	VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkImageCompressionFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkImageCompressionFixedRateFlagBitsEXT = ffi.typeof([[enum {
	VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0,
	VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 0x00000001,
	VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 0x00000002,
	VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 0x00000004,
	VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 0x00000008,
	VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 0x00000010,
	VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 0x00000020,
	VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 0x00000040,
	VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 0x00000080,
	VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 0x00000100,
	VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 0x00000200,
	VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 0x00000400,
	VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 0x00000800,
	VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 0x00001000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 0x00002000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 0x00004000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 0x00008000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 0x00010000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 0x00020000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 0x00040000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 0x00080000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 0x00100000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 0x00200000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 0x00400000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 0x00800000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkImageCompressionFixedRateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceImageCompressionControlFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageCompressionControl;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkImageCompressionControlEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t compressionControlPlaneCount;
	$* pFixedRateFlags;
}]], mod.VkStructureType, mod.VkImageCompressionFlagsEXT, mod.VkImageCompressionFixedRateFlagsEXT)
mod.VkImageCompressionPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageCompressionFlags;
	$ imageCompressionFixedRateFlags;
}]], mod.VkStructureType, mod.VkImageCompressionFlagsEXT, mod.VkImageCompressionFixedRateFlagsEXT)
mod.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ attachmentFeedbackLoopLayout;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevice4444FormatsFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ formatA4R4G4B4;
	$ formatA4B4G4R4;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkDeviceFaultAddressTypeEXT = ffi.typeof([[enum {
	VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
	VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
	VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
	VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
	VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceFaultVendorBinaryHeaderVersionEXT = ffi.typeof([[enum {
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceFaultFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ deviceFault;
	$ deviceFaultVendorBinary;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkDeviceFaultCountsEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t addressInfoCount;
	uint32_t vendorInfoCount;
	$ vendorBinarySize;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkDeviceFaultAddressInfoEXT = ffi.typeof([[struct {
	$ addressType;
	$ reportedAddress;
	$ addressPrecision;
}]], mod.VkDeviceFaultAddressTypeEXT, mod.VkDeviceAddress, mod.VkDeviceSize)
mod.VkDeviceFaultVendorInfoEXT = ffi.typeof([[struct {
	char description[256U];
	uint64_t vendorFaultCode;
	uint64_t vendorFaultData;
}]])
mod.VkDeviceFaultInfoEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	char description[256U];
	$* pAddressInfos;
	$* pVendorInfos;
	void* pVendorBinaryData;
}]], mod.VkStructureType, mod.VkDeviceFaultAddressInfoEXT, mod.VkDeviceFaultVendorInfoEXT)
mod.VkDeviceFaultVendorBinaryHeaderVersionOneEXT = ffi.typeof([[struct {
	uint32_t headerSize;
	$ headerVersion;
	uint32_t vendorID;
	uint32_t deviceID;
	uint32_t driverVersion;
	uint8_t pipelineCacheUUID[16U];
	uint32_t applicationNameOffset;
	uint32_t applicationVersion;
	uint32_t engineNameOffset;
	uint32_t engineVersion;
	uint32_t apiVersion;
}]], mod.VkDeviceFaultVendorBinaryHeaderVersionEXT)
mod.PFN_vkGetDeviceFaultInfoEXT = ffi.typeof([[$ (*)($ , $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDeviceFaultCountsEXT, mod.VkDeviceFaultInfoEXT)
ffi.cdef([[$  vkGetDeviceFaultInfoEXT($ , $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDeviceFaultCountsEXT, mod.VkDeviceFaultInfoEXT)
mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rasterizationOrderColorAttachmentAccess;
	$ rasterizationOrderDepthAttachmentAccess;
	$ rasterizationOrderStencilAttachmentAccess;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = ffi.typeof([[$ ]], mod.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT)
mod.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ formatRgba10x6WithoutYCbCrSampler;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ mutableDescriptorType;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT)
mod.VkMutableDescriptorTypeListEXT = ffi.typeof([[struct {
	uint32_t descriptorTypeCount;
	const $* pDescriptorTypes;
}]], mod.VkDescriptorType)
mod.VkMutableDescriptorTypeListVALVE = ffi.typeof([[$ ]], mod.VkMutableDescriptorTypeListEXT)
mod.VkMutableDescriptorTypeCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t mutableDescriptorTypeListCount;
	const $* pMutableDescriptorTypeLists;
}]], mod.VkStructureType, mod.VkMutableDescriptorTypeListEXT)
mod.VkMutableDescriptorTypeCreateInfoVALVE = ffi.typeof([[$ ]], mod.VkMutableDescriptorTypeCreateInfoEXT)
mod.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ vertexInputDynamicState;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVertexInputBindingDescription2EXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t binding;
	uint32_t stride;
	$ inputRate;
	uint32_t divisor;
}]], mod.VkStructureType, mod.VkVertexInputRate)
mod.VkVertexInputAttributeDescription2EXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t location;
	uint32_t binding;
	$ format;
	uint32_t offset;
}]], mod.VkStructureType, mod.VkFormat)
mod.PFN_vkCmdSetVertexInputEXT = ffi.typeof([[void (*)($ , uint32_t , const $*, uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkVertexInputBindingDescription2EXT, mod.VkVertexInputAttributeDescription2EXT)
ffi.cdef([[void  vkCmdSetVertexInputEXT($ , uint32_t , const $*, uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkVertexInputBindingDescription2EXT, mod.VkVertexInputAttributeDescription2EXT)
mod.VkPhysicalDeviceDrmPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ hasPrimary;
	$ hasRender;
	int64_t primaryMajor;
	int64_t primaryMinor;
	int64_t renderMajor;
	int64_t renderMinor;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkDeviceAddressBindingTypeEXT = ffi.typeof([[enum {
	VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
	VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
	VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceAddressBindingFlagBitsEXT = ffi.typeof([[enum {
	VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 0x00000001,
	VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDeviceAddressBindingFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceAddressBindingReportFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ reportAddressBinding;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDeviceAddressBindingCallbackDataEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ baseAddress;
	$ size;
	$ bindingType;
}]], mod.VkStructureType, mod.VkDeviceAddressBindingFlagsEXT, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceAddressBindingTypeEXT)
mod.VkPhysicalDeviceDepthClipControlFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ depthClipControl;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineViewportDepthClipControlCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ negativeOneToOne;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ primitiveTopologyListRestart;
	$ primitiveTopologyPatchListRestart;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR)
mod.VkSubpassShadingPipelineCreateInfoHUAWEI = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ renderPass;
	uint32_t subpass;
}]], mod.VkStructureType, mod.VkRenderPass)
mod.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ subpassShading;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxSubpassShadingWorkgroupSizeAspectRatio;
}]], mod.VkStructureType)
mod.PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = ffi.typeof([[$ (*)($ , $ , $*)]], mod.VkResult, mod.VkDevice, mod.VkRenderPass, mod.VkExtent2D)
mod.PFN_vkCmdSubpassShadingHUAWEI = ffi.typeof([[void (*)($ )]], mod.VkCommandBuffer)
ffi.cdef([[$  vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI($ , $ , $*);]], mod.VkResult, mod.VkDevice, mod.VkRenderPass, mod.VkExtent2D)
ffi.cdef([[void  vkCmdSubpassShadingHUAWEI($ );]], mod.VkCommandBuffer)
mod.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ invocationMask;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkCmdBindInvocationMaskHUAWEI = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkImageView, mod.VkImageLayout)
ffi.cdef([[void  vkCmdBindInvocationMaskHUAWEI($ , $ , $ );]], mod.VkCommandBuffer, mod.VkImageView, mod.VkImageLayout)
mod.VkRemoteAddressNV = ffi.typeof([[void*]])
mod.VkMemoryGetRemoteAddressInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ handleType;
}]], mod.VkStructureType, mod.VkDeviceMemory, mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ externalMemoryRDMA;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkGetMemoryRemoteAddressNV = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkMemoryGetRemoteAddressInfoNV, mod.VkRemoteAddressNV)
ffi.cdef([[$  vkGetMemoryRemoteAddressNV($ , const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkMemoryGetRemoteAddressInfoNV, mod.VkRemoteAddressNV)
mod.VkPipelineInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineInfoKHR)
mod.VkPipelinePropertiesIdentifierEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint8_t pipelineIdentifier[16U];
}]], mod.VkStructureType)
mod.VkPhysicalDevicePipelinePropertiesFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelinePropertiesIdentifier;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkGetPipelinePropertiesEXT = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkPipelineInfoEXT, mod.VkBaseOutStructure)
ffi.cdef([[$  vkGetPipelinePropertiesEXT($ , const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkPipelineInfoEXT, mod.VkBaseOutStructure)
mod.VkFrameBoundaryFlagBitsEXT = ffi.typeof([[enum {
	VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT = 0x00000001,
	VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkFrameBoundaryFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceFrameBoundaryFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ frameBoundary;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkFrameBoundaryEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint64_t frameID;
	uint32_t imageCount;
	const $* pImages;
	uint32_t bufferCount;
	const $* pBuffers;
	uint64_t tagName;
	size_t tagSize;
	const void* pTag;
}]], mod.VkStructureType, mod.VkFrameBoundaryFlagsEXT, mod.VkImage, mod.VkBuffer)
mod.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ multisampledRenderToSingleSampled;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSubpassResolvePerformanceQueryEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ optimal;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkMultisampledRenderToSingleSampledInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ multisampledRenderToSingleSampledEnable;
	$ rasterizationSamples;
}]], mod.VkStructureType, mod.VkBool32, mod.VkSampleCountFlagBits)
mod.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ extendedDynamicState2;
	$ extendedDynamicState2LogicOp;
	$ extendedDynamicState2PatchControlPoints;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.PFN_vkCmdSetPatchControlPointsEXT = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetRasterizerDiscardEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthBiasEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetLogicOpEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkLogicOp)
mod.PFN_vkCmdSetPrimitiveRestartEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetPatchControlPointsEXT($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetRasterizerDiscardEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthBiasEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetLogicOpEXT($ , $ );]], mod.VkCommandBuffer, mod.VkLogicOp)
ffi.cdef([[void  vkCmdSetPrimitiveRestartEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
mod.VkPhysicalDeviceColorWriteEnableFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ colorWriteEnable;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineColorWriteCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t attachmentCount;
	const $* pColorWriteEnables;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkCmdSetColorWriteEnableEXT = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetColorWriteEnableEXT($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkBool32)
mod.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ primitivesGeneratedQuery;
	$ primitivesGeneratedQueryWithRasterizerDiscard;
	$ primitivesGeneratedQueryWithNonZeroStreams;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceGlobalPriorityQueryFeatures)
mod.VkQueueFamilyGlobalPriorityPropertiesEXT = ffi.typeof([[$ ]], mod.VkQueueFamilyGlobalPriorityProperties)
mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_RGB_IDENTITY_BIT_VALVE = 0x00000001,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_IDENTITY_BIT_VALVE = 0x00000002,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_709_BIT_VALVE = 0x00000004,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_601_BIT_VALVE = 0x00000008,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_2020_BIT_VALVE = 0x00000010,
	VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_FLAG_BITS_MAX_ENUM_VALVE = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeRgbModelConversionFlagsVALVE = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FULL_RANGE_BIT_VALVE = 0x00000001,
	VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_NARROW_RANGE_BIT_VALVE = 0x00000002,
	VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FLAG_BITS_MAX_ENUM_VALVE = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeRgbRangeCompressionFlagsVALVE = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE = ffi.typeof([[enum {
	VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_COSITED_EVEN_BIT_VALVE = 0x00000001,
	VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_MIDPOINT_BIT_VALVE = 0x00000002,
	VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_FLAG_BITS_MAX_ENUM_VALVE = 0x7FFFFFFF,
}]])
mod.VkVideoEncodeRgbChromaOffsetFlagsVALVE = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ videoEncodeRgbConversion;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoEncodeRgbConversionCapabilitiesVALVE = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rgbModels;
	$ rgbRanges;
	$ xChromaOffsets;
	$ yChromaOffsets;
}]], mod.VkStructureType, mod.VkVideoEncodeRgbModelConversionFlagsVALVE, mod.VkVideoEncodeRgbRangeCompressionFlagsVALVE, mod.VkVideoEncodeRgbChromaOffsetFlagsVALVE, mod.VkVideoEncodeRgbChromaOffsetFlagsVALVE)
mod.VkVideoEncodeProfileRgbConversionInfoVALVE = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ performEncodeRgbConversion;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkVideoEncodeSessionRgbConversionCreateInfoVALVE = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ rgbModel;
	$ rgbRange;
	$ xChromaOffset;
	$ yChromaOffset;
}]], mod.VkStructureType, mod.VkVideoEncodeRgbModelConversionFlagBitsVALVE, mod.VkVideoEncodeRgbRangeCompressionFlagBitsVALVE, mod.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE, mod.VkVideoEncodeRgbChromaOffsetFlagBitsVALVE)
mod.VkPhysicalDeviceImageViewMinLodFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ minLod;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkImageViewMinLodCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	float minLod;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceMultiDrawFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ multiDraw;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMultiDrawPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxMultiDrawCount;
}]], mod.VkStructureType)
mod.VkMultiDrawInfoEXT = ffi.typeof([[struct {
	uint32_t firstVertex;
	uint32_t vertexCount;
}]])
mod.VkMultiDrawIndexedInfoEXT = ffi.typeof([[struct {
	uint32_t firstIndex;
	uint32_t indexCount;
	int32_t vertexOffset;
}]])
mod.PFN_vkCmdDrawMultiEXT = ffi.typeof([[void (*)($ , uint32_t , const $*, uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkMultiDrawInfoEXT)
mod.PFN_vkCmdDrawMultiIndexedEXT = ffi.typeof([[void (*)($ , uint32_t , const $*, uint32_t , uint32_t , uint32_t , const int32_t*)]], mod.VkCommandBuffer, mod.VkMultiDrawIndexedInfoEXT)
ffi.cdef([[void  vkCmdDrawMultiEXT($ , uint32_t , const $*, uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkMultiDrawInfoEXT)
ffi.cdef([[void  vkCmdDrawMultiIndexedEXT($ , uint32_t , const $*, uint32_t , uint32_t , uint32_t , const int32_t*);]], mod.VkCommandBuffer, mod.VkMultiDrawIndexedInfoEXT)
mod.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ image2DViewOf3D;
	$ sampler2DViewOf3D;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceShaderTileImageFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderTileImageColorReadAccess;
	$ shaderTileImageDepthReadAccess;
	$ shaderTileImageStencilReadAccess;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceShaderTileImagePropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderTileImageCoherentReadAccelerated;
	$ shaderTileImageReadSampleFromPixelRateInvocation;
	$ shaderTileImageReadFromHelperInvocation;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkMicromapEXT = ffi.typeof([[void*]])
mod.VkMicromapTypeEXT = ffi.typeof([[enum {
	VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
	VK_MICROMAP_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkBuildMicromapModeEXT = ffi.typeof([[enum {
	VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
	VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkCopyMicromapModeEXT = ffi.typeof([[enum {
	VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
	VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
	VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
	VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
	VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkOpacityMicromapFormatEXT = ffi.typeof([[enum {
	VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
	VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
	VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkOpacityMicromapSpecialIndexEXT = ffi.typeof([[enum {
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV = -5,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureCompatibilityKHR = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureBuildTypeKHR = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkBuildMicromapFlagBitsEXT = ffi.typeof([[enum {
	VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 0x00000001,
	VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 0x00000002,
	VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 0x00000004,
	VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkBuildMicromapFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMicromapCreateFlagBitsEXT = ffi.typeof([[enum {
	VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x00000001,
	VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkMicromapCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMicromapUsageEXT = ffi.typeof([[struct {
	uint32_t count;
	uint32_t subdivisionLevel;
	uint32_t format;
}]])
mod.VkDeviceOrHostAddressKHR = ffi.typeof([[union {
	$ deviceAddress;
	void* hostAddress;
}]], mod.VkDeviceAddress)
mod.VkMicromapBuildInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ flags;
	$ mode;
	$ dstMicromap;
	uint32_t usageCountsCount;
	const $* pUsageCounts;
	const $** const ppUsageCounts;
	$ data;
	$ scratchData;
	$ triangleArray;
	$ triangleArrayStride;
}]], mod.VkStructureType, mod.VkMicromapTypeEXT, mod.VkBuildMicromapFlagsEXT, mod.VkBuildMicromapModeEXT, mod.VkMicromapEXT, mod.VkMicromapUsageEXT, mod.VkMicromapUsageEXT, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceOrHostAddressKHR, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize)
mod.VkMicromapCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ createFlags;
	$ buffer;
	$ offset;
	$ size;
	$ type;
	$ deviceAddress;
}]], mod.VkStructureType, mod.VkMicromapCreateFlagsEXT, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkMicromapTypeEXT, mod.VkDeviceAddress)
mod.VkPhysicalDeviceOpacityMicromapFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ micromap;
	$ micromapCaptureReplay;
	$ micromapHostCommands;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceOpacityMicromapPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxOpacity2StateSubdivisionLevel;
	uint32_t maxOpacity4StateSubdivisionLevel;
}]], mod.VkStructureType)
mod.VkMicromapVersionInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const uint8_t* pVersionData;
}]], mod.VkStructureType)
mod.VkCopyMicromapToMemoryInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]], mod.VkStructureType, mod.VkMicromapEXT, mod.VkDeviceOrHostAddressKHR, mod.VkCopyMicromapModeEXT)
mod.VkCopyMemoryToMicromapInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]], mod.VkStructureType, mod.VkDeviceOrHostAddressConstKHR, mod.VkMicromapEXT, mod.VkCopyMicromapModeEXT)
mod.VkCopyMicromapInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]], mod.VkStructureType, mod.VkMicromapEXT, mod.VkMicromapEXT, mod.VkCopyMicromapModeEXT)
mod.VkMicromapBuildSizesInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ micromapSize;
	$ buildScratchSize;
	$ discardable;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkBool32)
mod.VkAccelerationStructureTrianglesOpacityMicromapEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ indexType;
	$ indexBuffer;
	$ indexStride;
	uint32_t baseTriangle;
	uint32_t usageCountsCount;
	const $* pUsageCounts;
	const $** const ppUsageCounts;
	$ micromap;
}]], mod.VkStructureType, mod.VkIndexType, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize, mod.VkMicromapUsageEXT, mod.VkMicromapUsageEXT, mod.VkMicromapEXT)
mod.VkMicromapTriangleEXT = ffi.typeof([[struct {
	uint32_t dataOffset;
	uint16_t subdivisionLevel;
	uint16_t format;
}]])
mod.PFN_vkCreateMicromapEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkMicromapCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkMicromapEXT)
mod.PFN_vkDestroyMicromapEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkMicromapEXT, mod.VkAllocationCallbacks)
mod.PFN_vkCmdBuildMicromapsEXT = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkMicromapBuildInfoEXT)
mod.PFN_vkBuildMicromapsEXT = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkMicromapBuildInfoEXT)
mod.PFN_vkCopyMicromapEXT = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyMicromapInfoEXT)
mod.PFN_vkCopyMicromapToMemoryEXT = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyMicromapToMemoryInfoEXT)
mod.PFN_vkCopyMemoryToMicromapEXT = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyMemoryToMicromapInfoEXT)
mod.PFN_vkWriteMicromapsPropertiesEXT = ffi.typeof([[$ (*)($ , uint32_t , const $*, $ , size_t , void*, size_t )]], mod.VkResult, mod.VkDevice, mod.VkMicromapEXT, mod.VkQueryType)
mod.PFN_vkCmdCopyMicromapEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyMicromapInfoEXT)
mod.PFN_vkCmdCopyMicromapToMemoryEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyMicromapToMemoryInfoEXT)
mod.PFN_vkCmdCopyMemoryToMicromapEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyMemoryToMicromapInfoEXT)
mod.PFN_vkCmdWriteMicromapsPropertiesEXT = ffi.typeof([[void (*)($ , uint32_t , const $*, $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkMicromapEXT, mod.VkQueryType, mod.VkQueryPool)
mod.PFN_vkGetDeviceMicromapCompatibilityEXT = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkMicromapVersionInfoEXT, mod.VkAccelerationStructureCompatibilityKHR)
mod.PFN_vkGetMicromapBuildSizesEXT = ffi.typeof([[void (*)($ , $ , const $*, $*)]], mod.VkDevice, mod.VkAccelerationStructureBuildTypeKHR, mod.VkMicromapBuildInfoEXT, mod.VkMicromapBuildSizesInfoEXT)
ffi.cdef([[$  vkCreateMicromapEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkMicromapCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkMicromapEXT)
ffi.cdef([[void  vkDestroyMicromapEXT($ , $ , const $*);]], mod.VkDevice, mod.VkMicromapEXT, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkCmdBuildMicromapsEXT($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkMicromapBuildInfoEXT)
ffi.cdef([[$  vkBuildMicromapsEXT($ , $ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkMicromapBuildInfoEXT)
ffi.cdef([[$  vkCopyMicromapEXT($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyMicromapInfoEXT)
ffi.cdef([[$  vkCopyMicromapToMemoryEXT($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyMicromapToMemoryInfoEXT)
ffi.cdef([[$  vkCopyMemoryToMicromapEXT($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyMemoryToMicromapInfoEXT)
ffi.cdef([[$  vkWriteMicromapsPropertiesEXT($ , uint32_t , const $*, $ , size_t , void*, size_t );]], mod.VkResult, mod.VkDevice, mod.VkMicromapEXT, mod.VkQueryType)
ffi.cdef([[void  vkCmdCopyMicromapEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyMicromapInfoEXT)
ffi.cdef([[void  vkCmdCopyMicromapToMemoryEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyMicromapToMemoryInfoEXT)
ffi.cdef([[void  vkCmdCopyMemoryToMicromapEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyMemoryToMicromapInfoEXT)
ffi.cdef([[void  vkCmdWriteMicromapsPropertiesEXT($ , uint32_t , const $*, $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkMicromapEXT, mod.VkQueryType, mod.VkQueryPool)
ffi.cdef([[void  vkGetDeviceMicromapCompatibilityEXT($ , const $*, $*);]], mod.VkDevice, mod.VkMicromapVersionInfoEXT, mod.VkAccelerationStructureCompatibilityKHR)
ffi.cdef([[void  vkGetMicromapBuildSizesEXT($ , $ , const $*, $*);]], mod.VkDevice, mod.VkAccelerationStructureBuildTypeKHR, mod.VkMicromapBuildInfoEXT, mod.VkMicromapBuildSizesInfoEXT)
mod.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ clustercullingShader;
	$ multiviewClusterCullingShader;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxWorkGroupCount[3];
	uint32_t maxWorkGroupSize[3];
	uint32_t maxOutputClusterCount;
	$ indirectBufferOffsetAlignment;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ clusterShadingRate;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkCmdDrawClusterHUAWEI = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawClusterIndirectHUAWEI = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawClusterHUAWEI($ , uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdDrawClusterIndirectHUAWEI($ , $ , $ );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ borderColorSwizzle;
	$ borderColorSwizzleFromImage;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkSamplerBorderColorComponentMappingCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ components;
	$ srgb;
}]], mod.VkStructureType, mod.VkComponentMapping, mod.VkBool32)
mod.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pageableDeviceLocalMemory;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkSetDeviceMemoryPriorityEXT = ffi.typeof([[void (*)($ , $ , float )]], mod.VkDevice, mod.VkDeviceMemory)
ffi.cdef([[void  vkSetDeviceMemoryPriorityEXT($ , $ , float );]], mod.VkDevice, mod.VkDeviceMemory)
mod.VkPhysicalDeviceShaderCorePropertiesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t pixelRate;
	uint32_t texelRate;
	uint32_t fmaRate;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceSchedulingControlsFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkPhysicalDeviceSchedulingControlsFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM = 0x00000001ULL
mod.VkDeviceQueueShaderCoreControlCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t shaderCoreCount;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceSchedulingControlsFeaturesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ schedulingControls;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceSchedulingControlsPropertiesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ schedulingControlsFlags;
}]], mod.VkStructureType, mod.VkPhysicalDeviceSchedulingControlsFlagsARM)
mod.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageSlicedViewOf3D;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkImageViewSlicedCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t sliceOffset;
	uint32_t sliceCount;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ descriptorSetHostMapping;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkDescriptorSetBindingReferenceVALVE = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ descriptorSetLayout;
	uint32_t binding;
}]], mod.VkStructureType, mod.VkDescriptorSetLayout)
mod.VkDescriptorSetLayoutHostMappingInfoVALVE = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	size_t descriptorOffset;
	uint32_t descriptorSize;
}]], mod.VkStructureType)
mod.PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDescriptorSetBindingReferenceVALVE, mod.VkDescriptorSetLayoutHostMappingInfoVALVE)
mod.PFN_vkGetDescriptorSetHostMappingVALVE = ffi.typeof([[void (*)($ , $ , void**)]], mod.VkDevice, mod.VkDescriptorSet)
ffi.cdef([[void  vkGetDescriptorSetLayoutHostMappingInfoVALVE($ , const $*, $*);]], mod.VkDevice, mod.VkDescriptorSetBindingReferenceVALVE, mod.VkDescriptorSetLayoutHostMappingInfoVALVE)
ffi.cdef([[void  vkGetDescriptorSetHostMappingVALVE($ , $ , void**);]], mod.VkDevice, mod.VkDescriptorSet)
mod.VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR)
mod.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ nonSeamlessCubeMap;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceRenderPassStripedFeaturesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ renderPassStriped;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceRenderPassStripedPropertiesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ renderPassStripeGranularity;
	uint32_t maxRenderPassStripes;
}]], mod.VkStructureType, mod.VkExtent2D)
mod.VkRenderPassStripeInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stripeArea;
}]], mod.VkStructureType, mod.VkRect2D)
mod.VkRenderPassStripeBeginInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t stripeInfoCount;
	const $* pStripeInfos;
}]], mod.VkStructureType, mod.VkRenderPassStripeInfoARM)
mod.VkRenderPassStripeSubmitInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t stripeSemaphoreInfoCount;
	const $* pStripeSemaphoreInfos;
}]], mod.VkStructureType, mod.VkSemaphoreSubmitInfo)
mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityMapOffset;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT)
mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityOffsetGranularity;
}]], mod.VkStructureType, mod.VkExtent2D)
mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = ffi.typeof([[$ ]], mod.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT)
mod.VkRenderPassFragmentDensityMapOffsetEndInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t fragmentDensityOffsetCount;
	const $* pFragmentDensityOffsets;
}]], mod.VkStructureType, mod.VkOffset2D)
mod.VkSubpassFragmentDensityMapOffsetEndInfoQCOM = ffi.typeof([[$ ]], mod.VkRenderPassFragmentDensityMapOffsetEndInfoEXT)
mod.VkCopyMemoryIndirectCommandNV = ffi.typeof([[$ ]], mod.VkCopyMemoryIndirectCommandKHR)
mod.VkCopyMemoryToImageIndirectCommandNV = ffi.typeof([[$ ]], mod.VkCopyMemoryToImageIndirectCommandKHR)
mod.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ indirectCopy;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = ffi.typeof([[$ ]], mod.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR)
mod.PFN_vkCmdCopyMemoryIndirectNV = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkDeviceAddress)
mod.PFN_vkCmdCopyMemoryToImageIndirectNV = ffi.typeof([[void (*)($ , $ , uint32_t , uint32_t , $ , $ , const $*)]], mod.VkCommandBuffer, mod.VkDeviceAddress, mod.VkImage, mod.VkImageLayout, mod.VkImageSubresourceLayers)
ffi.cdef([[void  vkCmdCopyMemoryIndirectNV($ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkDeviceAddress)
ffi.cdef([[void  vkCmdCopyMemoryToImageIndirectNV($ , $ , uint32_t , uint32_t , $ , $ , const $*);]], mod.VkCommandBuffer, mod.VkDeviceAddress, mod.VkImage, mod.VkImageLayout, mod.VkImageSubresourceLayers)
mod.VkMemoryDecompressionMethodFlagBitsEXT = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_EXT = 0x00000001ULL
mod.VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV = 0x00000001ULL
mod.VkMemoryDecompressionMethodFlagBitsNV = ffi.typeof([[$ ]], mod.VkMemoryDecompressionMethodFlagBitsEXT)
mod.VkMemoryDecompressionMethodFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkMemoryDecompressionMethodFlagsNV = ffi.typeof([[$ ]], mod.VkMemoryDecompressionMethodFlagsEXT)
mod.VkDecompressMemoryRegionNV = ffi.typeof([[struct {
	$ srcAddress;
	$ dstAddress;
	$ compressedSize;
	$ decompressedSize;
	$ decompressionMethod;
}]], mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkMemoryDecompressionMethodFlagsNV)
mod.VkPhysicalDeviceMemoryDecompressionFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ memoryDecompression;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMemoryDecompressionFeaturesNV = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMemoryDecompressionFeaturesEXT)
mod.VkPhysicalDeviceMemoryDecompressionPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ decompressionMethods;
	uint64_t maxDecompressionIndirectCount;
}]], mod.VkStructureType, mod.VkMemoryDecompressionMethodFlagsEXT)
mod.VkPhysicalDeviceMemoryDecompressionPropertiesNV = ffi.typeof([[$ ]], mod.VkPhysicalDeviceMemoryDecompressionPropertiesEXT)
mod.PFN_vkCmdDecompressMemoryNV = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkDecompressMemoryRegionNV)
mod.PFN_vkCmdDecompressMemoryIndirectCountNV = ffi.typeof([[void (*)($ , $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkDeviceAddress, mod.VkDeviceAddress)
ffi.cdef([[void  vkCmdDecompressMemoryNV($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkDecompressMemoryRegionNV)
ffi.cdef([[void  vkCmdDecompressMemoryIndirectCountNV($ , $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkDeviceAddress, mod.VkDeviceAddress)
mod.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ deviceGeneratedCompute;
	$ deviceGeneratedComputePipelines;
	$ deviceGeneratedComputeCaptureReplay;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkComputePipelineIndirectBufferInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ deviceAddress;
	$ size;
	$ pipelineDeviceAddressCaptureReplay;
}]], mod.VkStructureType, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceAddress)
mod.VkPipelineIndirectDeviceAddressInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ pipelineBindPoint;
	$ pipeline;
}]], mod.VkStructureType, mod.VkPipelineBindPoint, mod.VkPipeline)
mod.VkBindPipelineIndirectCommandNV = ffi.typeof([[struct {
	$ pipelineAddress;
}]], mod.VkDeviceAddress)
mod.PFN_vkGetPipelineIndirectMemoryRequirementsNV = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkComputePipelineCreateInfo, mod.VkMemoryRequirements2)
mod.PFN_vkCmdUpdatePipelineIndirectBufferNV = ffi.typeof([[void (*)($ , $ , $ )]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipeline)
mod.PFN_vkGetPipelineIndirectDeviceAddressNV = ffi.typeof([[$ (*)($ , const $*)]], mod.VkDeviceAddress, mod.VkDevice, mod.VkPipelineIndirectDeviceAddressInfoNV)
ffi.cdef([[void  vkGetPipelineIndirectMemoryRequirementsNV($ , const $*, $*);]], mod.VkDevice, mod.VkComputePipelineCreateInfo, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkCmdUpdatePipelineIndirectBufferNV($ , $ , $ );]], mod.VkCommandBuffer, mod.VkPipelineBindPoint, mod.VkPipeline)
ffi.cdef([[$  vkGetPipelineIndirectDeviceAddressNV($ , const $*);]], mod.VkDeviceAddress, mod.VkDevice, mod.VkPipelineIndirectDeviceAddressInfoNV)
mod.VkRayTracingLssIndexingModeNV = ffi.typeof([[enum {
	VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV = 0,
	VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV = 1,
	VK_RAY_TRACING_LSS_INDEXING_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkRayTracingLssPrimitiveEndCapsModeNV = ffi.typeof([[enum {
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV = 0,
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV = 1,
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ spheres;
	$ linearSweptSpheres;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkAccelerationStructureGeometryLinearSweptSpheresDataNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ vertexFormat;
	$ vertexData;
	$ vertexStride;
	$ radiusFormat;
	$ radiusData;
	$ radiusStride;
	$ indexType;
	$ indexData;
	$ indexStride;
	$ indexingMode;
	$ endCapsMode;
}]], mod.VkStructureType, mod.VkFormat, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize, mod.VkFormat, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize, mod.VkIndexType, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize, mod.VkRayTracingLssIndexingModeNV, mod.VkRayTracingLssPrimitiveEndCapsModeNV)
mod.VkAccelerationStructureGeometrySpheresDataNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ vertexFormat;
	$ vertexData;
	$ vertexStride;
	$ radiusFormat;
	$ radiusData;
	$ radiusStride;
	$ indexType;
	$ indexData;
	$ indexStride;
}]], mod.VkStructureType, mod.VkFormat, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize, mod.VkFormat, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize, mod.VkIndexType, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize)
mod.VkPhysicalDeviceLinearColorAttachmentFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ linearColorAttachment;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageCompressionControlSwapchain;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkImageViewSampleWeightCreateInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ filterCenter;
	$ filterSize;
	uint32_t numPhases;
}]], mod.VkStructureType, mod.VkOffset2D, mod.VkExtent2D)
mod.VkPhysicalDeviceImageProcessingFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ textureSampleWeighted;
	$ textureBoxFilter;
	$ textureBlockMatch;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceImageProcessingPropertiesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxWeightFilterPhases;
	$ maxWeightFilterDimension;
	$ maxBlockMatchRegion;
	$ maxBoxFilterBlockSize;
}]], mod.VkStructureType, mod.VkExtent2D, mod.VkExtent2D, mod.VkExtent2D)
mod.VkPhysicalDeviceNestedCommandBufferFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ nestedCommandBuffer;
	$ nestedCommandBufferRendering;
	$ nestedCommandBufferSimultaneousUse;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceNestedCommandBufferPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxCommandBufferNestingLevel;
}]], mod.VkStructureType)
mod.VkExternalMemoryAcquireUnmodifiedEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ acquireUnmodifiedMemory;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ extendedDynamicState3TessellationDomainOrigin;
	$ extendedDynamicState3DepthClampEnable;
	$ extendedDynamicState3PolygonMode;
	$ extendedDynamicState3RasterizationSamples;
	$ extendedDynamicState3SampleMask;
	$ extendedDynamicState3AlphaToCoverageEnable;
	$ extendedDynamicState3AlphaToOneEnable;
	$ extendedDynamicState3LogicOpEnable;
	$ extendedDynamicState3ColorBlendEnable;
	$ extendedDynamicState3ColorBlendEquation;
	$ extendedDynamicState3ColorWriteMask;
	$ extendedDynamicState3RasterizationStream;
	$ extendedDynamicState3ConservativeRasterizationMode;
	$ extendedDynamicState3ExtraPrimitiveOverestimationSize;
	$ extendedDynamicState3DepthClipEnable;
	$ extendedDynamicState3SampleLocationsEnable;
	$ extendedDynamicState3ColorBlendAdvanced;
	$ extendedDynamicState3ProvokingVertexMode;
	$ extendedDynamicState3LineRasterizationMode;
	$ extendedDynamicState3LineStippleEnable;
	$ extendedDynamicState3DepthClipNegativeOneToOne;
	$ extendedDynamicState3ViewportWScalingEnable;
	$ extendedDynamicState3ViewportSwizzle;
	$ extendedDynamicState3CoverageToColorEnable;
	$ extendedDynamicState3CoverageToColorLocation;
	$ extendedDynamicState3CoverageModulationMode;
	$ extendedDynamicState3CoverageModulationTableEnable;
	$ extendedDynamicState3CoverageModulationTable;
	$ extendedDynamicState3CoverageReductionMode;
	$ extendedDynamicState3RepresentativeFragmentTestEnable;
	$ extendedDynamicState3ShadingRateImageEnable;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ dynamicPrimitiveTopologyUnrestricted;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkColorBlendEquationEXT = ffi.typeof([[struct {
	$ srcColorBlendFactor;
	$ dstColorBlendFactor;
	$ colorBlendOp;
	$ srcAlphaBlendFactor;
	$ dstAlphaBlendFactor;
	$ alphaBlendOp;
}]], mod.VkBlendFactor, mod.VkBlendFactor, mod.VkBlendOp, mod.VkBlendFactor, mod.VkBlendFactor, mod.VkBlendOp)
mod.VkColorBlendAdvancedEXT = ffi.typeof([[struct {
	$ advancedBlendOp;
	$ srcPremultiplied;
	$ dstPremultiplied;
	$ blendOverlap;
	$ clampResults;
}]], mod.VkBlendOp, mod.VkBool32, mod.VkBool32, mod.VkBlendOverlapEXT, mod.VkBool32)
mod.PFN_vkCmdSetDepthClampEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetPolygonModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkPolygonMode)
mod.PFN_vkCmdSetRasterizationSamplesEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkSampleCountFlagBits)
mod.PFN_vkCmdSetSampleMaskEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkCommandBuffer, mod.VkSampleCountFlagBits, mod.VkSampleMask)
mod.PFN_vkCmdSetAlphaToCoverageEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetAlphaToOneEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetLogicOpEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetColorBlendEnableEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetColorBlendEquationEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkColorBlendEquationEXT)
mod.PFN_vkCmdSetColorWriteMaskEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkColorComponentFlags)
mod.PFN_vkCmdSetTessellationDomainOriginEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkTessellationDomainOrigin)
mod.PFN_vkCmdSetRasterizationStreamEXT = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetConservativeRasterizationModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkConservativeRasterizationModeEXT)
mod.PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT = ffi.typeof([[void (*)($ , float )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetDepthClipEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetSampleLocationsEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetColorBlendAdvancedEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkColorBlendAdvancedEXT)
mod.PFN_vkCmdSetProvokingVertexModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkProvokingVertexModeEXT)
mod.PFN_vkCmdSetLineRasterizationModeEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkLineRasterizationModeEXT)
mod.PFN_vkCmdSetLineStippleEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetDepthClipNegativeOneToOneEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetViewportWScalingEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetViewportSwizzleNV = ffi.typeof([[void (*)($ , uint32_t , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkViewportSwizzleNV)
mod.PFN_vkCmdSetCoverageToColorEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetCoverageToColorLocationNV = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetCoverageModulationModeNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCoverageModulationModeNV)
mod.PFN_vkCmdSetCoverageModulationTableEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetCoverageModulationTableNV = ffi.typeof([[void (*)($ , uint32_t , const float*)]], mod.VkCommandBuffer)
mod.PFN_vkCmdSetShadingRateImageEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetRepresentativeFragmentTestEnableNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkBool32)
mod.PFN_vkCmdSetCoverageReductionModeNV = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkCoverageReductionModeNV)
ffi.cdef([[void  vkCmdSetDepthClampEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetPolygonModeEXT($ , $ );]], mod.VkCommandBuffer, mod.VkPolygonMode)
ffi.cdef([[void  vkCmdSetRasterizationSamplesEXT($ , $ );]], mod.VkCommandBuffer, mod.VkSampleCountFlagBits)
ffi.cdef([[void  vkCmdSetSampleMaskEXT($ , $ , const $*);]], mod.VkCommandBuffer, mod.VkSampleCountFlagBits, mod.VkSampleMask)
ffi.cdef([[void  vkCmdSetAlphaToCoverageEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetAlphaToOneEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetLogicOpEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetColorBlendEnableEXT($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetColorBlendEquationEXT($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkColorBlendEquationEXT)
ffi.cdef([[void  vkCmdSetColorWriteMaskEXT($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkColorComponentFlags)
ffi.cdef([[void  vkCmdSetTessellationDomainOriginEXT($ , $ );]], mod.VkCommandBuffer, mod.VkTessellationDomainOrigin)
ffi.cdef([[void  vkCmdSetRasterizationStreamEXT($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetConservativeRasterizationModeEXT($ , $ );]], mod.VkCommandBuffer, mod.VkConservativeRasterizationModeEXT)
ffi.cdef([[void  vkCmdSetExtraPrimitiveOverestimationSizeEXT($ , float );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetDepthClipEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetSampleLocationsEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetColorBlendAdvancedEXT($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkColorBlendAdvancedEXT)
ffi.cdef([[void  vkCmdSetProvokingVertexModeEXT($ , $ );]], mod.VkCommandBuffer, mod.VkProvokingVertexModeEXT)
ffi.cdef([[void  vkCmdSetLineRasterizationModeEXT($ , $ );]], mod.VkCommandBuffer, mod.VkLineRasterizationModeEXT)
ffi.cdef([[void  vkCmdSetLineStippleEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetDepthClipNegativeOneToOneEXT($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetViewportWScalingEnableNV($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetViewportSwizzleNV($ , uint32_t , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkViewportSwizzleNV)
ffi.cdef([[void  vkCmdSetCoverageToColorEnableNV($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetCoverageToColorLocationNV($ , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetCoverageModulationModeNV($ , $ );]], mod.VkCommandBuffer, mod.VkCoverageModulationModeNV)
ffi.cdef([[void  vkCmdSetCoverageModulationTableEnableNV($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetCoverageModulationTableNV($ , uint32_t , const float*);]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdSetShadingRateImageEnableNV($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetRepresentativeFragmentTestEnableNV($ , $ );]], mod.VkCommandBuffer, mod.VkBool32)
ffi.cdef([[void  vkCmdSetCoverageReductionModeNV($ , $ );]], mod.VkCommandBuffer, mod.VkCoverageReductionModeNV)
mod.VkSubpassMergeStatusEXT = ffi.typeof([[enum {
	VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
	VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
	VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ subpassMergeFeedback;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkRenderPassCreationControlEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ disallowMerging;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkRenderPassCreationFeedbackInfoEXT = ffi.typeof([[struct {
	uint32_t postMergeSubpassCount;
}]])
mod.VkRenderPassCreationFeedbackCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$* pRenderPassFeedback;
}]], mod.VkStructureType, mod.VkRenderPassCreationFeedbackInfoEXT)
mod.VkRenderPassSubpassFeedbackInfoEXT = ffi.typeof([[struct {
	$ subpassMergeStatus;
	char description[256U];
	uint32_t postMergeIndex;
}]], mod.VkSubpassMergeStatusEXT)
mod.VkRenderPassSubpassFeedbackCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$* pSubpassFeedback;
}]], mod.VkStructureType, mod.VkRenderPassSubpassFeedbackInfoEXT)
mod.VkDirectDriverLoadingModeLUNARG = ffi.typeof([[enum {
	VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0,
	VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1,
	VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG = 0x7FFFFFFF,
}]])
mod.VkDirectDriverLoadingFlagsLUNARG = ffi.typeof([[$ ]], mod.VkFlags)
mod.PFN_vkGetInstanceProcAddrLUNARG = ffi.typeof([[$ (*)($ , const char*)]], mod.PFN_vkVoidFunction, mod.VkInstance)
mod.VkDirectDriverLoadingInfoLUNARG = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	$ pfnGetInstanceProcAddr;
}]], mod.VkStructureType, mod.VkDirectDriverLoadingFlagsLUNARG, mod.PFN_vkGetInstanceProcAddrLUNARG)
mod.VkDirectDriverLoadingListLUNARG = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ mode;
	uint32_t driverCount;
	const $* pDrivers;
}]], mod.VkStructureType, mod.VkDirectDriverLoadingModeLUNARG, mod.VkDirectDriverLoadingInfoLUNARG)
mod.VkTensorARM = ffi.typeof([[void*]])
mod.VkTensorViewARM = ffi.typeof([[void*]])
mod.VkTensorTilingARM = ffi.typeof([[enum {
	VK_TENSOR_TILING_OPTIMAL_ARM = 0,
	VK_TENSOR_TILING_LINEAR_ARM = 1,
	VK_TENSOR_TILING_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkTensorCreateFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkTensorCreateFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM = 0x00000001ULL
mod.VK_TENSOR_CREATE_PROTECTED_BIT_ARM = 0x00000002ULL
mod.VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM = 0x00000004ULL
mod.VkTensorViewCreateFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkTensorViewCreateFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM = 0x00000001ULL
mod.VkTensorUsageFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkTensorUsageFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_TENSOR_USAGE_SHADER_BIT_ARM = 0x00000002ULL
mod.VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM = 0x00000004ULL
mod.VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM = 0x00000008ULL
mod.VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM = 0x00000010ULL
mod.VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM = 0x00000020ULL
mod.VkTensorDescriptionARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ tiling;
	$ format;
	uint32_t dimensionCount;
	const int64_t* pDimensions;
	const int64_t* pStrides;
	$ usage;
}]], mod.VkStructureType, mod.VkTensorTilingARM, mod.VkFormat, mod.VkTensorUsageFlagsARM)
mod.VkTensorCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pDescription;
	$ sharingMode;
	uint32_t queueFamilyIndexCount;
	const uint32_t* pQueueFamilyIndices;
}]], mod.VkStructureType, mod.VkTensorCreateFlagsARM, mod.VkTensorDescriptionARM, mod.VkSharingMode)
mod.VkTensorViewCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ tensor;
	$ format;
}]], mod.VkStructureType, mod.VkTensorViewCreateFlagsARM, mod.VkTensorARM, mod.VkFormat)
mod.VkTensorMemoryRequirementsInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ tensor;
}]], mod.VkStructureType, mod.VkTensorARM)
mod.VkBindTensorMemoryInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ tensor;
	$ memory;
	$ memoryOffset;
}]], mod.VkStructureType, mod.VkTensorARM, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.VkWriteDescriptorSetTensorARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t tensorViewCount;
	const $* pTensorViews;
}]], mod.VkStructureType, mod.VkTensorViewARM)
mod.VkTensorFormatPropertiesARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ optimalTilingTensorFeatures;
	$ linearTilingTensorFeatures;
}]], mod.VkStructureType, mod.VkFormatFeatureFlags2, mod.VkFormatFeatureFlags2)
mod.VkPhysicalDeviceTensorPropertiesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxTensorDimensionCount;
	uint64_t maxTensorElements;
	uint64_t maxPerDimensionTensorElements;
	int64_t maxTensorStride;
	uint64_t maxTensorSize;
	uint32_t maxTensorShaderAccessArrayLength;
	uint32_t maxTensorShaderAccessSize;
	uint32_t maxDescriptorSetStorageTensors;
	uint32_t maxPerStageDescriptorSetStorageTensors;
	uint32_t maxDescriptorSetUpdateAfterBindStorageTensors;
	uint32_t maxPerStageDescriptorUpdateAfterBindStorageTensors;
	$ shaderStorageTensorArrayNonUniformIndexingNative;
	$ shaderTensorSupportedStages;
}]], mod.VkStructureType, mod.VkBool32, mod.VkShaderStageFlags)
mod.VkTensorMemoryBarrierARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcStageMask;
	$ srcAccessMask;
	$ dstStageMask;
	$ dstAccessMask;
	uint32_t srcQueueFamilyIndex;
	uint32_t dstQueueFamilyIndex;
	$ tensor;
}]], mod.VkStructureType, mod.VkPipelineStageFlags2, mod.VkAccessFlags2, mod.VkPipelineStageFlags2, mod.VkAccessFlags2, mod.VkTensorARM)
mod.VkTensorDependencyInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t tensorMemoryBarrierCount;
	const $* pTensorMemoryBarriers;
}]], mod.VkStructureType, mod.VkTensorMemoryBarrierARM)
mod.VkPhysicalDeviceTensorFeaturesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ tensorNonPacked;
	$ shaderTensorAccess;
	$ shaderStorageTensorArrayDynamicIndexing;
	$ shaderStorageTensorArrayNonUniformIndexing;
	$ descriptorBindingStorageTensorUpdateAfterBind;
	$ tensors;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDeviceTensorMemoryRequirementsARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const $* pCreateInfo;
}]], mod.VkStructureType, mod.VkTensorCreateInfoARM)
mod.VkTensorCopyARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t dimensionCount;
	const uint64_t* pSrcOffset;
	const uint64_t* pDstOffset;
	const uint64_t* pExtent;
}]], mod.VkStructureType)
mod.VkCopyTensorInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ srcTensor;
	$ dstTensor;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkTensorARM, mod.VkTensorARM, mod.VkTensorCopyARM)
mod.VkMemoryDedicatedAllocateInfoTensorARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ tensor;
}]], mod.VkStructureType, mod.VkTensorARM)
mod.VkPhysicalDeviceExternalTensorInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pDescription;
	$ handleType;
}]], mod.VkStructureType, mod.VkTensorCreateFlagsARM, mod.VkTensorDescriptionARM, mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkExternalTensorPropertiesARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ externalMemoryProperties;
}]], mod.VkStructureType, mod.VkExternalMemoryProperties)
mod.VkExternalMemoryTensorCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleTypes;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlags)
mod.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ descriptorBufferTensorDescriptors;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	size_t tensorCaptureReplayDescriptorDataSize;
	size_t tensorViewCaptureReplayDescriptorDataSize;
	size_t tensorDescriptorSize;
}]], mod.VkStructureType)
mod.VkDescriptorGetTensorInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ tensorView;
}]], mod.VkStructureType, mod.VkTensorViewARM)
mod.VkTensorCaptureDescriptorDataInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ tensor;
}]], mod.VkStructureType, mod.VkTensorARM)
mod.VkTensorViewCaptureDescriptorDataInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ tensorView;
}]], mod.VkStructureType, mod.VkTensorViewARM)
mod.VkFrameBoundaryTensorsARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t tensorCount;
	const $* pTensors;
}]], mod.VkStructureType, mod.VkTensorARM)
mod.PFN_vkCreateTensorARM = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkTensorCreateInfoARM, mod.VkAllocationCallbacks, mod.VkTensorARM)
mod.PFN_vkDestroyTensorARM = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkTensorARM, mod.VkAllocationCallbacks)
mod.PFN_vkCreateTensorViewARM = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkTensorViewCreateInfoARM, mod.VkAllocationCallbacks, mod.VkTensorViewARM)
mod.PFN_vkDestroyTensorViewARM = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkTensorViewARM, mod.VkAllocationCallbacks)
mod.PFN_vkGetTensorMemoryRequirementsARM = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkTensorMemoryRequirementsInfoARM, mod.VkMemoryRequirements2)
mod.PFN_vkBindTensorMemoryARM = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkBindTensorMemoryInfoARM)
mod.PFN_vkGetDeviceTensorMemoryRequirementsARM = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDeviceTensorMemoryRequirementsARM, mod.VkMemoryRequirements2)
mod.PFN_vkCmdCopyTensorARM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyTensorInfoARM)
mod.PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalTensorInfoARM, mod.VkExternalTensorPropertiesARM)
mod.PFN_vkGetTensorOpaqueCaptureDescriptorDataARM = ffi.typeof([[$ (*)($ , const $*, void*)]], mod.VkResult, mod.VkDevice, mod.VkTensorCaptureDescriptorDataInfoARM)
mod.PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM = ffi.typeof([[$ (*)($ , const $*, void*)]], mod.VkResult, mod.VkDevice, mod.VkTensorViewCaptureDescriptorDataInfoARM)
ffi.cdef([[$  vkCreateTensorARM($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkTensorCreateInfoARM, mod.VkAllocationCallbacks, mod.VkTensorARM)
ffi.cdef([[void  vkDestroyTensorARM($ , $ , const $*);]], mod.VkDevice, mod.VkTensorARM, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateTensorViewARM($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkTensorViewCreateInfoARM, mod.VkAllocationCallbacks, mod.VkTensorViewARM)
ffi.cdef([[void  vkDestroyTensorViewARM($ , $ , const $*);]], mod.VkDevice, mod.VkTensorViewARM, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkGetTensorMemoryRequirementsARM($ , const $*, $*);]], mod.VkDevice, mod.VkTensorMemoryRequirementsInfoARM, mod.VkMemoryRequirements2)
ffi.cdef([[$  vkBindTensorMemoryARM($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkBindTensorMemoryInfoARM)
ffi.cdef([[void  vkGetDeviceTensorMemoryRequirementsARM($ , const $*, $*);]], mod.VkDevice, mod.VkDeviceTensorMemoryRequirementsARM, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkCmdCopyTensorARM($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyTensorInfoARM)
ffi.cdef([[void  vkGetPhysicalDeviceExternalTensorPropertiesARM($ , const $*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceExternalTensorInfoARM, mod.VkExternalTensorPropertiesARM)
ffi.cdef([[$  vkGetTensorOpaqueCaptureDescriptorDataARM($ , const $*, void*);]], mod.VkResult, mod.VkDevice, mod.VkTensorCaptureDescriptorDataInfoARM)
ffi.cdef([[$  vkGetTensorViewOpaqueCaptureDescriptorDataARM($ , const $*, void*);]], mod.VkResult, mod.VkDevice, mod.VkTensorViewCaptureDescriptorDataInfoARM)
mod.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderModuleIdentifier;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint8_t shaderModuleIdentifierAlgorithmUUID[16U];
}]], mod.VkStructureType)
mod.VkPipelineShaderStageModuleIdentifierCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t identifierSize;
	const uint8_t* pIdentifier;
}]], mod.VkStructureType)
mod.VkShaderModuleIdentifierEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t identifierSize;
	uint8_t identifier[32U];
}]], mod.VkStructureType)
mod.PFN_vkGetShaderModuleIdentifierEXT = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkShaderModule, mod.VkShaderModuleIdentifierEXT)
mod.PFN_vkGetShaderModuleCreateInfoIdentifierEXT = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkShaderModuleCreateInfo, mod.VkShaderModuleIdentifierEXT)
ffi.cdef([[void  vkGetShaderModuleIdentifierEXT($ , $ , $*);]], mod.VkDevice, mod.VkShaderModule, mod.VkShaderModuleIdentifierEXT)
ffi.cdef([[void  vkGetShaderModuleCreateInfoIdentifierEXT($ , const $*, $*);]], mod.VkDevice, mod.VkShaderModuleCreateInfo, mod.VkShaderModuleIdentifierEXT)
mod.VkOpticalFlowSessionNV = ffi.typeof([[void*]])
mod.VkOpticalFlowPerformanceLevelNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowSessionBindingPointNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowGridSizeFlagBitsNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowGridSizeFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkOpticalFlowUsageFlagBitsNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 0x00000010,
	VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowUsageFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkOpticalFlowSessionCreateFlagBitsNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 0x00000010,
	VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowSessionCreateFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkOpticalFlowExecuteFlagBitsNV = ffi.typeof([[enum {
	VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOpticalFlowExecuteFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceOpticalFlowFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ opticalFlow;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceOpticalFlowPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ supportedOutputGridSizes;
	$ supportedHintGridSizes;
	$ hintSupported;
	$ costSupported;
	$ bidirectionalFlowSupported;
	$ globalFlowSupported;
	uint32_t minWidth;
	uint32_t minHeight;
	uint32_t maxWidth;
	uint32_t maxHeight;
	uint32_t maxNumRegionsOfInterest;
}]], mod.VkStructureType, mod.VkOpticalFlowGridSizeFlagsNV, mod.VkOpticalFlowGridSizeFlagsNV, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkOpticalFlowImageFormatInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ usage;
}]], mod.VkStructureType, mod.VkOpticalFlowUsageFlagsNV)
mod.VkOpticalFlowImageFormatPropertiesNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ format;
}]], mod.VkStructureType, mod.VkFormat)
mod.VkOpticalFlowSessionCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t width;
	uint32_t height;
	$ imageFormat;
	$ flowVectorFormat;
	$ costFormat;
	$ outputGridSize;
	$ hintGridSize;
	$ performanceLevel;
	$ flags;
}]], mod.VkStructureType, mod.VkFormat, mod.VkFormat, mod.VkFormat, mod.VkOpticalFlowGridSizeFlagsNV, mod.VkOpticalFlowGridSizeFlagsNV, mod.VkOpticalFlowPerformanceLevelNV, mod.VkOpticalFlowSessionCreateFlagsNV)
mod.VkOpticalFlowSessionCreatePrivateDataInfoNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t id;
	uint32_t size;
	const void* pPrivateData;
}]], mod.VkStructureType)
mod.VkOpticalFlowExecuteInfoNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkOpticalFlowExecuteFlagsNV, mod.VkRect2D)
mod.PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV = ffi.typeof([[$ (*)($ , const $*, uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkOpticalFlowImageFormatInfoNV, mod.VkOpticalFlowImageFormatPropertiesNV)
mod.PFN_vkCreateOpticalFlowSessionNV = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkOpticalFlowSessionCreateInfoNV, mod.VkAllocationCallbacks, mod.VkOpticalFlowSessionNV)
mod.PFN_vkDestroyOpticalFlowSessionNV = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkOpticalFlowSessionNV, mod.VkAllocationCallbacks)
mod.PFN_vkBindOpticalFlowSessionImageNV = ffi.typeof([[$ (*)($ , $ , $ , $ , $ )]], mod.VkResult, mod.VkDevice, mod.VkOpticalFlowSessionNV, mod.VkOpticalFlowSessionBindingPointNV, mod.VkImageView, mod.VkImageLayout)
mod.PFN_vkCmdOpticalFlowExecuteNV = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkCommandBuffer, mod.VkOpticalFlowSessionNV, mod.VkOpticalFlowExecuteInfoNV)
ffi.cdef([[$  vkGetPhysicalDeviceOpticalFlowImageFormatsNV($ , const $*, uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkOpticalFlowImageFormatInfoNV, mod.VkOpticalFlowImageFormatPropertiesNV)
ffi.cdef([[$  vkCreateOpticalFlowSessionNV($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkOpticalFlowSessionCreateInfoNV, mod.VkAllocationCallbacks, mod.VkOpticalFlowSessionNV)
ffi.cdef([[void  vkDestroyOpticalFlowSessionNV($ , $ , const $*);]], mod.VkDevice, mod.VkOpticalFlowSessionNV, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkBindOpticalFlowSessionImageNV($ , $ , $ , $ , $ );]], mod.VkResult, mod.VkDevice, mod.VkOpticalFlowSessionNV, mod.VkOpticalFlowSessionBindingPointNV, mod.VkImageView, mod.VkImageLayout)
ffi.cdef([[void  vkCmdOpticalFlowExecuteNV($ , $ , const $*);]], mod.VkCommandBuffer, mod.VkOpticalFlowSessionNV, mod.VkOpticalFlowExecuteInfoNV)
mod.VkPhysicalDeviceLegacyDitheringFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ legacyDithering;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = ffi.typeof([[$ ]], mod.VkPhysicalDevicePipelineProtectedAccessFeatures)
mod.VkAntiLagModeAMD = ffi.typeof([[enum {
	VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD = 0,
	VK_ANTI_LAG_MODE_ON_AMD = 1,
	VK_ANTI_LAG_MODE_OFF_AMD = 2,
	VK_ANTI_LAG_MODE_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkAntiLagStageAMD = ffi.typeof([[enum {
	VK_ANTI_LAG_STAGE_INPUT_AMD = 0,
	VK_ANTI_LAG_STAGE_PRESENT_AMD = 1,
	VK_ANTI_LAG_STAGE_MAX_ENUM_AMD = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceAntiLagFeaturesAMD = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ antiLag;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkAntiLagPresentationInfoAMD = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ stage;
	uint64_t frameIndex;
}]], mod.VkStructureType, mod.VkAntiLagStageAMD)
mod.VkAntiLagDataAMD = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ mode;
	uint32_t maxFPS;
	const $* pPresentationInfo;
}]], mod.VkStructureType, mod.VkAntiLagModeAMD, mod.VkAntiLagPresentationInfoAMD)
mod.PFN_vkAntiLagUpdateAMD = ffi.typeof([[void (*)($ , const $*)]], mod.VkDevice, mod.VkAntiLagDataAMD)
ffi.cdef([[void  vkAntiLagUpdateAMD($ , const $*);]], mod.VkDevice, mod.VkAntiLagDataAMD)
mod.VkShaderEXT = ffi.typeof([[void*]])
mod.VkShaderCodeTypeEXT = ffi.typeof([[enum {
	VK_SHADER_CODE_TYPE_BINARY_EXT = 0,
	VK_SHADER_CODE_TYPE_SPIRV_EXT = 1,
	VK_SHADER_CODE_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkDepthClampModeEXT = ffi.typeof([[enum {
	VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT = 0,
	VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT = 1,
	VK_DEPTH_CLAMP_MODE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkShaderCreateFlagBitsEXT = ffi.typeof([[enum {
	VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = 0x00000001,
	VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x00000002,
	VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x00000004,
	VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = 0x00000008,
	VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = 0x00000010,
	VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 0x00000020,
	VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00000040,
	VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT = 0x00000080,
	VK_SHADER_CREATE_64_BIT_INDEXING_BIT_EXT = 0x00008000,
	VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkShaderCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceShaderObjectFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderObject;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderObjectPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint8_t shaderBinaryUUID[16U];
	uint32_t shaderBinaryVersion;
}]], mod.VkStructureType)
mod.VkShaderCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ stage;
	$ nextStage;
	$ codeType;
	size_t codeSize;
	const void* pCode;
	const char* pName;
	uint32_t setLayoutCount;
	const $* pSetLayouts;
	uint32_t pushConstantRangeCount;
	const $* pPushConstantRanges;
	const $* pSpecializationInfo;
}]], mod.VkStructureType, mod.VkShaderCreateFlagsEXT, mod.VkShaderStageFlagBits, mod.VkShaderStageFlags, mod.VkShaderCodeTypeEXT, mod.VkDescriptorSetLayout, mod.VkPushConstantRange, mod.VkSpecializationInfo)
mod.VkShaderRequiredSubgroupSizeCreateInfoEXT = ffi.typeof([[$ ]], mod.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo)
mod.VkDepthClampRangeEXT = ffi.typeof([[struct {
	float minDepthClamp;
	float maxDepthClamp;
}]])
mod.PFN_vkCreateShadersEXT = ffi.typeof([[$ (*)($ , uint32_t , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkShaderCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkShaderEXT)
mod.PFN_vkDestroyShaderEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkShaderEXT, mod.VkAllocationCallbacks)
mod.PFN_vkGetShaderBinaryDataEXT = ffi.typeof([[$ (*)($ , $ , size_t*, void*)]], mod.VkResult, mod.VkDevice, mod.VkShaderEXT)
mod.PFN_vkCmdBindShadersEXT = ffi.typeof([[void (*)($ , uint32_t , const $*, const $*)]], mod.VkCommandBuffer, mod.VkShaderStageFlagBits, mod.VkShaderEXT)
mod.PFN_vkCmdSetDepthClampRangeEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkCommandBuffer, mod.VkDepthClampModeEXT, mod.VkDepthClampRangeEXT)
ffi.cdef([[$  vkCreateShadersEXT($ , uint32_t , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkShaderCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkShaderEXT)
ffi.cdef([[void  vkDestroyShaderEXT($ , $ , const $*);]], mod.VkDevice, mod.VkShaderEXT, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkGetShaderBinaryDataEXT($ , $ , size_t*, void*);]], mod.VkResult, mod.VkDevice, mod.VkShaderEXT)
ffi.cdef([[void  vkCmdBindShadersEXT($ , uint32_t , const $*, const $*);]], mod.VkCommandBuffer, mod.VkShaderStageFlagBits, mod.VkShaderEXT)
ffi.cdef([[void  vkCmdSetDepthClampRangeEXT($ , $ , const $*);]], mod.VkCommandBuffer, mod.VkDepthClampModeEXT, mod.VkDepthClampRangeEXT)
mod.VkPhysicalDeviceTilePropertiesFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ tileProperties;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkTilePropertiesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ tileSize;
	$ apronSize;
	$ origin;
}]], mod.VkStructureType, mod.VkExtent3D, mod.VkExtent2D, mod.VkOffset2D)
mod.PFN_vkGetFramebufferTilePropertiesQCOM = ffi.typeof([[$ (*)($ , $ , uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkFramebuffer, mod.VkTilePropertiesQCOM)
mod.PFN_vkGetDynamicRenderingTilePropertiesQCOM = ffi.typeof([[$ (*)($ , const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkRenderingInfo, mod.VkTilePropertiesQCOM)
ffi.cdef([[$  vkGetFramebufferTilePropertiesQCOM($ , $ , uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkFramebuffer, mod.VkTilePropertiesQCOM)
ffi.cdef([[$  vkGetDynamicRenderingTilePropertiesQCOM($ , const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkRenderingInfo, mod.VkTilePropertiesQCOM)
mod.VkPhysicalDeviceAmigoProfilingFeaturesSEC = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ amigoProfiling;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkAmigoProfilingSubmitInfoSEC = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t firstDrawTimestamp;
	uint64_t swapBufferTimestamp;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ multiviewPerViewViewports;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkRayTracingInvocationReorderModeNV = ffi.typeof([[enum {
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0,
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1,
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rayTracingInvocationReorderReorderingHint;
}]], mod.VkStructureType, mod.VkRayTracingInvocationReorderModeNV)
mod.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rayTracingInvocationReorder;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkCooperativeVectorMatrixLayoutNV = ffi.typeof([[enum {
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV = 0,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV = 1,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV = 2,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV = 3,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceCooperativeVectorPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cooperativeVectorSupportedStages;
	$ cooperativeVectorTrainingFloat16Accumulation;
	$ cooperativeVectorTrainingFloat32Accumulation;
	uint32_t maxCooperativeVectorComponents;
}]], mod.VkStructureType, mod.VkShaderStageFlags, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceCooperativeVectorFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cooperativeVector;
	$ cooperativeVectorTraining;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkCooperativeVectorPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ inputType;
	$ inputInterpretation;
	$ matrixInterpretation;
	$ biasInterpretation;
	$ resultType;
	$ transpose;
}]], mod.VkStructureType, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkBool32)
mod.VkConvertCooperativeVectorMatrixInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	size_t srcSize;
	$ srcData;
	size_t* pDstSize;
	$ dstData;
	$ srcComponentType;
	$ dstComponentType;
	uint32_t numRows;
	uint32_t numColumns;
	$ srcLayout;
	size_t srcStride;
	$ dstLayout;
	size_t dstStride;
}]], mod.VkStructureType, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceOrHostAddressKHR, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkCooperativeVectorMatrixLayoutNV, mod.VkCooperativeVectorMatrixLayoutNV)
mod.PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkCooperativeVectorPropertiesNV)
mod.PFN_vkConvertCooperativeVectorMatrixNV = ffi.typeof([[$ (*)($ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkConvertCooperativeVectorMatrixInfoNV)
mod.PFN_vkCmdConvertCooperativeVectorMatrixNV = ffi.typeof([[void (*)($ , uint32_t , const $*)]], mod.VkCommandBuffer, mod.VkConvertCooperativeVectorMatrixInfoNV)
ffi.cdef([[$  vkGetPhysicalDeviceCooperativeVectorPropertiesNV($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkCooperativeVectorPropertiesNV)
ffi.cdef([[$  vkConvertCooperativeVectorMatrixNV($ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkConvertCooperativeVectorMatrixInfoNV)
ffi.cdef([[void  vkCmdConvertCooperativeVectorMatrixNV($ , uint32_t , const $*);]], mod.VkCommandBuffer, mod.VkConvertCooperativeVectorMatrixInfoNV)
mod.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ extendedSparseAddressSpace;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ extendedSparseAddressSpaceSize;
	$ extendedSparseImageUsageFlags;
	$ extendedSparseBufferUsageFlags;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkImageUsageFlags, mod.VkBufferUsageFlags)
mod.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ legacyVertexAttributes;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ nativeUnalignedPerformance;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkLayerSettingTypeEXT = ffi.typeof([[enum {
	VK_LAYER_SETTING_TYPE_BOOL32_EXT = 0,
	VK_LAYER_SETTING_TYPE_INT32_EXT = 1,
	VK_LAYER_SETTING_TYPE_INT64_EXT = 2,
	VK_LAYER_SETTING_TYPE_UINT32_EXT = 3,
	VK_LAYER_SETTING_TYPE_UINT64_EXT = 4,
	VK_LAYER_SETTING_TYPE_FLOAT32_EXT = 5,
	VK_LAYER_SETTING_TYPE_FLOAT64_EXT = 6,
	VK_LAYER_SETTING_TYPE_STRING_EXT = 7,
	VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkLayerSettingEXT = ffi.typeof([[struct {
	const char* pLayerName;
	const char* pSettingName;
	$ type;
	uint32_t valueCount;
	const void* pValues;
}]], mod.VkLayerSettingTypeEXT)
mod.VkLayerSettingsCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t settingCount;
	const $* pSettings;
}]], mod.VkStructureType, mod.VkLayerSettingEXT)
mod.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderCoreBuiltins;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint64_t shaderCoreMask;
	uint32_t shaderCoreCount;
	uint32_t shaderWarpsPerCore;
}]], mod.VkStructureType)
mod.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineLibraryGroupHandles;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ dynamicRenderingUnusedAttachments;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkLatencyMarkerNV = ffi.typeof([[enum {
	VK_LATENCY_MARKER_SIMULATION_START_NV = 0,
	VK_LATENCY_MARKER_SIMULATION_END_NV = 1,
	VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = 2,
	VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = 3,
	VK_LATENCY_MARKER_PRESENT_START_NV = 4,
	VK_LATENCY_MARKER_PRESENT_END_NV = 5,
	VK_LATENCY_MARKER_INPUT_SAMPLE_NV = 6,
	VK_LATENCY_MARKER_TRIGGER_FLASH_NV = 7,
	VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = 8,
	VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = 9,
	VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = 10,
	VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = 11,
	VK_LATENCY_MARKER_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkOutOfBandQueueTypeNV = ffi.typeof([[enum {
	VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = 0,
	VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = 1,
	VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkLatencySleepModeInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ lowLatencyMode;
	$ lowLatencyBoost;
	uint32_t minimumIntervalUs;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkLatencySleepInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ signalSemaphore;
	uint64_t value;
}]], mod.VkStructureType, mod.VkSemaphore)
mod.VkSetLatencyMarkerInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t presentID;
	$ marker;
}]], mod.VkStructureType, mod.VkLatencyMarkerNV)
mod.VkLatencyTimingsFrameReportNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t presentID;
	uint64_t inputSampleTimeUs;
	uint64_t simStartTimeUs;
	uint64_t simEndTimeUs;
	uint64_t renderSubmitStartTimeUs;
	uint64_t renderSubmitEndTimeUs;
	uint64_t presentStartTimeUs;
	uint64_t presentEndTimeUs;
	uint64_t driverStartTimeUs;
	uint64_t driverEndTimeUs;
	uint64_t osRenderQueueStartTimeUs;
	uint64_t osRenderQueueEndTimeUs;
	uint64_t gpuRenderStartTimeUs;
	uint64_t gpuRenderEndTimeUs;
}]], mod.VkStructureType)
mod.VkGetLatencyMarkerInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t timingCount;
	$* pTimings;
}]], mod.VkStructureType, mod.VkLatencyTimingsFrameReportNV)
mod.VkLatencySubmissionPresentIdNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint64_t presentID;
}]], mod.VkStructureType)
mod.VkSwapchainLatencyCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ latencyModeEnable;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkOutOfBandQueueTypeInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ queueType;
}]], mod.VkStructureType, mod.VkOutOfBandQueueTypeNV)
mod.VkLatencySurfaceCapabilitiesNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t presentModeCount;
	$* pPresentModes;
}]], mod.VkStructureType, mod.VkPresentModeKHR)
mod.PFN_vkSetLatencySleepModeNV = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkLatencySleepModeInfoNV)
mod.PFN_vkLatencySleepNV = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkLatencySleepInfoNV)
mod.PFN_vkSetLatencyMarkerNV = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkSetLatencyMarkerInfoNV)
mod.PFN_vkGetLatencyTimingsNV = ffi.typeof([[void (*)($ , $ , $*)]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkGetLatencyMarkerInfoNV)
mod.PFN_vkQueueNotifyOutOfBandNV = ffi.typeof([[void (*)($ , const $*)]], mod.VkQueue, mod.VkOutOfBandQueueTypeInfoNV)
ffi.cdef([[$  vkSetLatencySleepModeNV($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkLatencySleepModeInfoNV)
ffi.cdef([[$  vkLatencySleepNV($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkSwapchainKHR, mod.VkLatencySleepInfoNV)
ffi.cdef([[void  vkSetLatencyMarkerNV($ , $ , const $*);]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkSetLatencyMarkerInfoNV)
ffi.cdef([[void  vkGetLatencyTimingsNV($ , $ , $*);]], mod.VkDevice, mod.VkSwapchainKHR, mod.VkGetLatencyMarkerInfoNV)
ffi.cdef([[void  vkQueueNotifyOutOfBandNV($ , const $*);]], mod.VkQueue, mod.VkOutOfBandQueueTypeInfoNV)
mod.VkDataGraphPipelineSessionARM = ffi.typeof([[void*]])
mod.VkDataGraphPipelineSessionBindPointARM = ffi.typeof([[enum {
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkDataGraphPipelineSessionBindPointTypeARM = ffi.typeof([[enum {
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkDataGraphPipelinePropertyARM = ffi.typeof([[enum {
	VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM = 1,
	VK_DATA_GRAPH_PIPELINE_PROPERTY_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceDataGraphProcessingEngineTypeARM = ffi.typeof([[enum {
	VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM = 0,
	VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceDataGraphOperationTypeARM = ffi.typeof([[enum {
	VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM = 0,
	VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_MAX_ENUM_ARM = 0x7FFFFFFF,
}]])
mod.VkDataGraphPipelineSessionCreateFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkDataGraphPipelineSessionCreateFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM = 0x00000001ULL
mod.VkDataGraphPipelineDispatchFlagsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkDataGraphPipelineDispatchFlagBitsARM = ffi.typeof([[$ ]], mod.VkFlags64)
mod.VkPhysicalDeviceDataGraphFeaturesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ dataGraph;
	$ dataGraphUpdateAfterBind;
	$ dataGraphSpecializationConstants;
	$ dataGraphDescriptorBuffer;
	$ dataGraphShaderModule;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDataGraphPipelineConstantARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t id;
	const void* pConstantData;
}]], mod.VkStructureType)
mod.VkDataGraphPipelineResourceInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t descriptorSet;
	uint32_t binding;
	uint32_t arrayElement;
}]], mod.VkStructureType)
mod.VkDataGraphPipelineCompilerControlCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const char* pVendorOptions;
}]], mod.VkStructureType)
mod.VkDataGraphPipelineCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ layout;
	uint32_t resourceInfoCount;
	const $* pResourceInfos;
}]], mod.VkStructureType, mod.VkPipelineCreateFlags2KHR, mod.VkPipelineLayout, mod.VkDataGraphPipelineResourceInfoARM)
mod.VkDataGraphPipelineShaderModuleCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ module;
	const char* pName;
	const $* pSpecializationInfo;
	uint32_t constantCount;
	const $* pConstants;
}]], mod.VkStructureType, mod.VkShaderModule, mod.VkSpecializationInfo, mod.VkDataGraphPipelineConstantARM)
mod.VkDataGraphPipelineSessionCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ dataGraphPipeline;
}]], mod.VkStructureType, mod.VkDataGraphPipelineSessionCreateFlagsARM, mod.VkPipeline)
mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ session;
}]], mod.VkStructureType, mod.VkDataGraphPipelineSessionARM)
mod.VkDataGraphPipelineSessionBindPointRequirementARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ bindPoint;
	$ bindPointType;
	uint32_t numObjects;
}]], mod.VkStructureType, mod.VkDataGraphPipelineSessionBindPointARM, mod.VkDataGraphPipelineSessionBindPointTypeARM)
mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ session;
	$ bindPoint;
	uint32_t objectIndex;
}]], mod.VkStructureType, mod.VkDataGraphPipelineSessionARM, mod.VkDataGraphPipelineSessionBindPointARM)
mod.VkBindDataGraphPipelineSessionMemoryInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ session;
	$ bindPoint;
	uint32_t objectIndex;
	$ memory;
	$ memoryOffset;
}]], mod.VkStructureType, mod.VkDataGraphPipelineSessionARM, mod.VkDataGraphPipelineSessionBindPointARM, mod.VkDeviceMemory, mod.VkDeviceSize)
mod.VkDataGraphPipelineInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ dataGraphPipeline;
}]], mod.VkStructureType, mod.VkPipeline)
mod.VkDataGraphPipelinePropertyQueryResultARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ property;
	$ isText;
	size_t dataSize;
	void* pData;
}]], mod.VkStructureType, mod.VkDataGraphPipelinePropertyARM, mod.VkBool32)
mod.VkDataGraphPipelineIdentifierCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t identifierSize;
	const uint8_t* pIdentifier;
}]], mod.VkStructureType)
mod.VkDataGraphPipelineDispatchInfoARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
}]], mod.VkStructureType, mod.VkDataGraphPipelineDispatchFlagsARM)
mod.VkPhysicalDeviceDataGraphProcessingEngineARM = ffi.typeof([[struct {
	$ type;
	$ isForeign;
}]], mod.VkPhysicalDeviceDataGraphProcessingEngineTypeARM, mod.VkBool32)
mod.VkPhysicalDeviceDataGraphOperationSupportARM = ffi.typeof([[struct {
	$ operationType;
	char name[128U];
	uint32_t version;
}]], mod.VkPhysicalDeviceDataGraphOperationTypeARM)
mod.VkQueueFamilyDataGraphPropertiesARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ engine;
	$ operation;
}]], mod.VkStructureType, mod.VkPhysicalDeviceDataGraphProcessingEngineARM, mod.VkPhysicalDeviceDataGraphOperationSupportARM)
mod.VkDataGraphProcessingEngineCreateInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t processingEngineCount;
	$* pProcessingEngines;
}]], mod.VkStructureType, mod.VkPhysicalDeviceDataGraphProcessingEngineARM)
mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t queueFamilyIndex;
	$ engineType;
}]], mod.VkStructureType, mod.VkPhysicalDeviceDataGraphProcessingEngineTypeARM)
mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ foreignSemaphoreHandleTypes;
	$ foreignMemoryHandleTypes;
}]], mod.VkStructureType, mod.VkExternalSemaphoreHandleTypeFlags, mod.VkExternalMemoryHandleTypeFlags)
mod.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t dimension;
	uint32_t zeroCount;
	uint32_t groupSize;
}]], mod.VkStructureType)
mod.PFN_vkCreateDataGraphPipelinesARM = ffi.typeof([[$ (*)($ , $ , $ , uint32_t , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkPipelineCache, mod.VkDataGraphPipelineCreateInfoARM, mod.VkAllocationCallbacks, mod.VkPipeline)
mod.PFN_vkCreateDataGraphPipelineSessionARM = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDataGraphPipelineSessionCreateInfoARM, mod.VkAllocationCallbacks, mod.VkDataGraphPipelineSessionARM)
mod.PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM = ffi.typeof([[$ (*)($ , const $*, uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM, mod.VkDataGraphPipelineSessionBindPointRequirementARM)
mod.PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM, mod.VkMemoryRequirements2)
mod.PFN_vkBindDataGraphPipelineSessionMemoryARM = ffi.typeof([[$ (*)($ , uint32_t , const $*)]], mod.VkResult, mod.VkDevice, mod.VkBindDataGraphPipelineSessionMemoryInfoARM)
mod.PFN_vkDestroyDataGraphPipelineSessionARM = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkDataGraphPipelineSessionARM, mod.VkAllocationCallbacks)
mod.PFN_vkCmdDispatchDataGraphARM = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkCommandBuffer, mod.VkDataGraphPipelineSessionARM, mod.VkDataGraphPipelineDispatchInfoARM)
mod.PFN_vkGetDataGraphPipelineAvailablePropertiesARM = ffi.typeof([[$ (*)($ , const $*, uint32_t*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDataGraphPipelineInfoARM, mod.VkDataGraphPipelinePropertyARM)
mod.PFN_vkGetDataGraphPipelinePropertiesARM = ffi.typeof([[$ (*)($ , const $*, uint32_t , $*)]], mod.VkResult, mod.VkDevice, mod.VkDataGraphPipelineInfoARM, mod.VkDataGraphPipelinePropertyQueryResultARM)
mod.PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = ffi.typeof([[$ (*)($ , uint32_t , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkQueueFamilyDataGraphPropertiesARM)
mod.PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM)
ffi.cdef([[$  vkCreateDataGraphPipelinesARM($ , $ , $ , uint32_t , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkPipelineCache, mod.VkDataGraphPipelineCreateInfoARM, mod.VkAllocationCallbacks, mod.VkPipeline)
ffi.cdef([[$  vkCreateDataGraphPipelineSessionARM($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDataGraphPipelineSessionCreateInfoARM, mod.VkAllocationCallbacks, mod.VkDataGraphPipelineSessionARM)
ffi.cdef([[$  vkGetDataGraphPipelineSessionBindPointRequirementsARM($ , const $*, uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDataGraphPipelineSessionBindPointRequirementsInfoARM, mod.VkDataGraphPipelineSessionBindPointRequirementARM)
ffi.cdef([[void  vkGetDataGraphPipelineSessionMemoryRequirementsARM($ , const $*, $*);]], mod.VkDevice, mod.VkDataGraphPipelineSessionMemoryRequirementsInfoARM, mod.VkMemoryRequirements2)
ffi.cdef([[$  vkBindDataGraphPipelineSessionMemoryARM($ , uint32_t , const $*);]], mod.VkResult, mod.VkDevice, mod.VkBindDataGraphPipelineSessionMemoryInfoARM)
ffi.cdef([[void  vkDestroyDataGraphPipelineSessionARM($ , $ , const $*);]], mod.VkDevice, mod.VkDataGraphPipelineSessionARM, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkCmdDispatchDataGraphARM($ , $ , const $*);]], mod.VkCommandBuffer, mod.VkDataGraphPipelineSessionARM, mod.VkDataGraphPipelineDispatchInfoARM)
ffi.cdef([[$  vkGetDataGraphPipelineAvailablePropertiesARM($ , const $*, uint32_t*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDataGraphPipelineInfoARM, mod.VkDataGraphPipelinePropertyARM)
ffi.cdef([[$  vkGetDataGraphPipelinePropertiesARM($ , const $*, uint32_t , $*);]], mod.VkResult, mod.VkDevice, mod.VkDataGraphPipelineInfoARM, mod.VkDataGraphPipelinePropertyQueryResultARM)
ffi.cdef([[$  vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM($ , uint32_t , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkQueueFamilyDataGraphPropertiesARM)
ffi.cdef([[void  vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM($ , const $*, $*);]], mod.VkPhysicalDevice, mod.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, mod.VkQueueFamilyDataGraphProcessingEnginePropertiesARM)
mod.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ multiviewPerViewRenderAreas;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t perViewRenderAreaCount;
	const $* pPerViewRenderAreas;
}]], mod.VkStructureType, mod.VkRect2D)
mod.VkPhysicalDevicePerStageDescriptorSetFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ perStageDescriptorSet;
	$ dynamicPipelineLayout;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkBlockMatchWindowCompareModeQCOM = ffi.typeof([[enum {
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = 0,
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = 1,
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceImageProcessing2FeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ textureBlockMatch2;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceImageProcessing2PropertiesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ maxBlockMatchWindow;
}]], mod.VkStructureType, mod.VkExtent2D)
mod.VkSamplerBlockMatchWindowCreateInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ windowExtent;
	$ windowCompareMode;
}]], mod.VkStructureType, mod.VkExtent2D, mod.VkBlockMatchWindowCompareModeQCOM)
mod.VkCubicFilterWeightsQCOM = ffi.typeof([[enum {
	VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = 0,
	VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = 1,
	VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = 2,
	VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = 3,
	VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceCubicWeightsFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ selectableCubicWeights;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSamplerCubicWeightsCreateInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ cubicWeights;
}]], mod.VkStructureType, mod.VkCubicFilterWeightsQCOM)
mod.VkBlitImageCubicWeightsInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ cubicWeights;
}]], mod.VkStructureType, mod.VkCubicFilterWeightsQCOM)
mod.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ ycbcrDegamma;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ enableYDegamma;
	$ enableCbCrDegamma;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceCubicClampFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cubicRangeClamp;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ attachmentFeedbackLoopDynamicState;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT = ffi.typeof([[void (*)($ , $ )]], mod.VkCommandBuffer, mod.VkImageAspectFlags)
ffi.cdef([[void  vkCmdSetAttachmentFeedbackLoopEnableEXT($ , $ );]], mod.VkCommandBuffer, mod.VkImageAspectFlags)
mod.VkLayeredDriverUnderlyingApiMSFT = ffi.typeof([[enum {
	VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0,
	VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1,
	VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT = 0x7FFFFFFF,
}]])
mod.VkPhysicalDeviceLayeredDriverPropertiesMSFT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ underlyingAPI;
}]], mod.VkStructureType, mod.VkLayeredDriverUnderlyingApiMSFT)
mod.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ descriptorPoolOverallocation;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ tileMemoryHeap;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ queueSubmitBoundary;
	$ tileBufferTransfers;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkTileMemoryRequirementsQCOM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ size;
	$ alignment;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkTileMemoryBindInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ memory;
}]], mod.VkStructureType, mod.VkDeviceMemory)
mod.VkTileMemorySizeInfoQCOM = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ size;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.PFN_vkCmdBindTileMemoryQCOM = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkTileMemoryBindInfoQCOM)
ffi.cdef([[void  vkCmdBindTileMemoryQCOM($ , const $*);]], mod.VkCommandBuffer, mod.VkTileMemoryBindInfoQCOM)
mod.VkDecompressMemoryRegionEXT = ffi.typeof([[struct {
	$ srcAddress;
	$ dstAddress;
	$ compressedSize;
	$ decompressedSize;
}]], mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkDecompressMemoryInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ decompressionMethod;
	uint32_t regionCount;
	const $* pRegions;
}]], mod.VkStructureType, mod.VkMemoryDecompressionMethodFlagsEXT, mod.VkDecompressMemoryRegionEXT)
mod.PFN_vkCmdDecompressMemoryEXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkDecompressMemoryInfoEXT)
mod.PFN_vkCmdDecompressMemoryIndirectCountEXT = ffi.typeof([[void (*)($ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkMemoryDecompressionMethodFlagsEXT, mod.VkDeviceAddress, mod.VkDeviceAddress)
ffi.cdef([[void  vkCmdDecompressMemoryEXT($ , const $*);]], mod.VkCommandBuffer, mod.VkDecompressMemoryInfoEXT)
ffi.cdef([[void  vkCmdDecompressMemoryIndirectCountEXT($ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkMemoryDecompressionMethodFlagsEXT, mod.VkDeviceAddress, mod.VkDeviceAddress)
mod.VkDisplaySurfaceStereoTypeNV = ffi.typeof([[enum {
	VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV = 0,
	VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV = 1,
	VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV = 2,
	VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV = 3,
	VK_DISPLAY_SURFACE_STEREO_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkDisplaySurfaceStereoCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ stereoType;
}]], mod.VkStructureType, mod.VkDisplaySurfaceStereoTypeNV)
mod.VkDisplayModeStereoPropertiesNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ hdmi3DSupported;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceRawAccessChainsFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderRawAccessChains;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkExternalComputeQueueNV = ffi.typeof([[void*]])
mod.VkExternalComputeQueueDeviceCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t reservedExternalQueues;
}]], mod.VkStructureType)
mod.VkExternalComputeQueueCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ preferredQueue;
}]], mod.VkStructureType, mod.VkQueue)
mod.VkExternalComputeQueueDataParamsNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t deviceIndex;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceExternalComputeQueuePropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t externalDataSize;
	uint32_t maxExternalQueues;
}]], mod.VkStructureType)
mod.PFN_vkCreateExternalComputeQueueNV = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkExternalComputeQueueCreateInfoNV, mod.VkAllocationCallbacks, mod.VkExternalComputeQueueNV)
mod.PFN_vkDestroyExternalComputeQueueNV = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkExternalComputeQueueNV, mod.VkAllocationCallbacks)
mod.PFN_vkGetExternalComputeQueueDataNV = ffi.typeof([[void (*)($ , $*, void*)]], mod.VkExternalComputeQueueNV, mod.VkExternalComputeQueueDataParamsNV)
ffi.cdef([[$  vkCreateExternalComputeQueueNV($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkExternalComputeQueueCreateInfoNV, mod.VkAllocationCallbacks, mod.VkExternalComputeQueueNV)
ffi.cdef([[void  vkDestroyExternalComputeQueueNV($ , $ , const $*);]], mod.VkDevice, mod.VkExternalComputeQueueNV, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkGetExternalComputeQueueDataNV($ , $*, void*);]], mod.VkExternalComputeQueueNV, mod.VkExternalComputeQueueDataParamsNV)
mod.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ commandBufferInheritance;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderFloat16VectorAtomics;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderReplicatedComposites;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderFloat8FeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderFloat8;
	$ shaderFloat8CooperativeMatrix;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceRayTracingValidationFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rayTracingValidation;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkClusterAccelerationStructureTypeNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureOpTypeNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV = 3,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV = 4,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV = 5,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureOpModeNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureAddressResolutionFlagBitsNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV = 0x00000008,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV = 0x00000010,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV = 0x00000020,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureAddressResolutionFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkClusterAccelerationStructureClusterFlagBitsNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureClusterFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkClusterAccelerationStructureGeometryFlagBitsNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureGeometryFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkClusterAccelerationStructureIndexFormatFlagBitsNV = ffi.typeof([[enum {
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkClusterAccelerationStructureIndexFormatFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ clusterAccelerationStructure;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxVerticesPerCluster;
	uint32_t maxTrianglesPerCluster;
	uint32_t clusterScratchByteAlignment;
	uint32_t clusterByteAlignment;
	uint32_t clusterTemplateByteAlignment;
	uint32_t clusterBottomLevelByteAlignment;
	uint32_t clusterTemplateBoundsByteAlignment;
	uint32_t maxClusterGeometryIndex;
}]], mod.VkStructureType)
mod.VkClusterAccelerationStructureClustersBottomLevelInputNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxTotalClusterCount;
	uint32_t maxClusterCountPerAccelerationStructure;
}]], mod.VkStructureType)
mod.VkClusterAccelerationStructureTriangleClusterInputNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ vertexFormat;
	uint32_t maxGeometryIndexValue;
	uint32_t maxClusterUniqueGeometryCount;
	uint32_t maxClusterTriangleCount;
	uint32_t maxClusterVertexCount;
	uint32_t maxTotalTriangleCount;
	uint32_t maxTotalVertexCount;
	uint32_t minPositionTruncateBitCount;
}]], mod.VkStructureType, mod.VkFormat)
mod.VkClusterAccelerationStructureMoveObjectsInputNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ type;
	$ noMoveOverlap;
	$ maxMovedBytes;
}]], mod.VkStructureType, mod.VkClusterAccelerationStructureTypeNV, mod.VkBool32, mod.VkDeviceSize)
mod.VkClusterAccelerationStructureOpInputNV = ffi.typeof([[union {
	$* pClustersBottomLevel;
	$* pTriangleClusters;
	$* pMoveObjects;
}]], mod.VkClusterAccelerationStructureClustersBottomLevelInputNV, mod.VkClusterAccelerationStructureTriangleClusterInputNV, mod.VkClusterAccelerationStructureMoveObjectsInputNV)
mod.VkClusterAccelerationStructureInputInfoNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxAccelerationStructureCount;
	$ flags;
	$ opType;
	$ opMode;
	$ opInput;
}]], mod.VkStructureType, mod.VkBuildAccelerationStructureFlagsKHR, mod.VkClusterAccelerationStructureOpTypeNV, mod.VkClusterAccelerationStructureOpModeNV, mod.VkClusterAccelerationStructureOpInputNV)
mod.VkStridedDeviceAddressRegionKHR = ffi.typeof([[struct {
	$ deviceAddress;
	$ stride;
	$ size;
}]], mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkClusterAccelerationStructureCommandsInfoNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ input;
	$ dstImplicitData;
	$ scratchData;
	$ dstAddressesArray;
	$ dstSizesArray;
	$ srcInfosArray;
	$ srcInfosCount;
	$ addressResolutionFlags;
}]], mod.VkStructureType, mod.VkClusterAccelerationStructureInputInfoNV, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkDeviceAddress, mod.VkClusterAccelerationStructureAddressResolutionFlagsNV)
mod.VkStridedDeviceAddressNV = ffi.typeof([[struct {
	$ startAddress;
	$ strideInBytes;
}]], mod.VkDeviceAddress, mod.VkDeviceSize)
mod.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = ffi.typeof([[struct {
	uint32_t geometryIndex;
	uint32_t reserved;
	uint32_t geometryFlags;
}]])
mod.VkClusterAccelerationStructureMoveObjectsInfoNV = ffi.typeof([[struct {
	$ srcAccelerationStructure;
}]], mod.VkDeviceAddress)
mod.VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV = ffi.typeof([[struct {
	uint32_t clusterReferencesCount;
	uint32_t clusterReferencesStride;
	$ clusterReferences;
}]], mod.VkDeviceAddress)
mod.VkClusterAccelerationStructureBuildTriangleClusterInfoNV = ffi.typeof([[struct {
	uint32_t clusterID;
	$ clusterFlags;
	uint32_t triangleCount;
	uint32_t vertexCount;
	uint32_t positionTruncateBitCount;
	uint32_t indexType;
	uint32_t opacityMicromapIndexType;
	$ baseGeometryIndexAndGeometryFlags;
	uint16_t indexBufferStride;
	uint16_t vertexBufferStride;
	uint16_t geometryIndexAndFlagsBufferStride;
	uint16_t opacityMicromapIndexBufferStride;
	$ indexBuffer;
	$ vertexBuffer;
	$ geometryIndexAndFlagsBuffer;
	$ opacityMicromapArray;
	$ opacityMicromapIndexBuffer;
}]], mod.VkClusterAccelerationStructureClusterFlagsNV, mod.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress)
mod.VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV = ffi.typeof([[struct {
	uint32_t clusterID;
	$ clusterFlags;
	uint32_t triangleCount;
	uint32_t vertexCount;
	uint32_t positionTruncateBitCount;
	uint32_t indexType;
	uint32_t opacityMicromapIndexType;
	$ baseGeometryIndexAndGeometryFlags;
	uint16_t indexBufferStride;
	uint16_t vertexBufferStride;
	uint16_t geometryIndexAndFlagsBufferStride;
	uint16_t opacityMicromapIndexBufferStride;
	$ indexBuffer;
	$ vertexBuffer;
	$ geometryIndexAndFlagsBuffer;
	$ opacityMicromapArray;
	$ opacityMicromapIndexBuffer;
	$ instantiationBoundingBoxLimit;
}]], mod.VkClusterAccelerationStructureClusterFlagsNV, mod.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress)
mod.VkClusterAccelerationStructureInstantiateClusterInfoNV = ffi.typeof([[struct {
	uint32_t clusterIdOffset;
	uint32_t geometryIndexOffset;
	uint32_t reserved;
	$ clusterTemplateAddress;
	$ vertexBuffer;
}]], mod.VkDeviceAddress, mod.VkStridedDeviceAddressNV)
mod.VkClusterAccelerationStructureGetTemplateIndicesInfoNV = ffi.typeof([[struct {
	$ clusterTemplateAddress;
}]], mod.VkDeviceAddress)
mod.VkAccelerationStructureBuildSizesInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ accelerationStructureSize;
	$ updateScratchSize;
	$ buildScratchSize;
}]], mod.VkStructureType, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkDeviceSize)
mod.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ allowClusterAccelerationStructure;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkGetClusterAccelerationStructureBuildSizesNV = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkClusterAccelerationStructureInputInfoNV, mod.VkAccelerationStructureBuildSizesInfoKHR)
mod.PFN_vkCmdBuildClusterAccelerationStructureIndirectNV = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkClusterAccelerationStructureCommandsInfoNV)
ffi.cdef([[void  vkGetClusterAccelerationStructureBuildSizesNV($ , const $*, $*);]], mod.VkDevice, mod.VkClusterAccelerationStructureInputInfoNV, mod.VkAccelerationStructureBuildSizesInfoKHR)
ffi.cdef([[void  vkCmdBuildClusterAccelerationStructureIndirectNV($ , const $*);]], mod.VkCommandBuffer, mod.VkClusterAccelerationStructureCommandsInfoNV)
mod.VkPartitionedAccelerationStructureOpTypeNV = ffi.typeof([[enum {
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV = 0,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV = 1,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV = 2,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPartitionedAccelerationStructureInstanceFlagBitsNV = ffi.typeof([[enum {
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV = 0x00000001,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV = 0x00000002,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV = 0x00000004,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV = 0x00000008,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV = 0x00000010,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF,
}]])
mod.VkPartitionedAccelerationStructureInstanceFlagsNV = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ partitionedAccelerationStructure;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxPartitionCount;
}]], mod.VkStructureType)
mod.VkPartitionedAccelerationStructureFlagsNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ enablePartitionTranslation;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkBuildPartitionedAccelerationStructureIndirectCommandNV = ffi.typeof([[struct {
	$ opType;
	uint32_t argCount;
	$ argData;
}]], mod.VkPartitionedAccelerationStructureOpTypeNV, mod.VkStridedDeviceAddressNV)
mod.VkPartitionedAccelerationStructureWriteInstanceDataNV = ffi.typeof([[struct {
	$ transform;
	float explicitAABB[6];
	uint32_t instanceID;
	uint32_t instanceMask;
	uint32_t instanceContributionToHitGroupIndex;
	$ instanceFlags;
	uint32_t instanceIndex;
	uint32_t partitionIndex;
	$ accelerationStructure;
}]], mod.VkTransformMatrixKHR, mod.VkPartitionedAccelerationStructureInstanceFlagsNV, mod.VkDeviceAddress)
mod.VkPartitionedAccelerationStructureUpdateInstanceDataNV = ffi.typeof([[struct {
	uint32_t instanceIndex;
	uint32_t instanceContributionToHitGroupIndex;
	$ accelerationStructure;
}]], mod.VkDeviceAddress)
mod.VkPartitionedAccelerationStructureWritePartitionTranslationDataNV = ffi.typeof([[struct {
	uint32_t partitionIndex;
	float partitionTranslation[3];
}]])
mod.VkWriteDescriptorSetPartitionedAccelerationStructureNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t accelerationStructureCount;
	const $* pAccelerationStructures;
}]], mod.VkStructureType, mod.VkDeviceAddress)
mod.VkPartitionedAccelerationStructureInstancesInputNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ flags;
	uint32_t instanceCount;
	uint32_t maxInstancePerPartitionCount;
	uint32_t partitionCount;
	uint32_t maxInstanceInGlobalPartitionCount;
}]], mod.VkStructureType, mod.VkBuildAccelerationStructureFlagsKHR)
mod.VkBuildPartitionedAccelerationStructureInfoNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ input;
	$ srcAccelerationStructureData;
	$ dstAccelerationStructureData;
	$ scratchData;
	$ srcInfos;
	$ srcInfosCount;
}]], mod.VkStructureType, mod.VkPartitionedAccelerationStructureInstancesInputNV, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress, mod.VkDeviceAddress)
mod.PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkPartitionedAccelerationStructureInstancesInputNV, mod.VkAccelerationStructureBuildSizesInfoKHR)
mod.PFN_vkCmdBuildPartitionedAccelerationStructuresNV = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkBuildPartitionedAccelerationStructureInfoNV)
ffi.cdef([[void  vkGetPartitionedAccelerationStructuresBuildSizesNV($ , const $*, $*);]], mod.VkDevice, mod.VkPartitionedAccelerationStructureInstancesInputNV, mod.VkAccelerationStructureBuildSizesInfoKHR)
ffi.cdef([[void  vkCmdBuildPartitionedAccelerationStructuresNV($ , const $*);]], mod.VkCommandBuffer, mod.VkBuildPartitionedAccelerationStructureInfoNV)
mod.VkIndirectExecutionSetEXT = ffi.typeof([[void*]])
mod.VkIndirectCommandsLayoutEXT = ffi.typeof([[void*]])
mod.VkIndirectExecutionSetInfoTypeEXT = ffi.typeof([[enum {
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT = 0,
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT = 1,
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsTokenTypeEXT = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT = 7,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT = 8,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT = 9,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT = 1000202002,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT = 1000202003,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT = 1000328000,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT = 1000328001,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT = 1000386004,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsInputModeFlagBitsEXT = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT = 0x00000001,
	VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT = 0x00000002,
	VK_INDIRECT_COMMANDS_INPUT_MODE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsInputModeFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkIndirectCommandsLayoutUsageFlagBitsEXT = ffi.typeof([[enum {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT = 0x00000001,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT = 0x00000002,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkIndirectCommandsLayoutUsageFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ deviceGeneratedCommands;
	$ dynamicGeneratedPipelineLayout;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxIndirectPipelineCount;
	uint32_t maxIndirectShaderObjectCount;
	uint32_t maxIndirectSequenceCount;
	uint32_t maxIndirectCommandsTokenCount;
	uint32_t maxIndirectCommandsTokenOffset;
	uint32_t maxIndirectCommandsIndirectStride;
	$ supportedIndirectCommandsInputModes;
	$ supportedIndirectCommandsShaderStages;
	$ supportedIndirectCommandsShaderStagesPipelineBinding;
	$ supportedIndirectCommandsShaderStagesShaderBinding;
	$ deviceGeneratedCommandsTransformFeedback;
	$ deviceGeneratedCommandsMultiDrawIndirectCount;
}]], mod.VkStructureType, mod.VkIndirectCommandsInputModeFlagsEXT, mod.VkShaderStageFlags, mod.VkShaderStageFlags, mod.VkShaderStageFlags, mod.VkBool32, mod.VkBool32)
mod.VkGeneratedCommandsMemoryRequirementsInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ indirectExecutionSet;
	$ indirectCommandsLayout;
	uint32_t maxSequenceCount;
	uint32_t maxDrawCount;
}]], mod.VkStructureType, mod.VkIndirectExecutionSetEXT, mod.VkIndirectCommandsLayoutEXT)
mod.VkIndirectExecutionSetPipelineInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ initialPipeline;
	uint32_t maxPipelineCount;
}]], mod.VkStructureType, mod.VkPipeline)
mod.VkIndirectExecutionSetShaderLayoutInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t setLayoutCount;
	const $* pSetLayouts;
}]], mod.VkStructureType, mod.VkDescriptorSetLayout)
mod.VkIndirectExecutionSetShaderInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t shaderCount;
	const $* pInitialShaders;
	const $* pSetLayoutInfos;
	uint32_t maxShaderCount;
	uint32_t pushConstantRangeCount;
	const $* pPushConstantRanges;
}]], mod.VkStructureType, mod.VkShaderEXT, mod.VkIndirectExecutionSetShaderLayoutInfoEXT, mod.VkPushConstantRange)
mod.VkIndirectExecutionSetInfoEXT = ffi.typeof([[union {
	const $* pPipelineInfo;
	const $* pShaderInfo;
}]], mod.VkIndirectExecutionSetPipelineInfoEXT, mod.VkIndirectExecutionSetShaderInfoEXT)
mod.VkIndirectExecutionSetCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ info;
}]], mod.VkStructureType, mod.VkIndirectExecutionSetInfoTypeEXT, mod.VkIndirectExecutionSetInfoEXT)
mod.VkGeneratedCommandsInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ shaderStages;
	$ indirectExecutionSet;
	$ indirectCommandsLayout;
	$ indirectAddress;
	$ indirectAddressSize;
	$ preprocessAddress;
	$ preprocessSize;
	uint32_t maxSequenceCount;
	$ sequenceCountAddress;
	uint32_t maxDrawCount;
}]], mod.VkStructureType, mod.VkShaderStageFlags, mod.VkIndirectExecutionSetEXT, mod.VkIndirectCommandsLayoutEXT, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceAddress, mod.VkDeviceSize, mod.VkDeviceAddress)
mod.VkWriteIndirectExecutionSetPipelineEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t index;
	$ pipeline;
}]], mod.VkStructureType, mod.VkPipeline)
mod.VkIndirectCommandsPushConstantTokenEXT = ffi.typeof([[struct {
	$ updateRange;
}]], mod.VkPushConstantRange)
mod.VkIndirectCommandsVertexBufferTokenEXT = ffi.typeof([[struct {
	uint32_t vertexBindingUnit;
}]])
mod.VkIndirectCommandsIndexBufferTokenEXT = ffi.typeof([[struct {
	$ mode;
}]], mod.VkIndirectCommandsInputModeFlagBitsEXT)
mod.VkIndirectCommandsExecutionSetTokenEXT = ffi.typeof([[struct {
	$ type;
	$ shaderStages;
}]], mod.VkIndirectExecutionSetInfoTypeEXT, mod.VkShaderStageFlags)
mod.VkIndirectCommandsTokenDataEXT = ffi.typeof([[union {
	const $* pPushConstant;
	const $* pVertexBuffer;
	const $* pIndexBuffer;
	const $* pExecutionSet;
}]], mod.VkIndirectCommandsPushConstantTokenEXT, mod.VkIndirectCommandsVertexBufferTokenEXT, mod.VkIndirectCommandsIndexBufferTokenEXT, mod.VkIndirectCommandsExecutionSetTokenEXT)
mod.VkIndirectCommandsLayoutTokenEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ data;
	uint32_t offset;
}]], mod.VkStructureType, mod.VkIndirectCommandsTokenTypeEXT, mod.VkIndirectCommandsTokenDataEXT)
mod.VkIndirectCommandsLayoutCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ shaderStages;
	uint32_t indirectStride;
	$ pipelineLayout;
	uint32_t tokenCount;
	const $* pTokens;
}]], mod.VkStructureType, mod.VkIndirectCommandsLayoutUsageFlagsEXT, mod.VkShaderStageFlags, mod.VkPipelineLayout, mod.VkIndirectCommandsLayoutTokenEXT)
mod.VkDrawIndirectCountIndirectCommandEXT = ffi.typeof([[struct {
	$ bufferAddress;
	uint32_t stride;
	uint32_t commandCount;
}]], mod.VkDeviceAddress)
mod.VkBindVertexBufferIndirectCommandEXT = ffi.typeof([[struct {
	$ bufferAddress;
	uint32_t size;
	uint32_t stride;
}]], mod.VkDeviceAddress)
mod.VkBindIndexBufferIndirectCommandEXT = ffi.typeof([[struct {
	$ bufferAddress;
	uint32_t size;
	$ indexType;
}]], mod.VkDeviceAddress, mod.VkIndexType)
mod.VkGeneratedCommandsPipelineInfoEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipeline;
}]], mod.VkStructureType, mod.VkPipeline)
mod.VkGeneratedCommandsShaderInfoEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t shaderCount;
	const $* pShaders;
}]], mod.VkStructureType, mod.VkShaderEXT)
mod.VkWriteIndirectExecutionSetShaderEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t index;
	$ shader;
}]], mod.VkStructureType, mod.VkShaderEXT)
mod.PFN_vkGetGeneratedCommandsMemoryRequirementsEXT = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkGeneratedCommandsMemoryRequirementsInfoEXT, mod.VkMemoryRequirements2)
mod.PFN_vkCmdPreprocessGeneratedCommandsEXT = ffi.typeof([[void (*)($ , const $*, $ )]], mod.VkCommandBuffer, mod.VkGeneratedCommandsInfoEXT, mod.VkCommandBuffer)
mod.PFN_vkCmdExecuteGeneratedCommandsEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkCommandBuffer, mod.VkBool32, mod.VkGeneratedCommandsInfoEXT)
mod.PFN_vkCreateIndirectCommandsLayoutEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkIndirectCommandsLayoutCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkIndirectCommandsLayoutEXT)
mod.PFN_vkDestroyIndirectCommandsLayoutEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkIndirectCommandsLayoutEXT, mod.VkAllocationCallbacks)
mod.PFN_vkCreateIndirectExecutionSetEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkIndirectExecutionSetCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkIndirectExecutionSetEXT)
mod.PFN_vkDestroyIndirectExecutionSetEXT = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkIndirectExecutionSetEXT, mod.VkAllocationCallbacks)
mod.PFN_vkUpdateIndirectExecutionSetPipelineEXT = ffi.typeof([[void (*)($ , $ , uint32_t , const $*)]], mod.VkDevice, mod.VkIndirectExecutionSetEXT, mod.VkWriteIndirectExecutionSetPipelineEXT)
mod.PFN_vkUpdateIndirectExecutionSetShaderEXT = ffi.typeof([[void (*)($ , $ , uint32_t , const $*)]], mod.VkDevice, mod.VkIndirectExecutionSetEXT, mod.VkWriteIndirectExecutionSetShaderEXT)
ffi.cdef([[void  vkGetGeneratedCommandsMemoryRequirementsEXT($ , const $*, $*);]], mod.VkDevice, mod.VkGeneratedCommandsMemoryRequirementsInfoEXT, mod.VkMemoryRequirements2)
ffi.cdef([[void  vkCmdPreprocessGeneratedCommandsEXT($ , const $*, $ );]], mod.VkCommandBuffer, mod.VkGeneratedCommandsInfoEXT, mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdExecuteGeneratedCommandsEXT($ , $ , const $*);]], mod.VkCommandBuffer, mod.VkBool32, mod.VkGeneratedCommandsInfoEXT)
ffi.cdef([[$  vkCreateIndirectCommandsLayoutEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkIndirectCommandsLayoutCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkIndirectCommandsLayoutEXT)
ffi.cdef([[void  vkDestroyIndirectCommandsLayoutEXT($ , $ , const $*);]], mod.VkDevice, mod.VkIndirectCommandsLayoutEXT, mod.VkAllocationCallbacks)
ffi.cdef([[$  vkCreateIndirectExecutionSetEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkIndirectExecutionSetCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkIndirectExecutionSetEXT)
ffi.cdef([[void  vkDestroyIndirectExecutionSetEXT($ , $ , const $*);]], mod.VkDevice, mod.VkIndirectExecutionSetEXT, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkUpdateIndirectExecutionSetPipelineEXT($ , $ , uint32_t , const $*);]], mod.VkDevice, mod.VkIndirectExecutionSetEXT, mod.VkWriteIndirectExecutionSetPipelineEXT)
ffi.cdef([[void  vkUpdateIndirectExecutionSetShaderEXT($ , $ , uint32_t , const $*);]], mod.VkDevice, mod.VkIndirectExecutionSetEXT, mod.VkWriteIndirectExecutionSetShaderEXT)
mod.VkPhysicalDeviceImageAlignmentControlFeaturesMESA = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ imageAlignmentControl;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceImageAlignmentControlPropertiesMESA = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t supportedImageAlignmentMask;
}]], mod.VkStructureType)
mod.VkImageAlignmentControlCreateInfoMESA = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maximumRequestedAlignment;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceDepthClampControlFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ depthClampControl;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPipelineViewportDepthClampControlCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ depthClampMode;
	const $* pDepthClampRange;
}]], mod.VkStructureType, mod.VkDepthClampModeEXT, mod.VkDepthClampRangeEXT)
mod.VkPhysicalDeviceHdrVividFeaturesHUAWEI = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ hdrVivid;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkHdrVividDynamicMetadataHUAWEI = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	size_t dynamicMetadataSize;
	const void* pDynamicMetadata;
}]], mod.VkStructureType)
mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t MGranularity;
	uint32_t NGranularity;
	uint32_t KGranularity;
	$ AType;
	$ BType;
	$ CType;
	$ ResultType;
	$ saturatingAccumulation;
	$ scope;
	uint32_t workgroupInvocations;
}]], mod.VkStructureType, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkComponentTypeKHR, mod.VkBool32, mod.VkScopeKHR)
mod.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ cooperativeMatrixWorkgroupScope;
	$ cooperativeMatrixFlexibleDimensions;
	$ cooperativeMatrixReductions;
	$ cooperativeMatrixConversions;
	$ cooperativeMatrixPerElementOperations;
	$ cooperativeMatrixTensorAddressing;
	$ cooperativeMatrixBlockLoads;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceCooperativeMatrix2PropertiesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t cooperativeMatrixWorkgroupScopeMaxWorkgroupSize;
	uint32_t cooperativeMatrixFlexibleDimensionsMaxDimension;
	uint32_t cooperativeMatrixWorkgroupScopeReservedSharedMemory;
}]], mod.VkStructureType)
mod.PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = ffi.typeof([[$ (*)($ , uint32_t*, $*)]], mod.VkResult, mod.VkPhysicalDevice, mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV)
ffi.cdef([[$  vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV($ , uint32_t*, $*);]], mod.VkResult, mod.VkPhysicalDevice, mod.VkCooperativeMatrixFlexibleDimensionsPropertiesNV)
mod.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineOpacityMicromap;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ vertexAttributeRobustness;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceFormatPackFeaturesARM = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ formatPack;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ fragmentDensityMapLayered;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxFragmentDensityMapLayers;
}]], mod.VkStructureType)
mod.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maxFragmentDensityMapLayers;
}]], mod.VkStructureType)
mod.VkSetPresentConfigNV = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t numFramesPerBatch;
	uint32_t presentConfigFeedback;
}]], mod.VkStructureType)
mod.VkPhysicalDevicePresentMeteringFeaturesNV = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ presentMetering;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkRenderingEndInfoEXT = ffi.typeof([[$ ]], mod.VkRenderingEndInfoKHR)
mod.PFN_vkCmdEndRendering2EXT = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkRenderingEndInfoKHR)
ffi.cdef([[void  vkCmdEndRendering2EXT($ , const $*);]], mod.VkCommandBuffer, mod.VkRenderingEndInfoKHR)
mod.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ zeroInitializeDeviceMemory;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShader64BitIndexingFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shader64BitIndexing;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ pipelineCacheIncrementalMode;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ shaderUniformBufferUnsizedArray;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkBuildAccelerationStructureModeKHR = ffi.typeof([[enum {
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureCreateFlagBitsKHR = ffi.typeof([[enum {
	VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x00000001,
	VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
	VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x00000004,
	VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkAccelerationStructureCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAccelerationStructureBuildRangeInfoKHR = ffi.typeof([[struct {
	uint32_t primitiveCount;
	uint32_t primitiveOffset;
	uint32_t firstVertex;
	uint32_t transformOffset;
}]])
mod.VkAccelerationStructureGeometryTrianglesDataKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ vertexFormat;
	$ vertexData;
	$ vertexStride;
	uint32_t maxVertex;
	$ indexType;
	$ indexData;
	$ transformData;
}]], mod.VkStructureType, mod.VkFormat, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize, mod.VkIndexType, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceOrHostAddressConstKHR)
mod.VkAccelerationStructureGeometryAabbsDataKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ data;
	$ stride;
}]], mod.VkStructureType, mod.VkDeviceOrHostAddressConstKHR, mod.VkDeviceSize)
mod.VkAccelerationStructureGeometryInstancesDataKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ arrayOfPointers;
	$ data;
}]], mod.VkStructureType, mod.VkBool32, mod.VkDeviceOrHostAddressConstKHR)
mod.VkAccelerationStructureGeometryDataKHR = ffi.typeof([[union {
	$ triangles;
	$ aabbs;
	$ instances;
}]], mod.VkAccelerationStructureGeometryTrianglesDataKHR, mod.VkAccelerationStructureGeometryAabbsDataKHR, mod.VkAccelerationStructureGeometryInstancesDataKHR)
mod.VkAccelerationStructureGeometryKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ geometryType;
	$ geometry;
	$ flags;
}]], mod.VkStructureType, mod.VkGeometryTypeKHR, mod.VkAccelerationStructureGeometryDataKHR, mod.VkGeometryFlagsKHR)
mod.VkAccelerationStructureBuildGeometryInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	$ flags;
	$ mode;
	$ srcAccelerationStructure;
	$ dstAccelerationStructure;
	uint32_t geometryCount;
	const $* pGeometries;
	const $** const ppGeometries;
	$ scratchData;
}]], mod.VkStructureType, mod.VkAccelerationStructureTypeKHR, mod.VkBuildAccelerationStructureFlagsKHR, mod.VkBuildAccelerationStructureModeKHR, mod.VkAccelerationStructureKHR, mod.VkAccelerationStructureKHR, mod.VkAccelerationStructureGeometryKHR, mod.VkAccelerationStructureGeometryKHR, mod.VkDeviceOrHostAddressKHR)
mod.VkAccelerationStructureCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ createFlags;
	$ buffer;
	$ offset;
	$ size;
	$ type;
	$ deviceAddress;
}]], mod.VkStructureType, mod.VkAccelerationStructureCreateFlagsKHR, mod.VkBuffer, mod.VkDeviceSize, mod.VkDeviceSize, mod.VkAccelerationStructureTypeKHR, mod.VkDeviceAddress)
mod.VkWriteDescriptorSetAccelerationStructureKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t accelerationStructureCount;
	const $* pAccelerationStructures;
}]], mod.VkStructureType, mod.VkAccelerationStructureKHR)
mod.VkPhysicalDeviceAccelerationStructureFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ accelerationStructure;
	$ accelerationStructureCaptureReplay;
	$ accelerationStructureIndirectBuild;
	$ accelerationStructureHostCommands;
	$ descriptorBindingAccelerationStructureUpdateAfterBind;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceAccelerationStructurePropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint64_t maxGeometryCount;
	uint64_t maxInstanceCount;
	uint64_t maxPrimitiveCount;
	uint32_t maxPerStageDescriptorAccelerationStructures;
	uint32_t maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
	uint32_t maxDescriptorSetAccelerationStructures;
	uint32_t maxDescriptorSetUpdateAfterBindAccelerationStructures;
	uint32_t minAccelerationStructureScratchOffsetAlignment;
}]], mod.VkStructureType)
mod.VkAccelerationStructureDeviceAddressInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ accelerationStructure;
}]], mod.VkStructureType, mod.VkAccelerationStructureKHR)
mod.VkAccelerationStructureVersionInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	const uint8_t* pVersionData;
}]], mod.VkStructureType)
mod.VkCopyAccelerationStructureToMemoryInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]], mod.VkStructureType, mod.VkAccelerationStructureKHR, mod.VkDeviceOrHostAddressKHR, mod.VkCopyAccelerationStructureModeKHR)
mod.VkCopyMemoryToAccelerationStructureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]], mod.VkStructureType, mod.VkDeviceOrHostAddressConstKHR, mod.VkAccelerationStructureKHR, mod.VkCopyAccelerationStructureModeKHR)
mod.VkCopyAccelerationStructureInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ src;
	$ dst;
	$ mode;
}]], mod.VkStructureType, mod.VkAccelerationStructureKHR, mod.VkAccelerationStructureKHR, mod.VkCopyAccelerationStructureModeKHR)
mod.PFN_vkCreateAccelerationStructureKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkAccelerationStructureKHR)
mod.PFN_vkDestroyAccelerationStructureKHR = ffi.typeof([[void (*)($ , $ , const $*)]], mod.VkDevice, mod.VkAccelerationStructureKHR, mod.VkAllocationCallbacks)
mod.PFN_vkCmdBuildAccelerationStructuresKHR = ffi.typeof([[void (*)($ , uint32_t , const $*, const $** const)]], mod.VkCommandBuffer, mod.VkAccelerationStructureBuildGeometryInfoKHR, mod.VkAccelerationStructureBuildRangeInfoKHR)
mod.PFN_vkCmdBuildAccelerationStructuresIndirectKHR = ffi.typeof([[void (*)($ , uint32_t , const $*, const $*, const uint32_t*, const uint32_t** const)]], mod.VkCommandBuffer, mod.VkAccelerationStructureBuildGeometryInfoKHR, mod.VkDeviceAddress)
mod.PFN_vkBuildAccelerationStructuresKHR = ffi.typeof([[$ (*)($ , $ , uint32_t , const $*, const $** const)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkAccelerationStructureBuildGeometryInfoKHR, mod.VkAccelerationStructureBuildRangeInfoKHR)
mod.PFN_vkCopyAccelerationStructureKHR = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyAccelerationStructureInfoKHR)
mod.PFN_vkCopyAccelerationStructureToMemoryKHR = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyAccelerationStructureToMemoryInfoKHR)
mod.PFN_vkCopyMemoryToAccelerationStructureKHR = ffi.typeof([[$ (*)($ , $ , const $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyMemoryToAccelerationStructureInfoKHR)
mod.PFN_vkWriteAccelerationStructuresPropertiesKHR = ffi.typeof([[$ (*)($ , uint32_t , const $*, $ , size_t , void*, size_t )]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureKHR, mod.VkQueryType)
mod.PFN_vkCmdCopyAccelerationStructureKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyAccelerationStructureInfoKHR)
mod.PFN_vkCmdCopyAccelerationStructureToMemoryKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyAccelerationStructureToMemoryInfoKHR)
mod.PFN_vkCmdCopyMemoryToAccelerationStructureKHR = ffi.typeof([[void (*)($ , const $*)]], mod.VkCommandBuffer, mod.VkCopyMemoryToAccelerationStructureInfoKHR)
mod.PFN_vkGetAccelerationStructureDeviceAddressKHR = ffi.typeof([[$ (*)($ , const $*)]], mod.VkDeviceAddress, mod.VkDevice, mod.VkAccelerationStructureDeviceAddressInfoKHR)
mod.PFN_vkCmdWriteAccelerationStructuresPropertiesKHR = ffi.typeof([[void (*)($ , uint32_t , const $*, $ , $ , uint32_t )]], mod.VkCommandBuffer, mod.VkAccelerationStructureKHR, mod.VkQueryType, mod.VkQueryPool)
mod.PFN_vkGetDeviceAccelerationStructureCompatibilityKHR = ffi.typeof([[void (*)($ , const $*, $*)]], mod.VkDevice, mod.VkAccelerationStructureVersionInfoKHR, mod.VkAccelerationStructureCompatibilityKHR)
mod.PFN_vkGetAccelerationStructureBuildSizesKHR = ffi.typeof([[void (*)($ , $ , const $*, const uint32_t*, $*)]], mod.VkDevice, mod.VkAccelerationStructureBuildTypeKHR, mod.VkAccelerationStructureBuildGeometryInfoKHR, mod.VkAccelerationStructureBuildSizesInfoKHR)
ffi.cdef([[$  vkCreateAccelerationStructureKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkAccelerationStructureKHR)
ffi.cdef([[void  vkDestroyAccelerationStructureKHR($ , $ , const $*);]], mod.VkDevice, mod.VkAccelerationStructureKHR, mod.VkAllocationCallbacks)
ffi.cdef([[void  vkCmdBuildAccelerationStructuresKHR($ , uint32_t , const $*, const $** const);]], mod.VkCommandBuffer, mod.VkAccelerationStructureBuildGeometryInfoKHR, mod.VkAccelerationStructureBuildRangeInfoKHR)
ffi.cdef([[void  vkCmdBuildAccelerationStructuresIndirectKHR($ , uint32_t , const $*, const $*, const uint32_t*, const uint32_t** const);]], mod.VkCommandBuffer, mod.VkAccelerationStructureBuildGeometryInfoKHR, mod.VkDeviceAddress)
ffi.cdef([[$  vkBuildAccelerationStructuresKHR($ , $ , uint32_t , const $*, const $** const);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkAccelerationStructureBuildGeometryInfoKHR, mod.VkAccelerationStructureBuildRangeInfoKHR)
ffi.cdef([[$  vkCopyAccelerationStructureKHR($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyAccelerationStructureInfoKHR)
ffi.cdef([[$  vkCopyAccelerationStructureToMemoryKHR($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyAccelerationStructureToMemoryInfoKHR)
ffi.cdef([[$  vkCopyMemoryToAccelerationStructureKHR($ , $ , const $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkCopyMemoryToAccelerationStructureInfoKHR)
ffi.cdef([[$  vkWriteAccelerationStructuresPropertiesKHR($ , uint32_t , const $*, $ , size_t , void*, size_t );]], mod.VkResult, mod.VkDevice, mod.VkAccelerationStructureKHR, mod.VkQueryType)
ffi.cdef([[void  vkCmdCopyAccelerationStructureKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyAccelerationStructureInfoKHR)
ffi.cdef([[void  vkCmdCopyAccelerationStructureToMemoryKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyAccelerationStructureToMemoryInfoKHR)
ffi.cdef([[void  vkCmdCopyMemoryToAccelerationStructureKHR($ , const $*);]], mod.VkCommandBuffer, mod.VkCopyMemoryToAccelerationStructureInfoKHR)
ffi.cdef([[$  vkGetAccelerationStructureDeviceAddressKHR($ , const $*);]], mod.VkDeviceAddress, mod.VkDevice, mod.VkAccelerationStructureDeviceAddressInfoKHR)
ffi.cdef([[void  vkCmdWriteAccelerationStructuresPropertiesKHR($ , uint32_t , const $*, $ , $ , uint32_t );]], mod.VkCommandBuffer, mod.VkAccelerationStructureKHR, mod.VkQueryType, mod.VkQueryPool)
ffi.cdef([[void  vkGetDeviceAccelerationStructureCompatibilityKHR($ , const $*, $*);]], mod.VkDevice, mod.VkAccelerationStructureVersionInfoKHR, mod.VkAccelerationStructureCompatibilityKHR)
ffi.cdef([[void  vkGetAccelerationStructureBuildSizesKHR($ , $ , const $*, const uint32_t*, $*);]], mod.VkDevice, mod.VkAccelerationStructureBuildTypeKHR, mod.VkAccelerationStructureBuildGeometryInfoKHR, mod.VkAccelerationStructureBuildSizesInfoKHR)
mod.VkShaderGroupShaderKHR = ffi.typeof([[enum {
	VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
	VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
	VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
	VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
	VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR = 0x7FFFFFFF,
}]])
mod.VkRayTracingShaderGroupCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ type;
	uint32_t generalShader;
	uint32_t closestHitShader;
	uint32_t anyHitShader;
	uint32_t intersectionShader;
	const void* pShaderGroupCaptureReplayHandle;
}]], mod.VkStructureType, mod.VkRayTracingShaderGroupTypeKHR)
mod.VkRayTracingPipelineInterfaceCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	uint32_t maxPipelineRayPayloadSize;
	uint32_t maxPipelineRayHitAttributeSize;
}]], mod.VkStructureType)
mod.VkRayTracingPipelineCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	uint32_t stageCount;
	const $* pStages;
	uint32_t groupCount;
	const $* pGroups;
	uint32_t maxPipelineRayRecursionDepth;
	const $* pLibraryInfo;
	const $* pLibraryInterface;
	const $* pDynamicState;
	$ layout;
	$ basePipelineHandle;
	int32_t basePipelineIndex;
}]], mod.VkStructureType, mod.VkPipelineCreateFlags, mod.VkPipelineShaderStageCreateInfo, mod.VkRayTracingShaderGroupCreateInfoKHR, mod.VkPipelineLibraryCreateInfoKHR, mod.VkRayTracingPipelineInterfaceCreateInfoKHR, mod.VkPipelineDynamicStateCreateInfo, mod.VkPipelineLayout, mod.VkPipeline)
mod.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rayTracingPipeline;
	$ rayTracingPipelineShaderGroupHandleCaptureReplay;
	$ rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
	$ rayTracingPipelineTraceRaysIndirect;
	$ rayTraversalPrimitiveCulling;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceRayTracingPipelinePropertiesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t shaderGroupHandleSize;
	uint32_t maxRayRecursionDepth;
	uint32_t maxShaderGroupStride;
	uint32_t shaderGroupBaseAlignment;
	uint32_t shaderGroupHandleCaptureReplaySize;
	uint32_t maxRayDispatchInvocationCount;
	uint32_t shaderGroupHandleAlignment;
	uint32_t maxRayHitAttributeSize;
}]], mod.VkStructureType)
mod.VkTraceRaysIndirectCommandKHR = ffi.typeof([[struct {
	uint32_t width;
	uint32_t height;
	uint32_t depth;
}]])
mod.PFN_vkCmdTraceRaysKHR = ffi.typeof([[void (*)($ , const $*, const $*, const $*, const $*, uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR)
mod.PFN_vkCreateRayTracingPipelinesKHR = ffi.typeof([[$ (*)($ , $ , $ , uint32_t , const $*, const $*, $*)]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkPipelineCache, mod.VkRayTracingPipelineCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkPipeline)
mod.PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = ffi.typeof([[$ (*)($ , $ , uint32_t , uint32_t , size_t , void*)]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
mod.PFN_vkCmdTraceRaysIndirectKHR = ffi.typeof([[void (*)($ , const $*, const $*, const $*, const $*, $ )]], mod.VkCommandBuffer, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkDeviceAddress)
mod.PFN_vkGetRayTracingShaderGroupStackSizeKHR = ffi.typeof([[$ (*)($ , $ , uint32_t , $ )]], mod.VkDeviceSize, mod.VkDevice, mod.VkPipeline, mod.VkShaderGroupShaderKHR)
mod.PFN_vkCmdSetRayTracingPipelineStackSizeKHR = ffi.typeof([[void (*)($ , uint32_t )]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdTraceRaysKHR($ , const $*, const $*, const $*, const $*, uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR)
ffi.cdef([[$  vkCreateRayTracingPipelinesKHR($ , $ , $ , uint32_t , const $*, const $*, $*);]], mod.VkResult, mod.VkDevice, mod.VkDeferredOperationKHR, mod.VkPipelineCache, mod.VkRayTracingPipelineCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkPipeline)
ffi.cdef([[$  vkGetRayTracingCaptureReplayShaderGroupHandlesKHR($ , $ , uint32_t , uint32_t , size_t , void*);]], mod.VkResult, mod.VkDevice, mod.VkPipeline)
ffi.cdef([[void  vkCmdTraceRaysIndirectKHR($ , const $*, const $*, const $*, const $*, $ );]], mod.VkCommandBuffer, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkStridedDeviceAddressRegionKHR, mod.VkDeviceAddress)
ffi.cdef([[$  vkGetRayTracingShaderGroupStackSizeKHR($ , $ , uint32_t , $ );]], mod.VkDeviceSize, mod.VkDevice, mod.VkPipeline, mod.VkShaderGroupShaderKHR)
ffi.cdef([[void  vkCmdSetRayTracingPipelineStackSizeKHR($ , uint32_t );]], mod.VkCommandBuffer)
mod.VkPhysicalDeviceRayQueryFeaturesKHR = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ rayQuery;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceMeshShaderFeaturesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ taskShader;
	$ meshShader;
	$ multiviewMeshShader;
	$ primitiveFragmentShadingRateMeshShader;
	$ meshShaderQueries;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkPhysicalDeviceMeshShaderPropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t maxTaskWorkGroupTotalCount;
	uint32_t maxTaskWorkGroupCount[3];
	uint32_t maxTaskWorkGroupInvocations;
	uint32_t maxTaskWorkGroupSize[3];
	uint32_t maxTaskPayloadSize;
	uint32_t maxTaskSharedMemorySize;
	uint32_t maxTaskPayloadAndSharedMemorySize;
	uint32_t maxMeshWorkGroupTotalCount;
	uint32_t maxMeshWorkGroupCount[3];
	uint32_t maxMeshWorkGroupInvocations;
	uint32_t maxMeshWorkGroupSize[3];
	uint32_t maxMeshSharedMemorySize;
	uint32_t maxMeshPayloadAndSharedMemorySize;
	uint32_t maxMeshOutputMemorySize;
	uint32_t maxMeshPayloadAndOutputMemorySize;
	uint32_t maxMeshOutputComponents;
	uint32_t maxMeshOutputVertices;
	uint32_t maxMeshOutputPrimitives;
	uint32_t maxMeshOutputLayers;
	uint32_t maxMeshMultiviewViewCount;
	uint32_t meshOutputPerVertexGranularity;
	uint32_t meshOutputPerPrimitiveGranularity;
	uint32_t maxPreferredTaskWorkGroupInvocations;
	uint32_t maxPreferredMeshWorkGroupInvocations;
	$ prefersLocalInvocationVertexOutput;
	$ prefersLocalInvocationPrimitiveOutput;
	$ prefersCompactVertexOutput;
	$ prefersCompactPrimitiveOutput;
}]], mod.VkStructureType, mod.VkBool32, mod.VkBool32, mod.VkBool32, mod.VkBool32)
mod.VkDrawMeshTasksIndirectCommandEXT = ffi.typeof([[struct {
	uint32_t groupCountX;
	uint32_t groupCountY;
	uint32_t groupCountZ;
}]])
mod.PFN_vkCmdDrawMeshTasksEXT = ffi.typeof([[void (*)($ , uint32_t , uint32_t , uint32_t )]], mod.VkCommandBuffer)
mod.PFN_vkCmdDrawMeshTasksIndirectEXT = ffi.typeof([[void (*)($ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
mod.PFN_vkCmdDrawMeshTasksIndirectCountEXT = ffi.typeof([[void (*)($ , $ , $ , $ , $ , uint32_t , uint32_t )]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawMeshTasksEXT($ , uint32_t , uint32_t , uint32_t );]], mod.VkCommandBuffer)
ffi.cdef([[void  vkCmdDrawMeshTasksIndirectEXT($ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize)
ffi.cdef([[void  vkCmdDrawMeshTasksIndirectCountEXT($ , $ , $ , $ , $ , uint32_t , uint32_t );]], mod.VkCommandBuffer, mod.VkBuffer, mod.VkDeviceSize, mod.VkBuffer, mod.VkDeviceSize)
mod.VkAndroidSurfaceCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkAndroidSurfaceCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	struct ANativeWindow* window;
}]], mod.VkStructureType, mod.VkAndroidSurfaceCreateFlagsKHR)
mod.PFN_vkCreateAndroidSurfaceKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkAndroidSurfaceCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkCreateAndroidSurfaceKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkAndroidSurfaceCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.VkAndroidHardwareBufferUsageANDROID = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint64_t androidHardwareBufferUsage;
}]], mod.VkStructureType)
mod.VkAndroidHardwareBufferPropertiesANDROID = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ allocationSize;
	uint32_t memoryTypeBits;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkAndroidHardwareBufferFormatPropertiesANDROID = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ format;
	uint64_t externalFormat;
	$ formatFeatures;
	$ samplerYcbcrConversionComponents;
	$ suggestedYcbcrModel;
	$ suggestedYcbcrRange;
	$ suggestedXChromaOffset;
	$ suggestedYChromaOffset;
}]], mod.VkStructureType, mod.VkFormat, mod.VkFormatFeatureFlags, mod.VkComponentMapping, mod.VkSamplerYcbcrModelConversion, mod.VkSamplerYcbcrRange, mod.VkChromaLocation, mod.VkChromaLocation)
mod.VkImportAndroidHardwareBufferInfoANDROID = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	struct AHardwareBuffer* buffer;
}]], mod.VkStructureType)
mod.VkMemoryGetAndroidHardwareBufferInfoANDROID = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ memory;
}]], mod.VkStructureType, mod.VkDeviceMemory)
mod.VkExternalFormatANDROID = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint64_t externalFormat;
}]], mod.VkStructureType)
mod.VkAndroidHardwareBufferFormatProperties2ANDROID = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ format;
	uint64_t externalFormat;
	$ formatFeatures;
	$ samplerYcbcrConversionComponents;
	$ suggestedYcbcrModel;
	$ suggestedYcbcrRange;
	$ suggestedXChromaOffset;
	$ suggestedYChromaOffset;
}]], mod.VkStructureType, mod.VkFormat, mod.VkFormatFeatureFlags2, mod.VkComponentMapping, mod.VkSamplerYcbcrModelConversion, mod.VkSamplerYcbcrRange, mod.VkChromaLocation, mod.VkChromaLocation)
mod.PFN_vkGetAndroidHardwareBufferPropertiesANDROID = ffi.typeof([[$ (*)($ , const struct AHardwareBuffer*, $*)]], mod.VkResult, mod.VkDevice, mod.VkAndroidHardwareBufferPropertiesANDROID)
mod.PFN_vkGetMemoryAndroidHardwareBufferANDROID = ffi.typeof([[$ (*)($ , const $*, struct AHardwareBuffer**)]], mod.VkResult, mod.VkDevice, mod.VkMemoryGetAndroidHardwareBufferInfoANDROID)
ffi.cdef([[$  vkGetAndroidHardwareBufferPropertiesANDROID($ , const struct AHardwareBuffer*, $*);]], mod.VkResult, mod.VkDevice, mod.VkAndroidHardwareBufferPropertiesANDROID)
ffi.cdef([[$  vkGetMemoryAndroidHardwareBufferANDROID($ , const $*, struct AHardwareBuffer**);]], mod.VkResult, mod.VkDevice, mod.VkMemoryGetAndroidHardwareBufferInfoANDROID)
mod.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ externalFormatResolve;
}]], mod.VkStructureType, mod.VkBool32)
mod.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ nullColorAttachmentWithExternalFormatResolve;
	$ externalFormatResolveChromaOffsetX;
	$ externalFormatResolveChromaOffsetY;
}]], mod.VkStructureType, mod.VkBool32, mod.VkChromaLocation, mod.VkChromaLocation)
mod.VkAndroidHardwareBufferFormatResolvePropertiesANDROID = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ colorAttachmentFormat;
}]], mod.VkStructureType, mod.VkFormat)
mod.VkIOSSurfaceCreateFlagsMVK = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkIOSSurfaceCreateInfoMVK = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const void* pView;
}]], mod.VkStructureType, mod.VkIOSSurfaceCreateFlagsMVK)
mod.PFN_vkCreateIOSSurfaceMVK = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkIOSSurfaceCreateInfoMVK, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkCreateIOSSurfaceMVK($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkIOSSurfaceCreateInfoMVK, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.VkMacOSSurfaceCreateFlagsMVK = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMacOSSurfaceCreateInfoMVK = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const void* pView;
}]], mod.VkStructureType, mod.VkMacOSSurfaceCreateFlagsMVK)
mod.PFN_vkCreateMacOSSurfaceMVK = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkMacOSSurfaceCreateInfoMVK, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkCreateMacOSSurfaceMVK($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkMacOSSurfaceCreateInfoMVK, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.CAMetalLayer = ffi.typeof([[void ]])
mod.VkMetalSurfaceCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkMetalSurfaceCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	const $* pLayer;
}]], mod.VkStructureType, mod.VkMetalSurfaceCreateFlagsEXT, mod.CAMetalLayer)
mod.PFN_vkCreateMetalSurfaceEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkMetalSurfaceCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkCreateMetalSurfaceEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkMetalSurfaceCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.MTLDevice_id = ffi.typeof([[void*]])
mod.MTLCommandQueue_id = ffi.typeof([[void*]])
mod.MTLBuffer_id = ffi.typeof([[void*]])
mod.MTLTexture_id = ffi.typeof([[void*]])
mod.IOSurfaceRef = ffi.typeof([[void*]])
mod.MTLSharedEvent_id = ffi.typeof([[void*]])
mod.VkExportMetalObjectTypeFlagBitsEXT = ffi.typeof([[enum {
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = 0x00000001,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = 0x00000002,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = 0x00000004,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = 0x00000008,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = 0x00000010,
	VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = 0x00000020,
	VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF,
}]])
mod.VkExportMetalObjectTypeFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkExportMetalObjectCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ exportObjectType;
}]], mod.VkStructureType, mod.VkExportMetalObjectTypeFlagBitsEXT)
mod.VkExportMetalObjectsInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
}]], mod.VkStructureType)
mod.VkExportMetalDeviceInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ mtlDevice;
}]], mod.VkStructureType, mod.MTLDevice_id)
mod.VkExportMetalCommandQueueInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ queue;
	$ mtlCommandQueue;
}]], mod.VkStructureType, mod.VkQueue, mod.MTLCommandQueue_id)
mod.VkExportMetalBufferInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ mtlBuffer;
}]], mod.VkStructureType, mod.VkDeviceMemory, mod.MTLBuffer_id)
mod.VkImportMetalBufferInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ mtlBuffer;
}]], mod.VkStructureType, mod.MTLBuffer_id)
mod.VkExportMetalTextureInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ imageView;
	$ bufferView;
	$ plane;
	$ mtlTexture;
}]], mod.VkStructureType, mod.VkImage, mod.VkImageView, mod.VkBufferView, mod.VkImageAspectFlagBits, mod.MTLTexture_id)
mod.VkImportMetalTextureInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ plane;
	$ mtlTexture;
}]], mod.VkStructureType, mod.VkImageAspectFlagBits, mod.MTLTexture_id)
mod.VkExportMetalIOSurfaceInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ image;
	$ ioSurface;
}]], mod.VkStructureType, mod.VkImage, mod.IOSurfaceRef)
mod.VkImportMetalIOSurfaceInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ ioSurface;
}]], mod.VkStructureType, mod.IOSurfaceRef)
mod.VkExportMetalSharedEventInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ semaphore;
	$ event;
	$ mtlSharedEvent;
}]], mod.VkStructureType, mod.VkSemaphore, mod.VkEvent, mod.MTLSharedEvent_id)
mod.VkImportMetalSharedEventInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ mtlSharedEvent;
}]], mod.VkStructureType, mod.MTLSharedEvent_id)
mod.PFN_vkExportMetalObjectsEXT = ffi.typeof([[void (*)($ , $*)]], mod.VkDevice, mod.VkExportMetalObjectsInfoEXT)
ffi.cdef([[void  vkExportMetalObjectsEXT($ , $*);]], mod.VkDevice, mod.VkExportMetalObjectsInfoEXT)
mod.VkImportMemoryMetalHandleInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ handleType;
	void* handle;
}]], mod.VkStructureType, mod.VkExternalMemoryHandleTypeFlagBits)
mod.VkMemoryMetalHandlePropertiesEXT = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint32_t memoryTypeBits;
}]], mod.VkStructureType)
mod.VkMemoryGetMetalHandleInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ memory;
	$ handleType;
}]], mod.VkStructureType, mod.VkDeviceMemory, mod.VkExternalMemoryHandleTypeFlagBits)
mod.PFN_vkGetMemoryMetalHandleEXT = ffi.typeof([[$ (*)($ , const $*, void**)]], mod.VkResult, mod.VkDevice, mod.VkMemoryGetMetalHandleInfoEXT)
mod.PFN_vkGetMemoryMetalHandlePropertiesEXT = ffi.typeof([[$ (*)($ , $ , const void*, $*)]], mod.VkResult, mod.VkDevice, mod.VkExternalMemoryHandleTypeFlagBits, mod.VkMemoryMetalHandlePropertiesEXT)
ffi.cdef([[$  vkGetMemoryMetalHandleEXT($ , const $*, void**);]], mod.VkResult, mod.VkDevice, mod.VkMemoryGetMetalHandleInfoEXT)
ffi.cdef([[$  vkGetMemoryMetalHandlePropertiesEXT($ , $ , const void*, $*);]], mod.VkResult, mod.VkDevice, mod.VkExternalMemoryHandleTypeFlagBits, mod.VkMemoryMetalHandlePropertiesEXT)
mod.VkViSurfaceCreateFlagsNN = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkViSurfaceCreateInfoNN = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	void* window;
}]], mod.VkStructureType, mod.VkViSurfaceCreateFlagsNN)
mod.PFN_vkCreateViSurfaceNN = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkViSurfaceCreateInfoNN, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkCreateViSurfaceNN($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkViSurfaceCreateInfoNN, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.VkWaylandSurfaceCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkWaylandSurfaceCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	struct wl_display* display;
	struct wl_surface* surface;
}]], mod.VkStructureType, mod.VkWaylandSurfaceCreateFlagsKHR)
mod.PFN_vkCreateWaylandSurfaceKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkWaylandSurfaceCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR = ffi.typeof([[$ (*)($ , uint32_t , struct wl_display*)]], mod.VkBool32, mod.VkPhysicalDevice)
ffi.cdef([[$  vkCreateWaylandSurfaceKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkWaylandSurfaceCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkGetPhysicalDeviceWaylandPresentationSupportKHR($ , uint32_t , struct wl_display*);]], mod.VkBool32, mod.VkPhysicalDevice)
mod.VkXlibSurfaceCreateFlagsKHR = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkXlibSurfaceCreateInfoKHR = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$* dpy;
	$ window;
}]], mod.VkStructureType, mod.VkXlibSurfaceCreateFlagsKHR, mod.Display, mod.Window)
mod.PFN_vkCreateXlibSurfaceKHR = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkXlibSurfaceCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR = ffi.typeof([[$ (*)($ , uint32_t , $*, $ )]], mod.VkBool32, mod.VkPhysicalDevice, mod.Display, mod.VisualID)
ffi.cdef([[$  vkCreateXlibSurfaceKHR($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkXlibSurfaceCreateInfoKHR, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkGetPhysicalDeviceXlibPresentationSupportKHR($ , uint32_t , $*, $ );]], mod.VkBool32, mod.VkPhysicalDevice, mod.Display, mod.VisualID)
mod.VkDirectFBSurfaceCreateFlagsEXT = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkDirectFBSurfaceCreateInfoEXT = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$* dfb;
	$* surface;
}]], mod.VkStructureType, mod.VkDirectFBSurfaceCreateFlagsEXT, mod.IDirectFB, mod.IDirectFBSurface)
mod.PFN_vkCreateDirectFBSurfaceEXT = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkDirectFBSurfaceCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT = ffi.typeof([[$ (*)($ , uint32_t , $*)]], mod.VkBool32, mod.VkPhysicalDevice, mod.IDirectFB)
ffi.cdef([[$  vkCreateDirectFBSurfaceEXT($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkDirectFBSurfaceCreateInfoEXT, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkGetPhysicalDeviceDirectFBPresentationSupportEXT($ , uint32_t , $*);]], mod.VkBool32, mod.VkPhysicalDevice, mod.IDirectFB)
mod.VkStreamDescriptorSurfaceCreateFlagsGGP = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkStreamDescriptorSurfaceCreateInfoGGP = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	$ streamDescriptor;
}]], mod.VkStructureType, mod.VkStreamDescriptorSurfaceCreateFlagsGGP, mod.GgpStreamDescriptor)
mod.PFN_vkCreateStreamDescriptorSurfaceGGP = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkStreamDescriptorSurfaceCreateInfoGGP, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkCreateStreamDescriptorSurfaceGGP($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkStreamDescriptorSurfaceCreateInfoGGP, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.VkPresentFrameTokenGGP = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ frameToken;
}]], mod.VkStructureType, mod.GgpFrameToken)
mod.VkScreenSurfaceCreateFlagsQNX = ffi.typeof([[$ ]], mod.VkFlags)
mod.VkScreenSurfaceCreateInfoQNX = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	$ flags;
	struct _screen_context* context;
	struct _screen_window* window;
}]], mod.VkStructureType, mod.VkScreenSurfaceCreateFlagsQNX)
mod.PFN_vkCreateScreenSurfaceQNX = ffi.typeof([[$ (*)($ , const $*, const $*, $*)]], mod.VkResult, mod.VkInstance, mod.VkScreenSurfaceCreateInfoQNX, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
mod.PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX = ffi.typeof([[$ (*)($ , uint32_t , struct _screen_window*)]], mod.VkBool32, mod.VkPhysicalDevice)
ffi.cdef([[$  vkCreateScreenSurfaceQNX($ , const $*, const $*, $*);]], mod.VkResult, mod.VkInstance, mod.VkScreenSurfaceCreateInfoQNX, mod.VkAllocationCallbacks, mod.VkSurfaceKHR)
ffi.cdef([[$  vkGetPhysicalDeviceScreenPresentationSupportQNX($ , uint32_t , struct _screen_window*);]], mod.VkBool32, mod.VkPhysicalDevice)
mod.VkScreenBufferPropertiesQNX = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ allocationSize;
	uint32_t memoryTypeBits;
}]], mod.VkStructureType, mod.VkDeviceSize)
mod.VkScreenBufferFormatPropertiesQNX = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ format;
	uint64_t externalFormat;
	uint64_t screenUsage;
	$ formatFeatures;
	$ samplerYcbcrConversionComponents;
	$ suggestedYcbcrModel;
	$ suggestedYcbcrRange;
	$ suggestedXChromaOffset;
	$ suggestedYChromaOffset;
}]], mod.VkStructureType, mod.VkFormat, mod.VkFormatFeatureFlags, mod.VkComponentMapping, mod.VkSamplerYcbcrModelConversion, mod.VkSamplerYcbcrRange, mod.VkChromaLocation, mod.VkChromaLocation)
mod.VkImportScreenBufferInfoQNX = ffi.typeof([[struct {
	$ sType;
	const void* pNext;
	struct _screen_buffer* buffer;
}]], mod.VkStructureType)
mod.VkExternalFormatQNX = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	uint64_t externalFormat;
}]], mod.VkStructureType)
mod.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = ffi.typeof([[struct {
	$ sType;
	void* pNext;
	$ screenBufferImport;
}]], mod.VkStructureType, mod.VkBool32)
mod.PFN_vkGetScreenBufferPropertiesQNX = ffi.typeof([[$ (*)($ , const struct _screen_buffer*, $*)]], mod.VkResult, mod.VkDevice, mod.VkScreenBufferPropertiesQNX)
ffi.cdef([[$  vkGetScreenBufferPropertiesQNX($ , const struct _screen_buffer*, $*);]], mod.VkResult, mod.VkDevice, mod.VkScreenBufferPropertiesQNX)

return mod
